theory AndrewSecureRPC begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, pred/1, sdec/2, senc/2, snd/1, succ/1
equations:
    fst(<x.1, x.2>) = x.1,
    pred(succ(x)) = x,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2



rule (modulo E) Create_Key:
   [ Fr( ~sk ) ]
  --[ Secret( $A, $B, ~sk ) ]->
   [ !Key( $A, $B, ~sk ), !Key( $B, $A, ~sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_sk:
   [ !Key( $A, $B, ~sk ) ]
  --[ Reveal( $A, $B ), Reveal( $B, $A ) ]->
   [ Out( ~sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_1:
   [ !Key( $A, $B, ~sk ), Fr( ~na ) ]
  --[ AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', ~na>, ~sk) ) ]->
   [ Out( <$A, senc(<'1', ~na>, ~sk)> ), StateASend( $A, $B, ~sk, ~na ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) B_1:
   [ In( <x, senc(<'1', xna>, ~sk)> ), !Key( x, $B, ~sk ), Fr( ~nb ) ]
  --[
  AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(xna), ~nb>, ~sk) ),
  AUTO_IN_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk), xna )
  ]->
   [ Out( senc(<'2', succ(xna), ~nb>, ~sk) ), StateB( x, $B, ~sk, xna, ~nb )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_2:
   [
   !Key( $A, $B, ~sk ), StateASend( $A, $B, ~sk, ~na ),
   In( senc(<'2', succ(~na), xnb>, ~sk) )
   ]
  --[
  AUTO_IN_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk), xnb ),
  Running_A( $A, $B, <'A', 'B', ~sk, ~na> )
  ]->
   [
   Out( senc(<'3', succ(xnb)>, ~sk) ),
   StateAReceive( $A, $B, ~sk, ~na, xnb )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) B_2:
   [
   StateB( x, $B, ~sk, xna, ~nb ), In( senc(<'3', succ(~nb)>, ~sk) ),
   Fr( ~nnb ), !Key( x, $B, ~sk ), Fr( ~nsk )
   ]
  --[
  Secret( x, $B, ~nsk ), Running_B( x, $B, <'A', 'B', ~sk, ~nsk> ),
  Commit_B( x, $B, <'A', 'B', ~sk, xna> )
  ]->
   [ Out( senc(<'4', ~nsk, ~nnb>, ~sk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) A_3:
   [
   !Key( $A, $B, ~sk ), In( senc(<'4', nsk, nnb>, ~sk) ),
   StateAReceive( $A, $B, ~sk, ~na, xnb )
   ]
  --[ Commit_A( $A, $B, <'A', 'B', ~sk, nsk> ), Secret( $A, $B, nsk ) ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma secrecy:
  all-traces
  "¬(∃ A B sk #i #j.
      ((Secret( A, B, sk ) @ #i) ∧ (K( sk ) @ #j)) ∧
      (¬(∃ #r. Reveal( A, B ) @ #r)))"
/*
guarded formula characterizing all counter-examples:
"∃ A B sk #i #j.
  (Secret( A, B, sk ) @ #i) ∧ (K( sk ) @ #j)
 ∧
  ∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥"
*/
simplify
solve( Secret( A, B, sk ) @ #i )
  case A_3
  solve( !Key( $A, $B, ~sk ) ▶₀ #i )
    case Create_Key_case_1
    solve( StateAReceive( $A, $B, ~sk, ~na, xnb ) ▶₂ #i )
      case A_2_case_1
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_2
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_3
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_4
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    qed
  next
    case Create_Key_case_2
    solve( StateAReceive( $A, $B, ~sk, ~na, xnb ) ▶₂ #i )
      case A_2_case_1
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_2
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_3
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case A_2_case_4
      solve( !KU( senc(<'4', sk.1, nnb>, ~sk) ) @ #vk.1 )
        case B_2_case_1
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_2
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_3
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case B_2_case_4
        solve( !KU( ~nsk ) @ #vk.1 )
          case B_2
          solve( !KU( ~sk ) @ #vk.7 )
            case Reveal_sk_case_1
            by contradiction /* from formulas */
          next
            case Reveal_sk_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_senc
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
next
  case B_2
  solve( StateB( A, $B, ~sk, xna, ~nb ) ▶₀ #i )
    case B_1_case_1
    solve( !Key( $A, $B, ~sk ) ▶₃ #i )
      case Create_Key_case_1
      solve( !KU( ~nsk ) @ #vk )
        case B_2
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case Create_Key_case_2
      solve( !KU( ~nsk ) @ #vk )
        case B_2
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    qed
  next
    case B_1_case_2
    solve( !Key( $B, $B.1, ~sk ) ▶₃ #i )
      case Create_Key_case_1
      solve( !KU( ~nsk ) @ #vk )
        case B_2
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case Create_Key_case_2
      solve( !KU( ~nsk ) @ #vk )
        case B_2
        solve( !KU( ~sk ) @ #vk.5 )
          case Reveal_sk_case_1
          by contradiction /* from formulas */
        next
          case Reveal_sk_case_2
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
next
  case Create_Key
  solve( !KU( ~sk ) @ #vk )
    case Reveal_sk_case_1
    by contradiction /* from formulas */
  next
    case Reveal_sk_case_2
    by contradiction /* from formulas */
  qed
qed

lemma injectiveagreement_A:
  all-traces
  "∀ A B t #i.
    (Commit_A( A, B, t ) @ #i) ⇒
    ((∃ #j.
       ((Running_B( A, B, t ) @ #j) ∧ (#j < #i)) ∧
       (¬(∃ A2 B2 #i2. (Commit_A( A2, B2, t ) @ #i2) ∧ (¬(#i2 = #i))))) ∨
     (∃ #r. Reveal( A, B ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ A B t #i.
  (Commit_A( A, B, t ) @ #i)
 ∧
  (∀ #j.
    (Running_B( A, B, t ) @ #j)
   ⇒
    ((¬(#j < #i)) ∨
     (∃ A2 B2 #i2. (Commit_A( A2, B2, t ) @ #i2) ∧ ¬(#i2 = #i)))) ∧
  (∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥)"
*/
simplify
solve( !Key( $A, $B, ~sk ) ▶₀ #i )
  case Create_Key_case_1
  solve( StateAReceive( $A, $B, ~sk, ~na, xnb ) ▶₂ #i )
    case A_2_case_1
    solve( !KU( senc(<'4', nsk, nnb>, ~sk) ) @ #vk )
      case B_2_case_1
      solve( (#i2 < #i)  ∥ (#i < #i2) )
        case case_1
        solve( !Key( $A.1, $B.1, ~sk ) ▶₀ #i2 )
          case Create_Key_case_1
          solve( StateAReceive( $A, $B, ~sk, ~na.1, xnb.1 ) ▶₂ #i2 )
            case A_2_case_1
            solve( !KU( senc(<'2', succ(~na), xnb>, ~sk) ) @ #vk.1 )
              case B_1_case_1
              solve( !KU( senc(<'3', succ(~nb.1)>, ~sk) ) @ #vk.2 )
                case A_2_case_1
                solve( !KU( senc(<'1', xna>, ~sk) ) @ #vk.6 )
                  case A_1_case_1
                  solve( !KU( senc(<'4', ~nsk, nnb.1>, ~sk) ) @ #vk.7 )
                    case B_2
                    solve( !KU( senc(<'2', succ(~na.1), xnb>, ~sk) ) @ #vk.7 )
                      case B_1_case_1
                      solve( !KU( senc(<'2', succ(~na.3), ~nb.2>, ~sk) ) @ #vk.10 )
                        case B_1
                        solve( !KU( senc(<'1', ~na>, ~sk) ) @ #vk.10 )
                          case A_1
                          solve( !KU( senc(<'1', ~na.1>, ~sk) ) @ #vk.11 )
                            case A_1
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma injectiveagreement_B:
  all-traces
  "∀ A B t #i.
    (Commit_B( A, B, t ) @ #i) ⇒
    ((∃ #j.
       ((Running_A( A, B, t ) @ #j) ∧ (#j < #i)) ∧
       (¬(∃ A2 B2 #i2. (Commit_B( A2, B2, t ) @ #i2) ∧ (¬(#i2 = #i))))) ∨
     (∃ #r. Reveal( A, B ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ A B t #i.
  (Commit_B( A, B, t ) @ #i)
 ∧
  (∀ #j.
    (Running_A( A, B, t ) @ #j)
   ⇒
    ((¬(#j < #i)) ∨
     (∃ A2 B2 #i2. (Commit_B( A2, B2, t ) @ #i2) ∧ ¬(#i2 = #i)))) ∧
  (∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥)"
*/
simplify
solve( StateB( A, $B, ~sk, xna, ~nb ) ▶₀ #i )
  case B_1_case_1
  solve( !Key( $A, $B, ~sk ) ▶₃ #i )
    case Create_Key_case_1
    solve( !KU( senc(<'3', succ(~nb)>, ~sk) ) @ #vk )
      case A_2_case_4
      solve( !KU( senc(<'1', xna>, ~sk) ) @ #vk.3 )
        case A_1_case_2
        solve( !KU( senc(<'2', succ(~na.1), ~nb>, ~sk) ) @ #vk.4 )
          case B_1
          SOLVED // trace found
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_A:
  all-traces
  "∀ A B t #i.
    (Commit_A( A, B, t ) @ #i) ⇒
    ((∃ #j. (Running_B( A, B, t ) @ #j) ∧ (#j < #i)) ∨
     (∃ #r. Reveal( A, B ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ A B t #i.
  (Commit_A( A, B, t ) @ #i)
 ∧
  (∀ #j. (Running_B( A, B, t ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥)"
*/
simplify
solve( !Key( $A, $B, ~sk ) ▶₀ #i )
  case Create_Key_case_1
  solve( StateAReceive( $A, $B, ~sk, ~na, xnb ) ▶₂ #i )
    case A_2_case_1
    solve( !KU( senc(<'4', nsk, nnb>, ~sk) ) @ #vk )
      case B_2_case_4
      solve( !KU( senc(<'2', succ(~na), xnb>, ~sk) ) @ #vk.1 )
        case B_1_case_1
        solve( !KU( senc(<'3', succ(~nb.1)>, ~sk) ) @ #vk.2 )
          case A_2_case_1
          solve( !KU( senc(<'1', xna>, ~sk) ) @ #vk.5 )
            case A_1_case_1
            solve( !KU( senc(<'2', succ(~na.2), ~nb.1>, ~sk) ) @ #vk.9 )
              case B_1
              solve( !KU( senc(<'1', ~na>, ~sk) ) @ #vk.9 )
                case A_1
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_B:
  all-traces
  "∀ A B t #i.
    (Commit_B( A, B, t ) @ #i) ⇒
    ((∃ #j. (Running_A( A, B, t ) @ #j) ∧ (#j < #i)) ∨
     (∃ #r. Reveal( A, B ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ A B t #i.
  (Commit_B( A, B, t ) @ #i)
 ∧
  (∀ #j. (Running_A( A, B, t ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥)"
*/
simplify
solve( StateB( A, $B, ~sk, xna, ~nb ) ▶₀ #i )
  case B_1_case_1
  solve( !Key( $A, $B, ~sk ) ▶₃ #i )
    case Create_Key_case_1
    solve( !KU( senc(<'3', succ(~nb)>, ~sk) ) @ #vk )
      case A_2_case_4
      solve( !KU( senc(<'1', xna>, ~sk) ) @ #vk.3 )
        case A_1_case_2
        solve( !KU( senc(<'2', succ(~na.1), ~nb>, ~sk) ) @ #vk.4 )
          case B_1
          SOLVED // trace found
        qed
      qed
    qed
  qed
qed

lemma Session_key_honest_setup:
  exists-trace
  "∃ A B t s #i #j.
    (((Commit_B( A, B, t ) @ #i) ∧ (Commit_A( A, B, s ) @ #j)) ∧ (#i < #j)) ∧
    (¬(∃ #r. Reveal( A, B ) @ #r))"
/*
guarded formula characterizing all satisfying traces:
"∃ A B t s #i #j.
  (Commit_B( A, B, t ) @ #i) ∧ (Commit_A( A, B, s ) @ #j)
 ∧
  (#i < #j) ∧ (∀ #r. (Reveal( A, B ) @ #r) ⇒ ⊥)"
*/
simplify
solve( StateB( $A, $B, ~sk, xna, ~nb ) ▶₀ #i )
  case B_1_case_1
  solve( !Key( $A, $B, ~sk ) ▶₃ #i )
    case Create_Key_case_1
    solve( !Key( $A, $B, ~sk.1 ) ▶₀ #j )
      case Create_Key_case_1
      solve( StateAReceive( $A, $B, ~sk.1, ~na, xnb ) ▶₂ #j )
        case A_2_case_1
        solve( !KU( senc(<'3', succ(~nb)>, ~sk) ) @ #vk )
          case A_2_case_1
          solve( !KU( senc(<'4', nsk.1, nnb.1>, ~sk.1) ) @ #vk.1 )
            case B_2_case_1
            solve( !KU( senc(<'1', xna>, ~sk) ) @ #vk.5 )
              case A_1_case_1
              solve( !KU( senc(<'2', succ(~na.1), xnb>, ~sk.1) ) @ #vk.6 )
                case B_1_case_1
                solve( !KU( senc(<'2', succ(~na.2), ~nb>, ~sk) ) @ #vk.8 )
                  case B_1
                  solve( !KU( senc(<'3', succ(~nb.2)>, ~sk.1) ) @ #vk.9 )
                    case A_2_case_1
                    solve( !KU( senc(<'1', xna>, ~sk.1) ) @ #vk.10 )
                      case A_1_case_1
                      solve( !KU( senc(<'2', succ(~na.3), ~nb.2>, ~sk.1) ) @ #vk.12 )
                        case B_1
                        solve( !KU( senc(<'1', ~na.1>, ~sk.1) ) @ #vk.12 )
                          case A_1
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

lemma AUTO_typing [sources]:
  all-traces
  "((⊤) ∧
    (∀ x m #i.
      (AUTO_IN_TERM_0_0_1_0_1__B_1( m, x ) @ #i) ⇒
      ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
       (∃ #j. (AUTO_OUT_TERM_0_0_1_0_1__B_1( m ) @ #j) ∧ (#j < #i))))) ∧
   (∀ x m #i.
     (AUTO_IN_TERM_2_0_0_1_1__A_2( m, x ) @ #i) ⇒
     ((∃ #j. (!KU( x ) @ #j) ∧ (#j < #i)) ∨
      (∃ #j. (AUTO_OUT_TERM_2_0_0_1_1__A_2( m ) @ #j) ∧ (#j < #i))))"
/*
guarded formula characterizing all counter-examples:
"((∃ x m #i.
    (AUTO_IN_TERM_0_0_1_0_1__B_1( m, x ) @ #i)
   ∧
    (∀ #j. (!KU( x ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (AUTO_OUT_TERM_0_0_1_0_1__B_1( m ) @ #j) ⇒ ¬(#j < #i))) ∨
  (∃ x m #i.
    (AUTO_IN_TERM_2_0_0_1_1__A_2( m, x ) @ #i)
   ∧
    (∀ #j. (!KU( x ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (AUTO_OUT_TERM_2_0_0_1_1__A_2( m ) @ #j) ⇒ ¬(#j < #i))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∃ x m #i.
           (AUTO_IN_TERM_0_0_1_0_1__B_1( m, x ) @ #i)
          ∧
           (∀ #j. (!KU( x ) @ #j) ⇒ ¬(#j < #i)) ∧
           (∀ #j. (AUTO_OUT_TERM_0_0_1_0_1__B_1( m ) @ #j) ⇒ ¬(#j < #i)))  ∥
         (∃ x m #i.
           (AUTO_IN_TERM_2_0_0_1_1__A_2( m, x ) @ #i)
          ∧
           (∀ #j. (!KU( x ) @ #j) ⇒ ¬(#j < #i)) ∧
           (∀ #j. (AUTO_OUT_TERM_2_0_0_1_1__A_2( m ) @ #j) ⇒ ¬(#j < #i))) )
    case case_1
    solve( (last(#i))  ∥
           (∃ #j. (!KU( x.1 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
           (∃ #j.
             (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', x.1>, ~sk) ) @ #j)
            ∧
             (¬(last(#j))) ∧ (#j < #i)) )
      case case_1
      solve( !Key( x, $B, ~sk ) ▶₁ #i )
        case Create_Key_case_1
        solve( !KU( senc(<'1', x>, ~sk) ) @ #vk.2 )
          case A_1_case_1
          by contradiction /* from formulas */
        next
          case A_1_case_2
          by contradiction /* from formulas */
        next
          case A_2_case_1
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_2
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_3
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_4
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case B_1_case_1
          solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case B_1_case_2
          solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case c_senc
          by contradiction /* from formulas */
        qed
      next
        case Create_Key_case_2
        solve( !KU( senc(<'1', x>, ~sk) ) @ #vk.2 )
          case A_1_case_1
          by contradiction /* from formulas */
        next
          case A_1_case_2
          by contradiction /* from formulas */
        next
          case A_2_case_1
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_2
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_3
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case A_2_case_4
          solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), xnb>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case B_1_case_1
          solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case B_1_case_2
          solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                 (∃ #j.
                   (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                  ∧
                   (¬(last(#j))) ∧ (#j < #vr.1)) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* impossible chain */
          qed
        next
          case c_senc
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (last(#i))  ∥
           (∃ #j. (!KU( x ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
           (∃ #j.
             (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na), x>, ~sk) ) @ #j)
            ∧
             (¬(last(#j))) ∧ (#j < #i)) )
      case case_1
      solve( !Key( $A, $B, ~sk ) ▶₀ #i )
        case Create_Key_case_1
        solve( StateASend( $A, $B, ~sk, ~na ) ▶₁ #i )
          case A_1_case_1
          solve( !KU( senc(<'2', succ(~na), x>, ~sk) ) @ #vk )
            case A_2_case_1
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_2
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_3
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_4
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_1
            by contradiction /* from formulas */
          next
            case B_1_case_2
            by contradiction /* from formulas */
          next
            case B_1_case_3
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_4
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case c_senc
            by contradiction /* from formulas */
          qed
        next
          case A_1_case_2
          solve( !KU( senc(<'2', succ(~na), x>, ~sk) ) @ #vk )
            case A_2_case_1
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_2
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_3
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_4
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_1
            by contradiction /* from formulas */
          next
            case B_1_case_2
            by contradiction /* from formulas */
          next
            case B_1_case_3
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_4
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case c_senc
            by contradiction /* from formulas */
          qed
        qed
      next
        case Create_Key_case_2
        solve( StateASend( $A, $B, ~sk, ~na ) ▶₁ #i )
          case A_1_case_1
          solve( !KU( senc(<'2', succ(~na), x>, ~sk) ) @ #vk )
            case A_2_case_1
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_2
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_3
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_4
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_1
            by contradiction /* from formulas */
          next
            case B_1_case_2
            by contradiction /* from formulas */
          next
            case B_1_case_3
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_4
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case c_senc
            by contradiction /* from formulas */
          qed
        next
          case A_1_case_2
          solve( !KU( senc(<'2', succ(~na), x>, ~sk) ) @ #vk )
            case A_2_case_1
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_2
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_3
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case A_2_case_4
            solve( (∃ #j. (!KU( xnb ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_2_0_0_1_1__A_2( senc(<'2', succ(~na.1), xnb>, ~sk.1)
                      ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_1
            by contradiction /* from formulas */
          next
            case B_1_case_2
            by contradiction /* from formulas */
          next
            case B_1_case_3
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case B_1_case_4
            solve( (∃ #j. (!KU( xna ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.2))  ∥
                   (∃ #j.
                     (AUTO_OUT_TERM_0_0_1_0_1__B_1( senc(<'1', xna>, ~sk.1) ) @ #j)
                    ∧
                     (¬(last(#j))) ∧ (#j < #vr.2)) )
              case case_1
              by contradiction /* cyclic */
            next
              case case_2
              by contradiction /* impossible chain */
            qed
          next
            case c_senc
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    qed
  qed
qed

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: examples/features/auto-sources/spore/AS_RPC.spthy

------------------------------------------------------------------------------
analyzed: examples/features/auto-sources/spore/AS_RPC.spthy

  output:          examples/features/auto-sources/spore/AS_RPC.spthy.tmp
  processing time: 40.523810508s
  secrecy (all-traces): verified (187 steps)
  injectiveagreement_A (all-traces): falsified - found trace (16 steps)
  injectiveagreement_B (all-traces): falsified - found trace (7 steps)
  noninjectiveagreement_A (all-traces): falsified - found trace (10 steps)
  noninjectiveagreement_B (all-traces): falsified - found trace (7 steps)
  Session_key_honest_setup (exists-trace): verified (15 steps)
  AUTO_typing (all-traces): verified (146 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: examples/features/auto-sources/spore/AS_RPC.spthy

  output:          examples/features/auto-sources/spore/AS_RPC.spthy.tmp
  processing time: 40.523810508s
  secrecy (all-traces): verified (187 steps)
  injectiveagreement_A (all-traces): falsified - found trace (16 steps)
  injectiveagreement_B (all-traces): falsified - found trace (7 steps)
  noninjectiveagreement_A (all-traces): falsified - found trace (10 steps)
  noninjectiveagreement_B (all-traces): falsified - found trace (7 steps)
  Session_key_honest_setup (exists-trace): verified (15 steps)
  AUTO_typing (all-traces): verified (146 steps)

==============================================================================
*/
