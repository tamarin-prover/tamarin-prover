theory Contract begin

// Function signature and definition of the equational theory E

functions: check_getmsg/2, checkpcs/5, convertpcs/2, fakepcs/4, fst/1,
           pair/2, pcs/3, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    check_getmsg(sign(xm, xsk), pk(xsk)) = xm,
    checkpcs(xc, xpk, pk(ysk), zpk, fakepcs(xpk, ysk, zpk, xc)) = true,
    checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xc, xsk), ypk, zpk)) = true,
    convertpcs(zsk, pcs(sign(xc, xsk), ypk, pk(zsk))) = sign(xc, xsk),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

heuristic: p

section{* GM Protocol for Contract signing *}

lemma aborted_and_resolved_exclusive:
  all-traces
  "¬(∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j)"
*/
simplify
solve( State_111121212111( ct, pk2, sk1, skT ) ▶₀ #i )
  case insignctpkskpksignctpkskpkskskT_0_11112121211
  solve( State_1111212121211( ct, sk1.1, sk2, skT ) ▶₀ #j )
    case insignsignctsksignctskskT_0_111121212121
    solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
           ) @ #vk )
      case c_sign
      solve( !KU( sign(<sign(ct, sk1.1), sign(ct, sk2)>, ~n.1) ) @ #vk.1 )
        case c_sign
        by solve( !KU( ~n ) @ #vk.3 )
      next
        case outsignconvertpcsskTypcsysigskT_0_1111211111112111
        solve( !KU( pcs(sign(ct, sk1.1), pk(sk2), pk(~n.1)) ) @ #vk.18 )
          case c_pcs
          by solve( !KU( ~n ) @ #vk.4 )
        qed
      next
        case outsignysigconvertpcsskTypcsskT_0_111121211111112111
        solve( !KU( pcs(sign(ct, sk2), pk(sk1.1), pk(~n.1)) ) @ #vk.19 )
          case c_pcs
          by solve( !KU( ~n ) @ #vk.4 )
        qed
      qed
    next
      case outsignctpkpkysigskT_0_111111112111
      solve( !KU( sign(<sign(ct, sk1.1), sign(ct, sk2)>, ~n.1) ) @ #vk.1 )
        case c_sign
        by solve( !KU( ~n.1 ) @ #vk.12 )
      next
        case outsignconvertpcsskTypcsysigskT_0_1111211111112111
        solve( ((#vr.41 < #vr.51) ∧
                (∃ #t2.
                  (Unlock_0( '0', ~n.2, ct ) @ #t2)
                 ∧
                  (#vr.41 < #t2) ∧
                  (#t2 < #vr.51) ∧
                  (∀ #t0 pp. (Unlock( pp, ~n.2, ct ) @ #t0) ⇒ #t0 = #t2) ∧
                  (∀ pp lpp #t0.
                    (Lock( pp, lpp, ct ) @ #t0)
                   ⇒
                    ((#t0 < #vr.41) ∨ (#t0 = #vr.41) ∨ (#t2 < #t0))) ∧
                  (∀ pp lpp #t0.
                    (Unlock( pp, lpp, ct ) @ #t0)
                   ⇒
                    ((#t0 < #vr.41) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
               (#vr.51 < #vr.41) )
          case case_1
          by contradiction /* cyclic */
        next
          case case_2
          by contradiction /* cyclic */
        qed
      next
        case outsignysigconvertpcsskTypcsskT_0_111121211111112111
        solve( ((#vr.41 < #vr.51) ∧
                (∃ #t2.
                  (Unlock_0( '0', ~n.2, ct ) @ #t2)
                 ∧
                  (#vr.41 < #t2) ∧
                  (#t2 < #vr.51) ∧
                  (∀ #t0 pp. (Unlock( pp, ~n.2, ct ) @ #t0) ⇒ #t0 = #t2) ∧
                  (∀ pp lpp #t0.
                    (Lock( pp, lpp, ct ) @ #t0)
                   ⇒
                    ((#t0 < #vr.41) ∨ (#t0 = #vr.41) ∨ (#t2 < #t0))) ∧
                  (∀ pp lpp #t0.
                    (Unlock( pp, lpp, ct ) @ #t0)
                   ⇒
                    ((#t0 < #vr.41) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
               (#vr.51 < #vr.41) )
          case case_1
          by contradiction /* cyclic */
        next
          case case_2
          by contradiction /* cyclic */
        qed
      qed
    qed
  qed
qed

lemma aborted_contract_reachable:
  exists-trace
  "(((∃ ct #i. AbortCert( ct ) @ #i) ∧
     (∀ ct1 ct2 #i1 #i2.
       ((Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (AbortCert( ct ) @ #i)) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( State_111121212111( ct, pk2, sk1, skT ) ▶₀ #i )
  case insignctpkskpksignctpkskpkskskT_0_11112121211
  solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
         ) @ #vk )
    case outsignctpkpkysigskT_0_111111112111
    solve( !KU( pk(sk1) ) @ #vk.6 )
      case c_pk
      solve( !KU( sign(<ct, pk(sk1), pk2>, sk1) ) @ #vk.9 )
        case c_sign
        SOLVED // trace found
      qed
    qed
  qed
qed

lemma resolved1_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct1 ct2 #i1 #i2.
      ((Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( State_1111212121211( ct, sk1, sk2, skT ) ▶₀ #i )
  case insignsignctsksignctskskT_0_111121212121
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case outsignysigconvertpcsskTypcsskT_0_111121211111112111
    solve( !KU( pcs(sign(ct, sk2), pk(sk1), pk(~n)) ) @ #vk.11 )
      case c_pcs
      solve( !KU( pk(sk1) ) @ #vk.7 )
        case c_pk
        solve( !KU( pk(sk2) ) @ #vk.10 )
          case c_pk
          solve( !KU( sign(ct, sk1) ) @ #vk.11 )
            case c_sign
            solve( !KU( sign(ct, sk2) ) @ #vk.12 )
              case c_sign
              solve( !KU( pk(~n) ) @ #vk.13 )
                case outpkskT_0_11
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma resolved2_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct1 ct2 #i1 #i2.
     ((Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2)) ⇒ (#i1 = #i2))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2) ⇒ #i1 = #i2)"
*/
simplify
solve( State_1111212121211( ct, sk1, sk2, skT ) ▶₀ #i )
  case insignsignctsksignctskskT_0_111121212121
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case outsignconvertpcsskTypcsysigskT_0_1111211111112111
    solve( !KU( pcs(sign(ct, sk1), pk(sk2), pk(~n)) ) @ #vk.10 )
      case c_pcs
      solve( !KU( pk(sk1) ) @ #vk.7 )
        case c_pk
        solve( !KU( pk(sk2) ) @ #vk.10 )
          case c_pk
          solve( !KU( sign(ct, sk2) ) @ #vk.11 )
            case c_sign
            solve( !KU( sign(ct, sk1) ) @ #vk.12 )
              case c_sign
              solve( !KU( pk(~n) ) @ #vk.13 )
                case outpkskT_0_11
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

rule (modulo E) Init[color=#ffffff, process="!"]:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_[color=#ffffff, process="!"]:
   [ State_( ) ] --> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_[color=#ffffff, process="!"]:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newskT_0_1[color=#ffffff, process="new skT;"]:
   [ State_1( ), Fr( skT ) ] --> [ State_11( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) outpkskT_0_11[color=#ffffff, process="out(pk(skT));"]:
   [ State_11( skT ) ] --> [ State_111( skT ), Out( pk(skT) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111[color=#ffffff, process="!"]:
   [ State_111( skT ) ] --> [ !Semistate_1111( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_111[color=#ffffff, process="!"]:
   [ !Semistate_1111( skT ) ] --> [ State_1111( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111[color=#ffffff, process="|"]:
   [ State_1111( skT ) ] --> [ State_11111( skT ), State_11112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) inabortctpkpkysig_0_11111[color=#804046,
                                          process="in(<'abort', ct, pk1, pk2, ysig>);"]:
   [ State_11111( skT ), In( <'abort', ct, pk1, pk2, ysig> ) ]
  -->
   [ State_111111( ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ifcheckgetmsgysigpkctpkpk_0_111111[color=#804046,
                                                   process="if check_getmsg(ysig, pk1)=<ct, pk1, pk2>"]:
   [ State_111111( ct, pk1, pk2, skT, ysig ) ]
  --[ Pred_Eq( check_getmsg(ysig, pk1), <ct, pk1, pk2> ) ]->
   [ State_1111111( ct, pk1, pk2, skT, ysig ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkctpkpk_0_111111[color=#804046,
                                                      process="if check_getmsg(ysig, pk1)=<ct, pk1, pk2>"]:
     [ State_111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_Eq( z, <ct, pk1, pk2> ) ]->
     [ State_1111111( ct, pk1, pk2, skT, ysig ) ]
    variants (modulo AC)
    1. pk1   = pk1.7
       ysig  = ysig.7
       z     = check_getmsg(ysig.7, pk1.7)
    
    2. pk1   = pk(x.7)
       ysig  = sign(x.10, x.7)
       z     = x.10
  */

rule (modulo E) ifcheckgetmsgysigpkctpkpk_1_111111[color=#804046,
                                                   process="if check_getmsg(ysig, pk1)=<ct, pk1, pk2>"]:
   [ State_111111( ct, pk1, pk2, skT, ysig ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig, pk1), <ct, pk1, pk2> ) ]->
   [ State_1111112( ct, pk1, pk2, skT, ysig ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkctpkpk_1_111111[color=#804046,
                                                      process="if check_getmsg(ysig, pk1)=<ct, pk1, pk2>"]:
     [ State_111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_Not_Eq( z, <ct, pk1, pk2> ) ]->
     [ State_1111112( ct, pk1, pk2, skT, ysig ) ]
    variants (modulo AC)
    1. pk1   = pk1.7
       ysig  = ysig.7
       z     = check_getmsg(ysig.7, pk1.7)
    
    2. pk1   = pk(x.7)
       ysig  = sign(x.10, x.7)
       z     = x.10
  */

rule (modulo E) lockct_0_1111111[color=#804046, process="lock ct;"]:
   [ State_1111111( ct, pk1, pk2, skT, ysig ), Fr( lock ) ]
  --[ Lock_0( '0', lock, ct ), Lock( '0', lock, ct ) ]->
   [ State_11111111( ct, lock, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookupctasstate_0_11111111[color=#804046,
                                           process="lookup ct as state"]:
   [ State_11111111( ct, lock, pk1, pk2, skT, ysig ) ]
  --[ IsIn( ct, state ) ]->
   [ State_111111111( ct, lock, pk1, pk2, skT, state, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookupctasstate_1_11111111[color=#804046,
                                           process="lookup ct as state"]:
   [ State_11111111( ct, lock, pk1, pk2, skT, ysig ) ]
  --[ IsNotSet( ct ) ]->
   [ State_111111112( ct, lock, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlockct_0_111111111[color=#804046,
                                     process="unlock ct;"]:
   [ State_111111111( ct, lock, pk1, pk2, skT, state, ysig ) ]
  --[ Unlock_0( '0', lock, ct ), Unlock( '0', lock, ct ) ]->
   [ State_1111111111( ct, lock, pk1, pk2, skT, state, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111111111[color=#804046, process="0"]:
   [ State_1111111111( ct, lock, pk1, pk2, skT, state, ysig ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) insertctaborted_0_111111112[color=#804046,
                                            process="insert ct,'aborted';"]:
   [ State_111111112( ct, lock, pk1, pk2, skT, ysig ) ]
  --[ Insert( ct, 'aborted' ) ]->
   [ State_1111111121( ct, lock, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventAbortct_0_1111111121[color=#804046,
                                          process="event Abort1( ct );"]:
   [ State_1111111121( ct, lock, pk1, pk2, skT, ysig ) ]
  --[ Abort1( ct ) ]->
   [ State_11111111211( ct, lock, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlockct_0_11111111211[color=#804046,
                                       process="unlock ct;"]:
   [ State_11111111211( ct, lock, pk1, pk2, skT, ysig ) ]
  --[ Unlock_0( '0', lock, ct ), Unlock( '0', lock, ct ) ]->
   [ State_111111112111( ct, lock, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) outsignctpkpkysigskT_0_111111112111[color=#804046,
                                                    process="out(sign(<<ct, pk1, pk2>, ysig>, skT));"]:
   [ State_111111112111( ct, lock, pk1, pk2, skT, ysig ) ]
  -->
   [
   State_1111111121111( ct, lock, pk1, pk2, skT, ysig ),
   Out( sign(<<ct, pk1, pk2>, ysig>, skT) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111111121111[color=#804046, process="0"]:
   [ State_1111111121111( ct, lock, pk1, pk2, skT, ysig ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111112[color=#804046, process="0"]:
   [ State_1111112( ct, pk1, pk2, skT, ysig ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112[color=#ffffff, process="!"]:
   [ State_11112( skT ) ] --> [ !Semistate_111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_11112[color=#ffffff, process="!"]:
   [ !Semistate_111121( skT ) ] --> [ State_111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111121[color=#ffffff, process="|"]:
   [ State_111121( skT ) ]
  -->
   [ State_1111211( skT ), State_1111212( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) inresolvectpkpkypcsysig_0_1111211[color=#5c8040,
                                                  process="in(<'resolve2', ct, pk1, pk2, ypcs1, ysig2>);"]:
   [ State_1111211( skT ), In( <'resolve2', ct, pk1, pk2, ypcs1, ysig2> ) ]
  -->
   [ State_11112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ifcheckgetmsgysigpkct_0_11112111[color=#5c8040,
                                                 process="if check_getmsg(ysig2, pk2)=ct"]:
   [ State_11112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Eq( check_getmsg(ysig2, pk2), ct ) ]->
   [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_0_11112111[color=#5c8040,
                                                    process="if check_getmsg(ysig2, pk2)=ct"]:
     [ State_11112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       ysig2 = ysig2.8
       z     = check_getmsg(ysig2.8, pk2.8)
    
    2. pk2   = pk(x.8)
       ysig2 = sign(x.11, x.8)
       z     = x.11
  */

rule (modulo E) ifcheckgetmsgysigpkct_1_11112111[color=#5c8040,
                                                 process="if check_getmsg(ysig2, pk2)=ct"]:
   [ State_11112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig2, pk2), ct ) ]->
   [ State_111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_1_11112111[color=#5c8040,
                                                    process="if check_getmsg(ysig2, pk2)=ct"]:
     [ State_11112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ State_111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       ysig2 = ysig2.8
       z     = check_getmsg(ysig2.8, pk2.8)
    
    2. pk2   = pk(x.8)
       ysig2 = sign(x.11, x.8)
       z     = x.11
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_0_111121111[color=#5c8040,
                                                               process="if check_getmsg(convertpcs(skT, ypcs1), pk1)=ct"]:
   [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Eq( check_getmsg(convertpcs(skT, ypcs1), pk1), ct ) ]->
   [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_0_111121111[color=#5c8040,
                                                                  process="if check_getmsg(convertpcs(skT, ypcs1), pk1)=ct"]:
     [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = check_getmsg(convertpcs(skT.8, ypcs1.8), pk1.8)
    
    2. pk1   = pk1.12
       skT   = x.8
       ypcs1 = pcs(sign(x.9, x.10), x.11, pk(x.8))
       z     = check_getmsg(sign(x.9, x.10), pk1.12)
    
    3. pk1   = pk(x.8)
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.8), x.12, pk(x.10))
       z     = x.11
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_1_111121111[color=#5c8040,
                                                               process="if check_getmsg(convertpcs(skT, ypcs1), pk1)=ct"]:
   [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Not_Eq( check_getmsg(convertpcs(skT, ypcs1), pk1), ct ) ]->
   [ State_1111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_1_111121111[color=#5c8040,
                                                                  process="if check_getmsg(convertpcs(skT, ypcs1), pk1)=ct"]:
     [ State_111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ State_1111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = check_getmsg(convertpcs(skT.8, ypcs1.8), pk1.8)
    
    2. pk1   = pk1.12
       skT   = x.8
       ypcs1 = pcs(sign(x.9, x.10), x.11, pk(x.8))
       z     = check_getmsg(sign(x.9, x.10), pk1.12)
    
    3. pk1   = pk(x.8)
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.8), x.12, pk(x.10))
       z     = x.11
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_0_1111211111[color=#5c8040,
                                                           process="if checkpcs(ct, pk1, pk2, pk(skT), ypcs1)=true"]:
   [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Eq( checkpcs(ct, pk1, pk2, pk(skT), ypcs1), true ) ]->
   [ State_11112111111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_0_1111211111[color=#5c8040,
                                                              process="if checkpcs(ct, pk1, pk2, pk(skT), ypcs1)=true"]:
     [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Eq( z, true ) ]->
     [ State_11112111111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = checkpcs(ct.8, pk1.8, pk2.8, pk(skT.8), ypcs1.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs1 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.10
       skT   = x.11
       ypcs1 = pcs(sign(x.8, x.9), x.10, pk(x.11))
       z     = true
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_1_1111211111[color=#5c8040,
                                                           process="if checkpcs(ct, pk1, pk2, pk(skT), ypcs1)=true"]:
   [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_Not_Eq( checkpcs(ct, pk1, pk2, pk(skT), ypcs1), true ) ]->
   [ State_11112111112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_1_1111211111[color=#5c8040,
                                                              process="if checkpcs(ct, pk1, pk2, pk(skT), ypcs1)=true"]:
     [ State_1111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_Not_Eq( z, true ) ]->
     [ State_11112111112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = checkpcs(ct.8, pk1.8, pk2.8, pk(skT.8), ypcs1.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs1 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.10
       skT   = x.11
       ypcs1 = pcs(sign(x.8, x.9), x.10, pk(x.11))
       z     = true
  */

rule (modulo E) lockct_0_11112111111[color=#5c8040, process="lock ct;"]:
   [ State_11112111111( ct, pk1, pk2, skT, ypcs1, ysig2 ), Fr( lock.1 ) ]
  --[ Lock_1( '1', lock.1, ct ), Lock( '1', lock.1, ct ) ]->
   [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]

  /*
  rule (modulo AC) lockct_0_11112111111[color=#5c8040, process="lock ct;"]:
     [ State_11112111111( ct, pk1, pk2, skT, ypcs1, ysig2 ), Fr( lock ) ]
    --[ Lock_1( '1', lock, ct ), Lock( '1', lock, ct ) ]->
     [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) lookupctasstatus_0_111121111111[color=#5c8040,
                                                process="lookup ct as status"]:
   [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  --[ IsIn( ct, status ) ]->
   [ State_1111211111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock.1 )
   ]

  /*
  rule (modulo AC) lookupctasstatus_0_111121111111[color=#5c8040,
                                                   process="lookup ct as status"]:
     [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    --[ IsIn( ct, status ) ]->
     [ State_1111211111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) lookupctasstatus_1_111121111111[color=#5c8040,
                                                process="lookup ct as status"]:
   [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  --[ IsNotSet( ct ) ]->
   [ State_1111211111112( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]

  /*
  rule (modulo AC) lookupctasstatus_1_111121111111[color=#5c8040,
                                                   process="lookup ct as status"]:
     [ State_111121111111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    --[ IsNotSet( ct ) ]->
     [ State_1111211111112( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) unlockct_0_1111211111111[color=#5c8040,
                                         process="unlock ct;"]:
   [ State_1111211111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock.1 )
   ]
  --[ Unlock_1( '1', lock.1, ct ), Unlock( '1', lock.1, ct ) ]->
   [ State_11112111111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock.1 )
   ]

  /*
  rule (modulo AC) unlockct_0_1111211111111[color=#5c8040,
                                            process="unlock ct;"]:
     [ State_1111211111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock ) ]
    --[ Unlock_1( '1', lock, ct ), Unlock( '1', lock, ct ) ]->
     [ State_11112111111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) p_0_11112111111111[color=#5c8040, process="0"]:
   [ State_11112111111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock.1 )
   ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_11112111111111[color=#5c8040, process="0"]:
     [ State_11112111111111( ct, pk1, pk2, skT, status, ypcs1, ysig2, lock ) ]
    -->
     [ ]
  */

rule (modulo E) insertctresolved_0_1111211111112[color=#5c8040,
                                                 process="insert ct,'resolved2';"]:
   [ State_1111211111112( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  --[ Insert( ct, 'resolved2' ) ]->
   [ State_11112111111121( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]

  /*
  rule (modulo AC) insertctresolved_0_1111211111112[color=#5c8040,
                                                    process="insert ct,'resolved2';"]:
     [ State_1111211111112( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    --[ Insert( ct, 'resolved2' ) ]->
     [ State_11112111111121( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) eventResolvect_0_11112111111121[color=#5c8040,
                                                process="event Resolve2( ct );"]:
   [ State_11112111111121( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  --[ Resolve2( ct ) ]->
   [ State_111121111111211( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]

  /*
  rule (modulo AC) eventResolvect_0_11112111111121[color=#5c8040,
                                                   process="event Resolve2( ct );"]:
     [ State_11112111111121( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    --[ Resolve2( ct ) ]->
     [ State_111121111111211( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) unlockct_0_111121111111211[color=#5c8040,
                                           process="unlock ct;"]:
   [ State_111121111111211( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  --[ Unlock_1( '1', lock.1, ct ), Unlock( '1', lock.1, ct ) ]->
   [ State_1111211111112111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]

  /*
  rule (modulo AC) unlockct_0_111121111111211[color=#5c8040,
                                              process="unlock ct;"]:
     [ State_111121111111211( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    --[ Unlock_1( '1', lock, ct ), Unlock( '1', lock, ct ) ]->
     [ State_1111211111112111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
  */

rule (modulo E) outsignconvertpcsskTypcsysigskT_0_1111211111112111[color=#5c8040,
                                                                   process="out(sign(<convertpcs(skT, ypcs1), ysig2>, skT));"]:
   [ State_1111211111112111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  -->
   [
   State_11112111111121111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ),
   Out( sign(<convertpcs(skT, ypcs1), ysig2>, skT) )
   ]

  /*
  rule (modulo AC) outsignconvertpcsskTypcsysigskT_0_1111211111112111[color=#5c8040,
                                                                      process="out(sign(<convertpcs(skT, ypcs1), ysig2>, skT));"]:
     [ State_1111211111112111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    -->
     [
     State_11112111111121111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ),
     Out( sign(<z, ysig2>, skT) )
     ]
    variants (modulo AC)
    1. skT   = skT.10
       ypcs1 = ypcs1.10
       z     = convertpcs(skT.10, ypcs1.10)
    
    2. skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = sign(x.11, x.12)
  */

rule (modulo E) p_0_11112111111121111[color=#5c8040, process="0"]:
   [ State_11112111111121111( ct, pk1, pk2, skT, ypcs1, ysig2, lock.1 ) ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_11112111111121111[color=#5c8040, process="0"]:
     [ State_11112111111121111( ct, pk1, pk2, skT, ypcs1, ysig2, lock ) ]
    -->
     [ ]
  */

rule (modulo E) p_0_11112111112[color=#5c8040, process="0"]:
   [ State_11112111112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111211112[color=#5c8040, process="0"]:
   [ State_1111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111121112[color=#5c8040, process="0"]:
   [ State_111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111212[color=#ffffff, process="!"]:
   [ State_1111212( skT ) ] --> [ !Semistate_11112121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_1111212[color=#ffffff, process="!"]:
   [ !Semistate_11112121( skT ) ] --> [ State_11112121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112121[color=#ffffff, process="|"]:
   [ State_11112121( skT ) ]
  -->
   [ State_111121211( skT ), State_111121212( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) inresolvectpkpkysigypcs_0_111121211[color=#798040,
                                                    process="in(<'resolve1', ct, pk1, pk2, ysig1, ypcs2>);"]:
   [ State_111121211( skT ), In( <'resolve1', ct, pk1, pk2, ysig1, ypcs2> )
   ]
  -->
   [ State_1111212111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ifcheckgetmsgysigpkct_0_1111212111[color=#798040,
                                                   process="if check_getmsg(ysig1, pk1)=ct"]:
   [ State_1111212111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Eq( check_getmsg(ysig1, pk1), ct ) ]->
   [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_0_1111212111[color=#798040,
                                                      process="if check_getmsg(ysig1, pk1)=ct"]:
     [ State_1111212111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig1 = ysig1.8
       z     = check_getmsg(ysig1.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig1 = sign(x.12, x.8)
       z     = x.12
  */

rule (modulo E) ifcheckgetmsgysigpkct_1_1111212111[color=#798040,
                                                   process="if check_getmsg(ysig1, pk1)=ct"]:
   [ State_1111212111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig1, pk1), ct ) ]->
   [ State_11112121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_1_1111212111[color=#798040,
                                                      process="if check_getmsg(ysig1, pk1)=ct"]:
     [ State_1111212111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ State_11112121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig1 = ysig1.8
       z     = check_getmsg(ysig1.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig1 = sign(x.12, x.8)
       z     = x.12
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_0_11112121111[color=#798040,
                                                                 process="if check_getmsg(convertpcs(skT, ypcs2), pk2)=ct"]:
   [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Eq( check_getmsg(convertpcs(skT, ypcs2), pk2), ct ) ]->
   [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_0_11112121111[color=#798040,
                                                                    process="if check_getmsg(convertpcs(skT, ypcs2), pk2)=ct"]:
     [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = check_getmsg(convertpcs(skT.8, ypcs2.8), pk2.8)
    
    2. pk2   = pk2.12
       skT   = x.8
       ypcs2 = pcs(sign(x.9, x.10), x.11, pk(x.8))
       z     = check_getmsg(sign(x.9, x.10), pk2.12)
    
    3. pk2   = pk(x.8)
       skT   = x.9
       ypcs2 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_1_11112121111[color=#798040,
                                                                 process="if check_getmsg(convertpcs(skT, ypcs2), pk2)=ct"]:
   [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Not_Eq( check_getmsg(convertpcs(skT, ypcs2), pk2), ct ) ]->
   [ State_111121211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_1_11112121111[color=#798040,
                                                                    process="if check_getmsg(convertpcs(skT, ypcs2), pk2)=ct"]:
     [ State_11112121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ State_111121211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = check_getmsg(convertpcs(skT.8, ypcs2.8), pk2.8)
    
    2. pk2   = pk2.12
       skT   = x.8
       ypcs2 = pcs(sign(x.9, x.10), x.11, pk(x.8))
       z     = check_getmsg(sign(x.9, x.10), pk2.12)
    
    3. pk2   = pk(x.8)
       skT   = x.9
       ypcs2 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_0_111121211111[color=#798040,
                                                             process="if checkpcs(ct, pk2, pk1, pk(skT), ypcs2)=true"]:
   [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Eq( checkpcs(ct, pk2, pk1, pk(skT), ypcs2), true ) ]->
   [ State_1111212111111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_0_111121211111[color=#798040,
                                                                process="if checkpcs(ct, pk2, pk1, pk(skT), ypcs2)=true"]:
     [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Eq( z, true ) ]->
     [ State_1111212111111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = checkpcs(ct.8, pk2.8, pk1.8, pk(skT.8), ypcs2.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs2 = pcs(sign(x.8, x.10), x.9, pk(x.11))
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.10
       skT   = x.11
       ypcs2 = fakepcs(x.10, x.9, pk(x.11), x.8)
       z     = true
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_1_111121211111[color=#798040,
                                                             process="if checkpcs(ct, pk2, pk1, pk(skT), ypcs2)=true"]:
   [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_Not_Eq( checkpcs(ct, pk2, pk1, pk(skT), ypcs2), true ) ]->
   [ State_1111212111112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_1_111121211111[color=#798040,
                                                                process="if checkpcs(ct, pk2, pk1, pk(skT), ypcs2)=true"]:
     [ State_111121211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_Not_Eq( z, true ) ]->
     [ State_1111212111112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = checkpcs(ct.8, pk2.8, pk1.8, pk(skT.8), ypcs2.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs2 = pcs(sign(x.8, x.10), x.9, pk(x.11))
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.10
       skT   = x.11
       ypcs2 = fakepcs(x.10, x.9, pk(x.11), x.8)
       z     = true
  */

rule (modulo E) lockct_0_1111212111111[color=#798040,
                                       process="lock ct;"]:
   [ State_1111212111111( ct, pk1, pk2, skT, ypcs2, ysig1 ), Fr( lock.2 ) ]
  --[ Lock_2( '2', lock.2, ct ), Lock( '2', lock.2, ct ) ]->
   [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]

  /*
  rule (modulo AC) lockct_0_1111212111111[color=#798040,
                                          process="lock ct;"]:
     [ State_1111212111111( ct, pk1, pk2, skT, ypcs2, ysig1 ), Fr( lock ) ]
    --[ Lock_2( '2', lock, ct ), Lock( '2', lock, ct ) ]->
     [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
  */

rule (modulo E) lookupctasstatus_0_11112121111111[color=#798040,
                                                  process="lookup ct as status"]:
   [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  --[ IsIn( ct, status ) ]->
   [
   State_111121211111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock.2 )
   ]

  /*
  rule (modulo AC) lookupctasstatus_0_11112121111111[color=#798040,
                                                     process="lookup ct as status"]:
     [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    --[ IsIn( ct, status ) ]->
     [ State_111121211111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock )
     ]
  */

rule (modulo E) lookupctasstatus_1_11112121111111[color=#798040,
                                                  process="lookup ct as status"]:
   [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  --[ IsNotSet( ct ) ]->
   [ State_111121211111112( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]

  /*
  rule (modulo AC) lookupctasstatus_1_11112121111111[color=#798040,
                                                     process="lookup ct as status"]:
     [ State_11112121111111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    --[ IsNotSet( ct ) ]->
     [ State_111121211111112( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
  */

rule (modulo E) unlockct_0_111121211111111[color=#798040,
                                           process="unlock ct;"]:
   [
   State_111121211111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock.2 )
   ]
  --[ Unlock_2( '2', lock.2, ct ), Unlock( '2', lock.2, ct ) ]->
   [
   State_1111212111111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock.2 )
   ]

  /*
  rule (modulo AC) unlockct_0_111121211111111[color=#798040,
                                              process="unlock ct;"]:
     [ State_111121211111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock )
     ]
    --[ Unlock_2( '2', lock, ct ), Unlock( '2', lock, ct ) ]->
     [ State_1111212111111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock )
     ]
  */

rule (modulo E) p_0_1111212111111111[color=#798040, process="0"]:
   [
   State_1111212111111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock.2 )
   ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_1111212111111111[color=#798040, process="0"]:
     [ State_1111212111111111( ct, pk1, pk2, skT, status, ypcs2, ysig1, lock )
     ]
    -->
     [ ]
  */

rule (modulo E) insertctresolved_0_111121211111112[color=#798040,
                                                   process="insert ct,'resolved1';"]:
   [ State_111121211111112( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  --[ Insert( ct, 'resolved1' ) ]->
   [ State_1111212111111121( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]

  /*
  rule (modulo AC) insertctresolved_0_111121211111112[color=#798040,
                                                      process="insert ct,'resolved1';"]:
     [ State_111121211111112( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    --[ Insert( ct, 'resolved1' ) ]->
     [ State_1111212111111121( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
  */

rule (modulo E) eventResolvect_0_1111212111111121[color=#798040,
                                                  process="event Resolve1( ct );"]:
   [ State_1111212111111121( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  --[ Resolve1( ct ) ]->
   [ State_11112121111111211( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]

  /*
  rule (modulo AC) eventResolvect_0_1111212111111121[color=#798040,
                                                     process="event Resolve1( ct );"]:
     [ State_1111212111111121( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    --[ Resolve1( ct ) ]->
     [ State_11112121111111211( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
  */

rule (modulo E) unlockct_0_11112121111111211[color=#798040,
                                             process="unlock ct;"]:
   [ State_11112121111111211( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  --[ Unlock_2( '2', lock.2, ct ), Unlock( '2', lock.2, ct ) ]->
   [ State_111121211111112111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]

  /*
  rule (modulo AC) unlockct_0_11112121111111211[color=#798040,
                                                process="unlock ct;"]:
     [ State_11112121111111211( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    --[ Unlock_2( '2', lock, ct ), Unlock( '2', lock, ct ) ]->
     [ State_111121211111112111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
  */

rule (modulo E) outsignysigconvertpcsskTypcsskT_0_111121211111112111[color=#798040,
                                                                     process="out(sign(<ysig1, convertpcs(skT, ypcs2)>, skT));"]:
   [ State_111121211111112111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  -->
   [
   State_1111212111111121111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ),
   Out( sign(<ysig1, convertpcs(skT, ypcs2)>, skT) )
   ]

  /*
  rule (modulo AC) outsignysigconvertpcsskTypcsskT_0_111121211111112111[color=#798040,
                                                                        process="out(sign(<ysig1, convertpcs(skT, ypcs2)>, skT));"]:
     [ State_111121211111112111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    -->
     [
     State_1111212111111121111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ),
     Out( sign(<ysig1, z>, skT) )
     ]
    variants (modulo AC)
    1. skT   = skT.11
       ypcs2 = ypcs2.11
       z     = convertpcs(skT.11, ypcs2.11)
    
    2. skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = sign(x.12, x.13)
  */

rule (modulo E) p_0_1111212111111121111[color=#798040, process="0"]:
   [ State_1111212111111121111( ct, pk1, pk2, skT, ypcs2, ysig1, lock.2 ) ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_1111212111111121111[color=#798040, process="0"]:
     [ State_1111212111111121111( ct, pk1, pk2, skT, ypcs2, ysig1, lock ) ]
    -->
     [ ]
  */

rule (modulo E) p_0_1111212111112[color=#798040, process="0"]:
   [ State_1111212111112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111121211112[color=#798040, process="0"]:
   [ State_111121211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112121112[color=#798040, process="0"]:
   [ State_11112121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111121212[color=#ffffff, process="!"]:
   [ State_111121212( skT ) ] --> [ !Semistate_1111212121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_111121212[color=#ffffff, process="!"]:
   [ !Semistate_1111212121( skT ) ] --> [ State_1111212121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111212121[color=#ffffff, process="|"]:
   [ State_1111212121( skT ) ]
  -->
   [ State_11112121211( skT ), State_11112121212( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insignctpkskpksignctpkskpkskskT_0_11112121211[color=#804059,
                                                              process="in(sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, skT));"]:
   [
   State_11112121211( skT ),
   In( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, skT) )
   ]
  -->
   [ State_111121212111( ct, pk2, sk1, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventAbortCertct_0_111121212111[color=#804059,
                                                process="event AbortCert( ct );"]:
   [ State_111121212111( ct, pk2, sk1, skT ) ]
  --[ AbortCert( ct ) ]->
   [ State_1111212121111( ct, pk2, sk1, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111212121111[color=#804059, process="0"]:
   [ State_1111212121111( ct, pk2, sk1, skT ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112121212[color=#ffffff, process="!"]:
   [ State_11112121212( skT ) ] --> [ !Semistate_111121212121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_11112121212[color=#ffffff, process="!"]:
   [ !Semistate_111121212121( skT ) ] --> [ State_111121212121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insignsignctsksignctskskT_0_111121212121[color=#40805f,
                                                         process="in(sign(<sign(ct, sk1), sign(ct, sk2)>, skT));"]:
   [
   State_111121212121( skT ),
   In( sign(<sign(ct, sk1), sign(ct, sk2)>, skT) )
   ]
  -->
   [ State_1111212121211( ct, sk1, sk2, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventResolveCertct_0_1111212121211[color=#40805f,
                                                   process="event ResolveCert( ct );"]:
   [ State_1111212121211( ct, sk1, sk2, skT ) ]
  --[ ResolveCert( ct ) ]->
   [ State_11112121212111( ct, sk1, sk2, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112121212111[color=#40805f, process="0"]:
   [ State_11112121212111( ct, sk1, sk2, skT ) ] --> [ ]

  /* has exactly the trivial AC variant */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒ (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_Not_Eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction locking_0:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_0( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_1:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_1( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_2:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_2( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: examples/sapic/fast/GJM-contract/contract.spthy

------------------------------------------------------------------------------
analyzed: examples/sapic/fast/GJM-contract/contract.spthy

  output:          examples/sapic/fast/GJM-contract/contract.spthy.tmp
  processing time: 17.09447792s
  aborted_and_resolved_exclusive (all-traces): verified (18 steps)
  aborted_contract_reachable (exists-trace): verified (6 steps)
  resolved1_contract_reachable (exists-trace): verified (10 steps)
  resolved2_contract_reachable (exists-trace): verified (10 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: examples/sapic/fast/GJM-contract/contract.spthy

  output:          examples/sapic/fast/GJM-contract/contract.spthy.tmp
  processing time: 17.09447792s
  aborted_and_resolved_exclusive (all-traces): verified (18 steps)
  aborted_contract_reachable (exists-trace): verified (6 steps)
  resolved1_contract_reachable (exists-trace): verified (10 steps)
  resolved2_contract_reachable (exists-trace): verified (10 steps)

==============================================================================
*/
