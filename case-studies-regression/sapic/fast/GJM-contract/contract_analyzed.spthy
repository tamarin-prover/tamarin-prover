theory Contract begin

// Function signature and definition of the equational theory E

functions: check_getmsg/2, checkpcs/5, convertpcs/2, fakepcs/4,
           fst/1[destructor], pair/2, pcs/3, pk/1, sign/2, snd/1[destructor],
           true/0, verify/3[destructor]
equations:
    check_getmsg(sign(xm, xsk), pk(xsk)) = xm,
    checkpcs(xc, xpk, pk(ysk), zpk, fakepcs(xpk, ysk, zpk, xc)) = true,
    checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xc, xsk), ypk, zpk)) = true,
    convertpcs(zsk, pcs(sign(xc, xsk), ypk, pk(zsk))) = sign(xc, xsk),
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

heuristic: p

section{* GM Protocol for Contract signing *}















lemma aborted_and_resolved_exclusive:
  all-traces
  "¬(∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j)"
*/
simplify
solve( State_111121212111111( signed, signed2, sk1, skT, ct, pk2
       ) ▶₀ #i )
  case ifctpkskpkcheckgetmsgsignedpksk_0_11112121211111
  solve( !Semistate_111121212121( skT ) ▶₀ #j )
    case p_1_111121212
    solve( !KU( sign(<sign(ct, sk1.1), sign(ct, sk2)>, ~n.1) ) @ #vk )
      case c_sign
      solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
             ) @ #vk.1 )
        case c_sign
        by solve( !KU( ~n.1 ) @ #vk.3 )
      next
        case unlockct_0_111111111211
        by solve( !KU( ~n.1 ) @ #vk.3 )
      qed
    next
      case unlockct_0_1111211111111211
      solve( !KU( pcs(sign(ct, sk1.1), pk(sk2), pk(~n.1)) ) @ #vk.11 )
        case c_pcs
        solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
               ) @ #vk.2 )
          case c_sign
          by solve( !KU( ~n ) @ #vk.17 )
        next
          case unlockct_0_111111111211
          solve( ((#vr.18 < #vr.29) ∧
                  (∃ #t2.
                    (Unlock_1( '1', ~n.2, ct ) @ #t2)
                   ∧
                    (#vr.18 < #t2) ∧
                    (#t2 < #vr.29) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.2, ct ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ct ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t0 = #vr.18) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ct ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.29 < #vr.18) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* cyclic */
          qed
        qed
      qed
    next
      case unlockct_0_111121211111111211
      solve( !KU( pcs(sign(ct, sk2), pk(sk1.1), pk(~n.1)) ) @ #vk.12 )
        case c_pcs
        solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
               ) @ #vk.2 )
          case c_sign
          by solve( !KU( ~n ) @ #vk.17 )
        next
          case unlockct_0_111111111211
          solve( ((#vr.18 < #vr.30) ∧
                  (∃ #t2.
                    (Unlock_2( '2', ~n.2, ct ) @ #t2)
                   ∧
                    (#vr.18 < #t2) ∧
                    (#t2 < #vr.30) ∧
                    (∀ #t0 pp. (Unlock( pp, ~n.2, ct ) @ #t0) ⇒ #t0 = #t2) ∧
                    (∀ pp lpp #t0.
                      (Lock( pp, lpp, ct ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t0 = #vr.18) ∨ (#t2 < #t0))) ∧
                    (∀ pp lpp #t0.
                      (Unlock( pp, lpp, ct ) @ #t0)
                     ⇒
                      ((#t0 < #vr.18) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                 (#vr.30 < #vr.18) )
            case case_1
            by contradiction /* cyclic */
          next
            case case_2
            by contradiction /* cyclic */
          qed
        qed
      qed
    qed
  qed
qed

lemma aborted_contract_reachable:
  exists-trace
  "(((∃ ct #i. AbortCert( ct ) @ #i) ∧
     (∀ ct1 ct2 #i1 #i2.
       ((Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (AbortCert( ct ) @ #i)) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Abort1( ct1 ) @ #i1) ∧ (Abort1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( State_111121212111111( signed, signed2, sk1, skT, ct, pk2
       ) ▶₀ #i )
  case ifctpkskpkcheckgetmsgsignedpksk_0_11112121211111
  solve( !KU( sign(<<ct, pk(sk1), pk2>, sign(<ct, pk(sk1), pk2>, sk1)>, ~n)
         ) @ #vk )
    case unlockct_0_111111111211
    solve( !KU( pk(sk1) ) @ #vk.6 )
      case c_pk
      solve( !KU( sign(<ct, pk(sk1), pk2>, sk1) ) @ #vk.9 )
        case c_sign
        SOLVED // trace found
      qed
    qed
  qed
qed

lemma resolved1_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct1 ct2 #i1 #i2.
      ((Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( !Semistate_111121212121( skT ) ▶₀ #i )
  case p_1_111121212
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case unlockct_0_111121211111111211
    solve( !KU( pcs(sign(ct, sk2), pk(sk1), pk(~n)) ) @ #vk.11 )
      case c_pcs
      solve( !KU( pk(sk1) ) @ #vk.7 )
        case c_pk
        solve( !KU( pk(sk2) ) @ #vk.10 )
          case c_pk
          solve( !KU( sign(ct, sk1) ) @ #vk.11 )
            case c_sign
            solve( !KU( sign(ct, sk2) ) @ #vk.12 )
              case c_sign
              solve( !KU( pk(~n) ) @ #vk.13 )
                case p_1_
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma resolved2_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct1 ct2 #i1 #i2.
     ((Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2)) ⇒ (#i1 = #i2))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2) ⇒ #i1 = #i2)"
*/
simplify
solve( !Semistate_111121212121( skT ) ▶₀ #i )
  case p_1_111121212
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case unlockct_0_1111211111111211
    solve( !KU( pcs(sign(ct, sk1), pk(sk2), pk(~n)) ) @ #vk.10 )
      case c_pcs
      solve( !KU( pk(sk1) ) @ #vk.7 )
        case c_pk
        solve( !KU( pk(sk2) ) @ #vk.10 )
          case c_pk
          solve( !KU( sign(ct, sk2) ) @ #vk.11 )
            case c_sign
            solve( !KU( sign(ct, sk1) ) @ #vk.12 )
              case c_sign
              solve( !KU( pk(~n) ) @ #vk.13 )
                case p_1_
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

















rule (modulo E) Init[color=#ffffff, process="!"]:
   [ ] --[ Init( ) ]-> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_[color=#ffffff, process="!"]:
   [ !Semistate_1( ), Fr( skT.1 ) ]
  -->
   [ !Semistate_1111( skT.1 ), Out( pk(skT.1) ) ]

  /*
  rule (modulo AC) p_1_[color=#ffffff, process="!"]:
     [ !Semistate_1( ), Fr( skT ) ]
    -->
     [ !Semistate_1111( skT ), Out( pk(skT) ) ]
  */

rule (modulo E) inabortctpkpkysig_0_111111[color=#804046,
                                           process="in(<'abort', ct.1, pk1.1, pk2.1, ysig.1>);"]:
   [ State_111111( skT.1 ), In( <'abort', ct.1, pk1.1, pk2.1, ysig.1> ) ]
  -->
   [ State_1111111( ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) inabortctpkpkysig_0_111111[color=#804046,
                                              process="in(<'abort', ct.1, pk1.1, pk2.1, ysig.1>);"]:
     [ State_111111( skT ), In( <'abort', ct, pk1, pk2, ysig> ) ]
    -->
     [ State_1111111( ct, pk1, pk2, skT, ysig ) ]
  */

rule (modulo E) ifcheckgetmsgysigpkctpkpk_0_1111111[color=#804046,
                                                    process="if check_getmsg(ysig.1, pk1.1)=<ct.1, pk1.1, pk2.1>"]:
   [ State_1111111( ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ Pred_Eq( check_getmsg(ysig.1, pk1.1), <ct.1, pk1.1, pk2.1> ) ]->
   [ State_11111111( ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkctpkpk_0_1111111[color=#804046,
                                                       process="if check_getmsg(ysig.1, pk1.1)=<ct.1, pk1.1, pk2.1>"]:
     [ State_1111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_Eq( z, <ct, pk1, pk2> ) ]->
     [ State_11111111( ct, pk1, pk2, skT, ysig ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig  = ysig.8
       z     = check_getmsg(ysig.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig  = sign(x.11, x.8)
       z     = x.11
  */

rule (modulo E) lockct_0_11111111[color=#804046, process="lock ct.1;"]:
   [ State_11111111( ct.1, pk1.1, pk2.1, skT.1, ysig.1 ), Fr( lock ) ]
  --[ Lock_0( '0', lock, ct.1 ), Lock( '0', lock, ct.1 ) ]->
   [ State_111111111( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) lockct_0_11111111[color=#804046, process="lock ct.1;"]:
     [ State_11111111( ct, pk1, pk2, skT, ysig ), Fr( lock ) ]
    --[ Lock_0( '0', lock, ct ), Lock( '0', lock, ct ) ]->
     [ State_111111111( lock, ct, pk1, pk2, skT, ysig ) ]
  */

rule (modulo E) lookupctasstate_0_111111111[color=#804046,
                                            process="lookup ct.1 as state.1"]:
   [ State_111111111( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ IsIn( ct.1, state.1 ) ]->
   [ State_1111111111( lock, ct.1, pk1.1, pk2.1, skT.1, state.1, ysig.1 ) ]

  /*
  rule (modulo AC) lookupctasstate_0_111111111[color=#804046,
                                               process="lookup ct.1 as state.1"]:
     [ State_111111111( lock, ct, pk1, pk2, skT, ysig ) ]
    --[ IsIn( ct, state ) ]->
     [ State_1111111111( lock, ct, pk1, pk2, skT, state, ysig ) ]
  */

rule (modulo E) unlockct_0_1111111111[color=#804046,
                                      process="unlock ct.1;"]:
   [ State_1111111111( lock, ct.1, pk1.1, pk2.1, skT.1, state.1, ysig.1 ) ]
  --[ Unlock_0( '0', lock, ct.1 ), Unlock( '0', lock, ct.1 ) ]->
   [ ]

  /*
  rule (modulo AC) unlockct_0_1111111111[color=#804046,
                                         process="unlock ct.1;"]:
     [ State_1111111111( lock, ct, pk1, pk2, skT, state, ysig ) ]
    --[ Unlock_0( '0', lock, ct ), Unlock( '0', lock, ct ) ]->
     [ ]
  */

rule (modulo E) lookupctasstate_1_111111111[color=#804046,
                                            process="lookup ct.1 as state.1"]:
   [ State_111111111( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ IsNotSet( ct.1 ) ]->
   [ State_1111111112( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) lookupctasstate_1_111111111[color=#804046,
                                               process="lookup ct.1 as state.1"]:
     [ State_111111111( lock, ct, pk1, pk2, skT, ysig ) ]
    --[ IsNotSet( ct ) ]->
     [ State_1111111112( lock, ct, pk1, pk2, skT, ysig ) ]
  */

rule (modulo E) insertctaborted_0_1111111112[color=#804046,
                                             process="insert ct.1,'aborted';"]:
   [ State_1111111112( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ Insert( ct.1, 'aborted' ) ]->
   [ State_11111111121( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) insertctaborted_0_1111111112[color=#804046,
                                                process="insert ct.1,'aborted';"]:
     [ State_1111111112( lock, ct, pk1, pk2, skT, ysig ) ]
    --[ Insert( ct, 'aborted' ) ]->
     [ State_11111111121( lock, ct, pk1, pk2, skT, ysig ) ]
  */

rule (modulo E) eventAbortct_0_11111111121[color=#804046,
                                           process="event Abort1( ct.1 );"]:
   [ State_11111111121( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ Abort1( ct.1 ) ]->
   [ State_111111111211( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]

  /*
  rule (modulo AC) eventAbortct_0_11111111121[color=#804046,
                                              process="event Abort1( ct.1 );"]:
     [ State_11111111121( lock, ct, pk1, pk2, skT, ysig ) ]
    --[ Abort1( ct ) ]->
     [ State_111111111211( lock, ct, pk1, pk2, skT, ysig ) ]
  */

rule (modulo E) unlockct_0_111111111211[color=#804046,
                                        process="unlock ct.1;"]:
   [ State_111111111211( lock, ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ Unlock_0( '0', lock, ct.1 ), Unlock( '0', lock, ct.1 ) ]->
   [ Out( sign(<<ct.1, pk1.1, pk2.1>, ysig.1>, skT.1) ) ]

  /*
  rule (modulo AC) unlockct_0_111111111211[color=#804046,
                                           process="unlock ct.1;"]:
     [ State_111111111211( lock, ct, pk1, pk2, skT, ysig ) ]
    --[ Unlock_0( '0', lock, ct ), Unlock( '0', lock, ct ) ]->
     [ Out( sign(<<ct, pk1, pk2>, ysig>, skT) ) ]
  */

rule (modulo E) ifcheckgetmsgysigpkctpkpk_1_1111111[color=#804046,
                                                    process="if check_getmsg(ysig.1, pk1.1)=<ct.1, pk1.1, pk2.1>"]:
   [ State_1111111( ct.1, pk1.1, pk2.1, skT.1, ysig.1 ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig.1, pk1.1), <ct.1, pk1.1, pk2.1> ) ]->
   [ ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkctpkpk_1_1111111[color=#804046,
                                                       process="if check_getmsg(ysig.1, pk1.1)=<ct.1, pk1.1, pk2.1>"]:
     [ State_1111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_Not_Eq( z, <ct, pk1, pk2> ) ]->
     [ ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig  = ysig.8
       z     = check_getmsg(ysig.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig  = sign(x.11, x.8)
       z     = x.11
  */

rule (modulo E) p_1_111[color=#ffffff, process="!"]:
   [ !Semistate_1111( skT.1 ) ]
  -->
   [ !Semistate_111121( skT.1 ), State_111111( skT.1 ) ]

  /*
  rule (modulo AC) p_1_111[color=#ffffff, process="!"]:
     [ !Semistate_1111( skT ) ]
    -->
     [ !Semistate_111121( skT ), State_111111( skT ) ]
  */

rule (modulo E) inresolvectpkpkypcsysig_0_11112111[color=#5c8040,
                                                   process="in(<'resolve2', ct.2, pk1.2, pk2.2, ypcs1.1, ysig2.1>);"]:
   [
   State_11112111( skT.1 ),
   In( <'resolve2', ct.2, pk1.2, pk2.2, ypcs1.1, ysig2.1> )
   ]
  -->
   [ State_111121111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]

  /*
  rule (modulo AC) inresolvectpkpkypcsysig_0_11112111[color=#5c8040,
                                                      process="in(<'resolve2', ct.2, pk1.2, pk2.2, ypcs1.1, ysig2.1>);"]:
     [ State_11112111( skT ), In( <'resolve2', ct, pk1, pk2, ypcs1, ysig2> ) ]
    -->
     [ State_111121111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) ifcheckgetmsgysigpkct_0_111121111[color=#5c8040,
                                                  process="if check_getmsg(ysig2.1, pk2.2)=ct.2"]:
   [ State_111121111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Eq( check_getmsg(ysig2.1, pk2.2), ct.2 ) ]->
   [ State_1111211111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_0_111121111[color=#5c8040,
                                                     process="if check_getmsg(ysig2.1, pk2.2)=ct.2"]:
     [ State_111121111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_1111211111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.11
       ysig2 = ysig2.10
       z     = check_getmsg(ysig2.10, pk2.11)
    
    2. pk2   = pk(x.11)
       ysig2 = sign(x.10, x.11)
       z     = x.10
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_0_1111211111[color=#5c8040,
                                                                process="if check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2)=ct.2"]:
   [ State_1111211111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Eq( check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2), ct.2 ) ]->
   [ State_11112111111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_0_1111211111[color=#5c8040,
                                                                   process="if check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2)=ct.2"]:
     [ State_1111211111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_11112111111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.11
       skT   = skT.10
       ypcs1 = ypcs1.10
       z     = check_getmsg(convertpcs(skT.10, ypcs1.10), pk1.11)
    
    2. pk1   = pk1.15
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = check_getmsg(sign(x.11, x.12), pk1.15)
    
    3. pk1   = pk(x.12)
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = x.11
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_0_11112111111[color=#5c8040,
                                                            process="if checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1)=true"]:
   [ State_11112111111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Eq( checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1), true ) ]->
   [ State_111121111111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_0_11112111111[color=#5c8040,
                                                               process="if checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1)=true"]:
     [ State_11112111111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, true ) ]->
     [ State_111121111111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. ct    = ct.11
       pk1   = pk1.11
       pk2   = pk2.11
       skT   = skT.10
       ypcs1 = ypcs1.10
       z     = checkpcs(ct.11, pk1.11, pk2.11, pk(skT.10), ypcs1.10)
    
    2. ct    = x.13
       pk1   = x.11
       pk2   = pk(x.12)
       skT   = x.10
       ypcs1 = fakepcs(x.11, x.12, pk(x.10), x.13)
       z     = true
    
    3. ct    = x.11
       pk1   = pk(x.12)
       pk2   = x.13
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = true
  */

rule (modulo E) lockct_0_111121111111[color=#5c8040,
                                      process="lock ct.2;"]:
   [
   State_111121111111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ),
   Fr( lock.1 )
   ]
  --[ Lock_1( '1', lock.1, ct.2 ), Lock( '1', lock.1, ct.2 ) ]->
   [
   State_1111211111111( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2
   )
   ]

  /*
  rule (modulo AC) lockct_0_111121111111[color=#5c8040,
                                         process="lock ct.2;"]:
     [ State_111121111111( skT, ypcs1, ysig2, ct, pk1, pk2 ), Fr( lock ) ]
    --[ Lock_1( '1', lock, ct ), Lock( '1', lock, ct ) ]->
     [ State_1111211111111( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) lookupctasstatus_0_1111211111111[color=#5c8040,
                                                 process="lookup ct.2 as status.1"]:
   [
   State_1111211111111( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2
   )
   ]
  --[ IsIn( ct.2, status.1 ) ]->
   [
   State_11112111111111( lock.1, skT.1, status.1, ypcs1.1, ysig2.1, ct.2,
                         pk1.2, pk2.2
   )
   ]

  /*
  rule (modulo AC) lookupctasstatus_0_1111211111111[color=#5c8040,
                                                    process="lookup ct.2 as status.1"]:
     [ State_1111211111111( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ IsIn( ct, status ) ]->
     [ State_11112111111111( lock, skT, status, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) unlockct_0_11112111111111[color=#5c8040,
                                          process="unlock ct.2;"]:
   [
   State_11112111111111( lock.1, skT.1, status.1, ypcs1.1, ysig2.1, ct.2,
                         pk1.2, pk2.2
   )
   ]
  --[ Unlock_1( '1', lock.1, ct.2 ), Unlock( '1', lock.1, ct.2 ) ]->
   [ ]

  /*
  rule (modulo AC) unlockct_0_11112111111111[color=#5c8040,
                                             process="unlock ct.2;"]:
     [ State_11112111111111( lock, skT, status, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Unlock_1( '1', lock, ct ), Unlock( '1', lock, ct ) ]->
     [ ]
  */

rule (modulo E) lookupctasstatus_1_1111211111111[color=#5c8040,
                                                 process="lookup ct.2 as status.1"]:
   [
   State_1111211111111( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2
   )
   ]
  --[ IsNotSet( ct.2 ) ]->
   [
   State_11112111111112( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2
   )
   ]

  /*
  rule (modulo AC) lookupctasstatus_1_1111211111111[color=#5c8040,
                                                    process="lookup ct.2 as status.1"]:
     [ State_1111211111111( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ IsNotSet( ct ) ]->
     [ State_11112111111112( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) insertctresolved_0_11112111111112[color=#5c8040,
                                                  process="insert ct.2,'resolved2';"]:
   [
   State_11112111111112( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2
   )
   ]
  --[ Insert( ct.2, 'resolved2' ) ]->
   [
   State_111121111111121( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2,
                          pk2.2
   )
   ]

  /*
  rule (modulo AC) insertctresolved_0_11112111111112[color=#5c8040,
                                                     process="insert ct.2,'resolved2';"]:
     [ State_11112111111112( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Insert( ct, 'resolved2' ) ]->
     [ State_111121111111121( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) eventResolvect_0_111121111111121[color=#5c8040,
                                                 process="event Resolve2( ct.2 );"]:
   [
   State_111121111111121( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2,
                          pk2.2
   )
   ]
  --[ Resolve2( ct.2 ) ]->
   [
   State_1111211111111211( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2,
                           pk2.2
   )
   ]

  /*
  rule (modulo AC) eventResolvect_0_111121111111121[color=#5c8040,
                                                    process="event Resolve2( ct.2 );"]:
     [ State_111121111111121( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Resolve2( ct ) ]->
     [ State_1111211111111211( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
  */

rule (modulo E) unlockct_0_1111211111111211[color=#5c8040,
                                            process="unlock ct.2;"]:
   [
   State_1111211111111211( lock.1, skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2,
                           pk2.2
   )
   ]
  --[ Unlock_1( '1', lock.1, ct.2 ), Unlock( '1', lock.1, ct.2 ) ]->
   [ Out( sign(<convertpcs(skT.1, ypcs1.1), ysig2.1>, skT.1) ) ]

  /*
  rule (modulo AC) unlockct_0_1111211111111211[color=#5c8040,
                                               process="unlock ct.2;"]:
     [ State_1111211111111211( lock, skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Unlock_1( '1', lock, ct ), Unlock( '1', lock, ct ) ]->
     [ Out( sign(<z, ysig2>, skT) ) ]
    variants (modulo AC)
    1. skT   = skT.12
       ypcs1 = ypcs1.13
       z     = convertpcs(skT.12, ypcs1.13)
    
    2. skT   = skT.15
       ypcs1 = pcs(sign(x.23, x.24), x.25, pk(skT.15))
       z     = sign(x.23, x.24)
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_1_11112111111[color=#5c8040,
                                                            process="if checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1)=true"]:
   [ State_11112111111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Not_Eq( checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1), true )
  ]->
   [ ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_1_11112111111[color=#5c8040,
                                                               process="if checkpcs(ct.2, pk1.2, pk2.2, pk(skT.1), ypcs1.1)=true"]:
     [ State_11112111111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, true ) ]->
     [ ]
    variants (modulo AC)
    1. ct    = ct.11
       pk1   = pk1.11
       pk2   = pk2.11
       skT   = skT.10
       ypcs1 = ypcs1.10
       z     = checkpcs(ct.11, pk1.11, pk2.11, pk(skT.10), ypcs1.10)
    
    2. ct    = x.13
       pk1   = x.11
       pk2   = pk(x.12)
       skT   = x.10
       ypcs1 = fakepcs(x.11, x.12, pk(x.10), x.13)
       z     = true
    
    3. ct    = x.11
       pk1   = pk(x.12)
       pk2   = x.13
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = true
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_1_1111211111[color=#5c8040,
                                                                process="if check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2)=ct.2"]:
   [ State_1111211111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Not_Eq( check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2), ct.2 )
  ]->
   [ ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_1_1111211111[color=#5c8040,
                                                                   process="if check_getmsg(convertpcs(skT.1, ypcs1.1), pk1.2)=ct.2"]:
     [ State_1111211111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ ]
    variants (modulo AC)
    1. pk1   = pk1.11
       skT   = skT.10
       ypcs1 = ypcs1.10
       z     = check_getmsg(convertpcs(skT.10, ypcs1.10), pk1.11)
    
    2. pk1   = pk1.15
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = check_getmsg(sign(x.11, x.12), pk1.15)
    
    3. pk1   = pk(x.12)
       skT   = x.10
       ypcs1 = pcs(sign(x.11, x.12), x.13, pk(x.10))
       z     = x.11
  */

rule (modulo E) ifcheckgetmsgysigpkct_1_111121111[color=#5c8040,
                                                  process="if check_getmsg(ysig2.1, pk2.2)=ct.2"]:
   [ State_111121111( skT.1, ypcs1.1, ysig2.1, ct.2, pk1.2, pk2.2 ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig2.1, pk2.2), ct.2 ) ]->
   [ ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_1_111121111[color=#5c8040,
                                                     process="if check_getmsg(ysig2.1, pk2.2)=ct.2"]:
     [ State_111121111( skT, ypcs1, ysig2, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ ]
    variants (modulo AC)
    1. pk2   = pk2.11
       ysig2 = ysig2.10
       z     = check_getmsg(ysig2.10, pk2.11)
    
    2. pk2   = pk(x.11)
       ysig2 = sign(x.10, x.11)
       z     = x.10
  */

rule (modulo E) p_1_11112[color=#ffffff, process="!"]:
   [ !Semistate_111121( skT.1 ) ]
  -->
   [ !Semistate_11112121( skT.1 ), State_11112111( skT.1 ) ]

  /*
  rule (modulo AC) p_1_11112[color=#ffffff, process="!"]:
     [ !Semistate_111121( skT ) ]
    -->
     [ !Semistate_11112121( skT ), State_11112111( skT ) ]
  */

rule (modulo E) inresolvectpkpkysigypcs_0_1111212111[color=#798040,
                                                     process="in(<'resolve1', ct.3, pk1.3, pk2.3, ysig1.1, ypcs2.1>);"]:
   [
   State_1111212111( skT.1 ),
   In( <'resolve1', ct.3, pk1.3, pk2.3, ysig1.1, ypcs2.1> )
   ]
  -->
   [ State_11112121111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]

  /*
  rule (modulo AC) inresolvectpkpkysigypcs_0_1111212111[color=#798040,
                                                        process="in(<'resolve1', ct.3, pk1.3, pk2.3, ysig1.1, ypcs2.1>);"]:
     [ State_1111212111( skT ), In( <'resolve1', ct, pk1, pk2, ysig1, ypcs2> )
     ]
    -->
     [ State_11112121111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
  */

rule (modulo E) ifcheckgetmsgysigpkct_0_11112121111[color=#798040,
                                                    process="if check_getmsg(ysig1.1, pk1.3)=ct.3"]:
   [ State_11112121111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Eq( check_getmsg(ysig1.1, pk1.3), ct.3 ) ]->
   [ State_111121211111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_0_11112121111[color=#798040,
                                                       process="if check_getmsg(ysig1.1, pk1.3)=ct.3"]:
     [ State_11112121111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_111121211111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.13
       ysig1 = ysig1.11
       z     = check_getmsg(ysig1.11, pk1.13)
    
    2. pk1   = pk(x.12)
       ysig1 = sign(x.11, x.12)
       z     = x.11
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_0_111121211111[color=#798040,
                                                                  process="if check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3)=ct.3"]:
   [ State_111121211111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Eq( check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3), ct.3 ) ]->
   [ State_1111212111111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_0_111121211111[color=#798040,
                                                                     process="if check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3)=ct.3"]:
     [ State_111121211111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, ct ) ]->
     [ State_1111212111111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.13
       skT   = skT.11
       ypcs2 = ypcs2.11
       z     = check_getmsg(convertpcs(skT.11, ypcs2.11), pk2.13)
    
    2. pk2   = pk2.17
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = check_getmsg(sign(x.12, x.13), pk2.17)
    
    3. pk2   = pk(x.13)
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = x.12
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_0_1111212111111[color=#798040,
                                                              process="if checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1)=true"]:
   [ State_1111212111111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Eq( checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1), true ) ]->
   [ State_11112121111111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_0_1111212111111[color=#798040,
                                                                 process="if checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1)=true"]:
     [ State_1111212111111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Eq( z, true ) ]->
     [ State_11112121111111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    variants (modulo AC)
    1. ct    = ct.13
       pk1   = pk1.13
       pk2   = pk2.13
       skT   = skT.11
       ypcs2 = ypcs2.11
       z     = checkpcs(ct.13, pk2.13, pk1.13, pk(skT.11), ypcs2.11)
    
    2. ct    = x.14
       pk1   = pk(x.13)
       pk2   = x.12
       skT   = x.11
       ypcs2 = fakepcs(x.12, x.13, pk(x.11), x.14)
       z     = true
    
    3. ct    = x.12
       pk1   = x.14
       pk2   = pk(x.13)
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = true
  */

rule (modulo E) lockct_0_11112121111111[color=#798040,
                                        process="lock ct.3;"]:
   [
   State_11112121111111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ),
   Fr( lock.2 )
   ]
  --[ Lock_2( '2', lock.2, ct.3 ), Lock( '2', lock.2, ct.3 ) ]->
   [
   State_111121211111111( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                          pk2.3
   )
   ]

  /*
  rule (modulo AC) lockct_0_11112121111111[color=#798040,
                                           process="lock ct.3;"]:
     [ State_11112121111111( skT, ypcs2, ysig1, ct, pk1, pk2 ), Fr( lock ) ]
    --[ Lock_2( '2', lock, ct ), Lock( '2', lock, ct ) ]->
     [ State_111121211111111( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
  */

rule (modulo E) lookupctasstatus_0_111121211111111[color=#798040,
                                                   process="lookup ct.3 as status.2"]:
   [
   State_111121211111111( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                          pk2.3
   )
   ]
  --[ IsIn( ct.3, status.2 ) ]->
   [
   State_1111212111111111( skT.1, ypcs2.1, ysig1.1, lock.2, status.2, ct.3,
                           pk1.3, pk2.3
   )
   ]

  /*
  rule (modulo AC) lookupctasstatus_0_111121211111111[color=#798040,
                                                      process="lookup ct.3 as status.2"]:
     [ State_111121211111111( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
    --[ IsIn( ct, status ) ]->
     [ State_1111212111111111( skT, ypcs2, ysig1, lock, status, ct, pk1, pk2 )
     ]
  */

rule (modulo E) unlockct_0_1111212111111111[color=#798040,
                                            process="unlock ct.3;"]:
   [
   State_1111212111111111( skT.1, ypcs2.1, ysig1.1, lock.2, status.2, ct.3,
                           pk1.3, pk2.3
   )
   ]
  --[ Unlock_2( '2', lock.2, ct.3 ), Unlock( '2', lock.2, ct.3 ) ]->
   [ ]

  /*
  rule (modulo AC) unlockct_0_1111212111111111[color=#798040,
                                               process="unlock ct.3;"]:
     [ State_1111212111111111( skT, ypcs2, ysig1, lock, status, ct, pk1, pk2 )
     ]
    --[ Unlock_2( '2', lock, ct ), Unlock( '2', lock, ct ) ]->
     [ ]
  */

rule (modulo E) lookupctasstatus_1_111121211111111[color=#798040,
                                                   process="lookup ct.3 as status.2"]:
   [
   State_111121211111111( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                          pk2.3
   )
   ]
  --[ IsNotSet( ct.3 ) ]->
   [
   State_1111212111111112( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                           pk2.3
   )
   ]

  /*
  rule (modulo AC) lookupctasstatus_1_111121211111111[color=#798040,
                                                      process="lookup ct.3 as status.2"]:
     [ State_111121211111111( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
    --[ IsNotSet( ct ) ]->
     [ State_1111212111111112( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
  */

rule (modulo E) insertctresolved_0_1111212111111112[color=#798040,
                                                    process="insert ct.3,'resolved1';"]:
   [
   State_1111212111111112( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                           pk2.3
   )
   ]
  --[ Insert( ct.3, 'resolved1' ) ]->
   [
   State_11112121111111121( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                            pk2.3
   )
   ]

  /*
  rule (modulo AC) insertctresolved_0_1111212111111112[color=#798040,
                                                       process="insert ct.3,'resolved1';"]:
     [ State_1111212111111112( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
    --[ Insert( ct, 'resolved1' ) ]->
     [ State_11112121111111121( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
  */

rule (modulo E) eventResolvect_0_11112121111111121[color=#798040,
                                                   process="event Resolve1( ct.3 );"]:
   [
   State_11112121111111121( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                            pk2.3
   )
   ]
  --[ Resolve1( ct.3 ) ]->
   [
   State_111121211111111211( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                             pk2.3
   )
   ]

  /*
  rule (modulo AC) eventResolvect_0_11112121111111121[color=#798040,
                                                      process="event Resolve1( ct.3 );"]:
     [ State_11112121111111121( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
    --[ Resolve1( ct ) ]->
     [ State_111121211111111211( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
  */

rule (modulo E) unlockct_0_111121211111111211[color=#798040,
                                              process="unlock ct.3;"]:
   [
   State_111121211111111211( skT.1, ypcs2.1, ysig1.1, lock.2, ct.3, pk1.3,
                             pk2.3
   )
   ]
  --[ Unlock_2( '2', lock.2, ct.3 ), Unlock( '2', lock.2, ct.3 ) ]->
   [ Out( sign(<ysig1.1, convertpcs(skT.1, ypcs2.1)>, skT.1) ) ]

  /*
  rule (modulo AC) unlockct_0_111121211111111211[color=#798040,
                                                 process="unlock ct.3;"]:
     [ State_111121211111111211( skT, ypcs2, ysig1, lock, ct, pk1, pk2 ) ]
    --[ Unlock_2( '2', lock, ct ), Unlock( '2', lock, ct ) ]->
     [ Out( sign(<ysig1, z>, skT) ) ]
    variants (modulo AC)
    1. skT   = skT.13
       ypcs2 = ypcs2.14
       z     = convertpcs(skT.13, ypcs2.14)
    
    2. skT   = skT.16
       ypcs2 = pcs(sign(x.25, x.26), x.27, pk(skT.16))
       z     = sign(x.25, x.26)
  */

rule (modulo E) ifcheckpcsctpkpkpkskTypcstrue_1_1111212111111[color=#798040,
                                                              process="if checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1)=true"]:
   [ State_1111212111111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Not_Eq( checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1), true )
  ]->
   [ ]

  /*
  rule (modulo AC) ifcheckpcsctpkpkpkskTypcstrue_1_1111212111111[color=#798040,
                                                                 process="if checkpcs(ct.3, pk2.3, pk1.3, pk(skT.1), ypcs2.1)=true"]:
     [ State_1111212111111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, true ) ]->
     [ ]
    variants (modulo AC)
    1. ct    = ct.13
       pk1   = pk1.13
       pk2   = pk2.13
       skT   = skT.11
       ypcs2 = ypcs2.11
       z     = checkpcs(ct.13, pk2.13, pk1.13, pk(skT.11), ypcs2.11)
    
    2. ct    = x.14
       pk1   = pk(x.13)
       pk2   = x.12
       skT   = x.11
       ypcs2 = fakepcs(x.12, x.13, pk(x.11), x.14)
       z     = true
    
    3. ct    = x.12
       pk1   = x.14
       pk2   = pk(x.13)
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = true
  */

rule (modulo E) ifcheckgetmsgconvertpcsskTypcspkct_1_111121211111[color=#798040,
                                                                  process="if check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3)=ct.3"]:
   [ State_111121211111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Not_Eq( check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3), ct.3 )
  ]->
   [ ]

  /*
  rule (modulo AC) ifcheckgetmsgconvertpcsskTypcspkct_1_111121211111[color=#798040,
                                                                     process="if check_getmsg(convertpcs(skT.1, ypcs2.1), pk2.3)=ct.3"]:
     [ State_111121211111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ ]
    variants (modulo AC)
    1. pk2   = pk2.13
       skT   = skT.11
       ypcs2 = ypcs2.11
       z     = check_getmsg(convertpcs(skT.11, ypcs2.11), pk2.13)
    
    2. pk2   = pk2.17
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = check_getmsg(sign(x.12, x.13), pk2.17)
    
    3. pk2   = pk(x.13)
       skT   = x.11
       ypcs2 = pcs(sign(x.12, x.13), x.14, pk(x.11))
       z     = x.12
  */

rule (modulo E) ifcheckgetmsgysigpkct_1_11112121111[color=#798040,
                                                    process="if check_getmsg(ysig1.1, pk1.3)=ct.3"]:
   [ State_11112121111( skT.1, ypcs2.1, ysig1.1, ct.3, pk1.3, pk2.3 ) ]
  --[ Pred_Not_Eq( check_getmsg(ysig1.1, pk1.3), ct.3 ) ]->
   [ ]

  /*
  rule (modulo AC) ifcheckgetmsgysigpkct_1_11112121111[color=#798040,
                                                       process="if check_getmsg(ysig1.1, pk1.3)=ct.3"]:
     [ State_11112121111( skT, ypcs2, ysig1, ct, pk1, pk2 ) ]
    --[ Pred_Not_Eq( z, ct ) ]->
     [ ]
    variants (modulo AC)
    1. pk1   = pk1.13
       ysig1 = ysig1.11
       z     = check_getmsg(ysig1.11, pk1.13)
    
    2. pk1   = pk(x.12)
       ysig1 = sign(x.11, x.12)
       z     = x.11
  */

rule (modulo E) p_1_1111212[color=#ffffff, process="!"]:
   [ !Semistate_11112121( skT.1 ) ]
  -->
   [ !Semistate_1111212121( skT.1 ), State_1111212111( skT.1 ) ]

  /*
  rule (modulo AC) p_1_1111212[color=#ffffff, process="!"]:
     [ !Semistate_11112121( skT ) ]
    -->
     [ !Semistate_1111212121( skT ), State_1111212111( skT ) ]
  */

rule (modulo E) insigned_0_111121212111[color=#804059,
                                        process="in(signed.1);"]:
   [ State_111121212111( skT.1 ), In( signed.1 ) ]
  -->
   [
   Let_11112121211111( check_getmsg(signed.1, pk(skT.1)), signed.1, skT.1 )
   ]

  /*
  rule (modulo AC) insigned_0_111121212111[color=#804059,
                                           process="in(signed.1);"]:
     [ State_111121212111( skT ), In( signed ) ]
    -->
     [ Let_11112121211111( z, signed, skT ) ]
    variants (modulo AC)
    1. signed
             = signed.5
       skT   = skT.5
       z     = check_getmsg(signed.5, pk(skT.5))
    
    2. signed
             = sign(x.5, x.6)
       skT   = x.6
       z     = x.5
  */

rule (modulo E) letctpkskpksignedcheckgetmsgsignedpkskT_1_1111212121111[color=#ffffff,
                                                                        process="let <<ct.4, pk(sk1.1), pk2.4>, signed2.1>=check_getmsg(signed.1, pk(skT.1))"]:
   [
   Let_11112121211111( <<ct.4, pk(sk1.1), pk2.4>, signed2.1>, signed.1,
                       skT.1
   )
   ]
  -->
   [ State_11112121211111( signed.1, signed2.1, sk1.1, skT.1, ct.4, pk2.4 )
   ]

  /*
  rule (modulo AC) letctpkskpksignedcheckgetmsgsignedpkskT_1_1111212121111[color=#ffffff,
                                                                           process="let <<ct.4, pk(sk1.1), pk2.4>, signed2.1>=check_getmsg(signed.1, pk(skT.1))"]:
     [ Let_11112121211111( <<ct, pk(sk1), pk2>, signed2>, signed, skT ) ]
    -->
     [ State_11112121211111( signed, signed2, sk1, skT, ct, pk2 ) ]
  */

rule (modulo E) ifctpkskpkcheckgetmsgsignedpksk_0_11112121211111[color=#804059,
                                                                 process="if <ct.4, pk(sk1.1), pk2.4>=check_getmsg(signed2.1, pk(sk1.1))"]:
   [ State_11112121211111( signed.1, signed2.1, sk1.1, skT.1, ct.4, pk2.4 )
   ]
  --[
  Pred_Eq( <ct.4, pk(sk1.1), pk2.4>, check_getmsg(signed2.1, pk(sk1.1)) )
  ]->
   [ State_111121212111111( signed.1, signed2.1, sk1.1, skT.1, ct.4, pk2.4 )
   ]

  /*
  rule (modulo AC) ifctpkskpkcheckgetmsgsignedpksk_0_11112121211111[color=#804059,
                                                                    process="if <ct.4, pk(sk1.1), pk2.4>=check_getmsg(signed2.1, pk(sk1.1))"]:
     [ State_11112121211111( signed, signed2, sk1, skT, ct, pk2 ) ]
    --[ Pred_Eq( <ct, pk(sk1), pk2>, z ) ]->
     [ State_111121212111111( signed, signed2, sk1, skT, ct, pk2 ) ]
    variants (modulo AC)
    1. signed2
             = signed2.12
       sk1   = sk1.12
       z     = check_getmsg(signed2.12, pk(sk1.12))
    
    2. signed2
             = sign(x.12, x.13)
       sk1   = x.13
       z     = x.12
  */

rule (modulo E) eventAbortCertct_0_111121212111111[color=#804059,
                                                   process="event AbortCert( ct.4 );"]:
   [ State_111121212111111( signed.1, signed2.1, sk1.1, skT.1, ct.4, pk2.4 )
   ]
  --[ AbortCert( ct.4 ) ]->
   [ ]

  /*
  rule (modulo AC) eventAbortCertct_0_111121212111111[color=#804059,
                                                      process="event AbortCert( ct.4 );"]:
     [ State_111121212111111( signed, signed2, sk1, skT, ct, pk2 ) ]
    --[ AbortCert( ct ) ]->
     [ ]
  */

rule (modulo E) ifctpkskpkcheckgetmsgsignedpksk_1_11112121211111[color=#804059,
                                                                 process="if <ct.4, pk(sk1.1), pk2.4>=check_getmsg(signed2.1, pk(sk1.1))"]:
   [ State_11112121211111( signed.1, signed2.1, sk1.1, skT.1, ct.4, pk2.4 )
   ]
  --[
  Pred_Not_Eq( <ct.4, pk(sk1.1), pk2.4>, check_getmsg(signed2.1, pk(sk1.1))
  )
  ]->
   [ ]

  /*
  rule (modulo AC) ifctpkskpkcheckgetmsgsignedpksk_1_11112121211111[color=#804059,
                                                                    process="if <ct.4, pk(sk1.1), pk2.4>=check_getmsg(signed2.1, pk(sk1.1))"]:
     [ State_11112121211111( signed, signed2, sk1, skT, ct, pk2 ) ]
    --[ Pred_Not_Eq( <ct, pk(sk1), pk2>, z ) ]->
     [ ]
    variants (modulo AC)
    1. signed2
             = signed2.12
       sk1   = sk1.12
       z     = check_getmsg(signed2.12, pk(sk1.12))
    
    2. signed2
             = sign(x.12, x.13)
       sk1   = x.13
       z     = x.12
  */

rule (modulo E) p_1_111121212[color=#ffffff, process="!"]:
   [ !Semistate_1111212121( skT.1 ) ]
  -->
   [ !Semistate_111121212121( skT.1 ), State_111121212111( skT.1 ) ]

  /*
  rule (modulo AC) p_1_111121212[color=#ffffff, process="!"]:
     [ !Semistate_1111212121( skT ) ]
    -->
     [ !Semistate_111121212121( skT ), State_111121212111( skT ) ]
  */

rule (modulo E) p_1_11112121212[color=#ffffff, process="!"]:
   [
   !Semistate_111121212121( skT.1 ),
   In( sign(<sign(ct, sk1.2), sign(ct, sk2.1)>, skT.1) )
   ]
  --[ ResolveCert( ct ) ]->
   [ ]

  /*
  rule (modulo AC) p_1_11112121212[color=#ffffff, process="!"]:
     [
     !Semistate_111121212121( skT ),
     In( sign(<sign(ct, sk1), sign(ct, sk2)>, skT) )
     ]
    --[ ResolveCert( ct ) ]->
     [ ]
  */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒ (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_Not_Eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction locking_0:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_0( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_1:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_1( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_2:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_2( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 3.0. OK.
 checking installation: OK.


analyzing: examples/sapic/fast/GJM-contract/contract.spthy

------------------------------------------------------------------------------
analyzed: examples/sapic/fast/GJM-contract/contract.spthy

  output:          examples/sapic/fast/GJM-contract/contract.spthy.tmp
  processing time: 6.953393479s
  aborted_and_resolved_exclusive (all-traces): verified (19 steps)
  aborted_contract_reachable (exists-trace): verified (6 steps)
  resolved1_contract_reachable (exists-trace): verified (10 steps)
  resolved2_contract_reachable (exists-trace): verified (10 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: examples/sapic/fast/GJM-contract/contract.spthy

  output:          examples/sapic/fast/GJM-contract/contract.spthy.tmp
  processing time: 6.953393479s
  aborted_and_resolved_exclusive (all-traces): verified (19 steps)
  aborted_contract_reachable (exists-trace): verified (6 steps)
  resolved1_contract_reachable (exists-trace): verified (10 steps)
  resolved2_contract_reachable (exists-trace): verified (10 steps)

==============================================================================
*/
