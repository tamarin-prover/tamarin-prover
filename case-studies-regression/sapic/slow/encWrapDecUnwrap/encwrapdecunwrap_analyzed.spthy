theory EncWrapDecUnwrap begin

// Function signature and definition of the equational theory E

functions: att/1, fst/1, key/1, pair/2, sdec/2, senc/2, sencSucc/2,
           snd/1, true/0
equations:
    att(<k, a>) = a,
    fst(<x.1, x.2>) = x.1,
    key(<k, a>) = k,
    sdec(senc(x.1, x.2), x.2) = x.1,
    sencSucc(senc(m, k), k) = true,
    snd(<x.1, x.2>) = x.2

heuristic: p

lemma dec_limits [sources]:
  all-traces
  "∀ k m #t1.
    (DecUsing( k, m ) @ #t1) ⇒
    (((((∃ h2 k2 #t2 #t3.
          (((NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)) ∧ (#t2 < #t1)) ∧
          (#t3 < #t1)) ∨
        (∃ #t2. (EncUsing( k, m ) @ #t2) ∧ (#t2 < #t1))) ∨
       (∃ h2 k2 #t2 #t3.
         (((Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)) ∧ (#t2 < #t1)) ∧
         (#t3 < #t1))) ∨
      (∃ #t2 #t3 h1 h2 k2.
        (((WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)) ∧ (#t2 < #t1)) ∧
        (#t3 < #t1))) ∨
     (∃ #t2 #t3 h1 h2 k2.
       (((Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)) ∧
        (#t2 < #t1)) ∧
       (#t3 < #t1)))"
/*
guarded formula characterizing all counter-examples:
"∃ k m #t1.
  (DecUsing( k, m ) @ #t1)
 ∧
  (∀ h2 k2 #t2 #t3.
    (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
   ⇒
    ((¬(#t2 < #t1)) ∨ (¬(#t3 < #t1)))) ∧
  (∀ #t2. (EncUsing( k, m ) @ #t2) ⇒ ¬(#t2 < #t1)) ∧
  (∀ h2 k2 #t2 #t3.
    (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
   ⇒
    ((¬(#t2 < #t1)) ∨ (¬(#t3 < #t1)))) ∧
  (∀ #t2 #t3 h1 h2 k2.
    (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
   ⇒
    ((¬(#t2 < #t1)) ∨ (¬(#t3 < #t1)))) ∧
  (∀ #t2 #t3 h1 h2 k2.
    (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
   ⇒
    ((¬(#t2 < #t1)) ∨ (¬(#t3 < #t1))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ k m #t1.
           (DecUsing( k, m ) @ #t1)
          ⇒
           ((last(#t1)) ∨
            (∃ h2 k2 #t2 #t3.
              (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
             ∧
              (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1)) ∨
            (∃ #t2. (EncUsing( k, m ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #t1)) ∨
            (∃ h2 k2 #t2 #t3.
              (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
             ∧
              (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1)) ∨
            (∃ #t2 #t3 h1 h2 k2.
              (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
             ∧
              (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1)) ∨
            (∃ #t2 #t3 h1 h2 k2.
              (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
             ∧
              (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_3( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_4( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_5( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_6( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#t1))  ∥
           (∃ h2 k2 #t2 #t3.
             (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
            ∧
             (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1))  ∥
           (∃ #t2. (EncUsing( k, m ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #t1))  ∥
           (∃ h2 k2 #t2 #t3.
             (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
            ∧
             (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1))  ∥
           (∃ #t2 #t3 h1 h2 k2.
             (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
            ∧
             (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1))  ∥
           (∃ #t2 #t3 h1 h2 k2.
             (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
            ∧
             (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #t1) ∧ (#t3 < #t1)) )
      case case_1
      solve( State_1111211111( L_h, c, v, lock ) ▶₀ #t1 )
        case ifsencSuccckeyvtrue_0_111121111
        solve( !KU( senc(m, k) ) @ #vk.2 )
          case c_senc
          solve( Insert( L_h, <k, 'dec'> ) @ #t2 )
            case insertLhkeyvdec_0_11111211111
            solve( State_11111211111( L_h, v, lock ) ▶₀ #t2 )
              case eventDecKeyLhkeyv_0_1111121111
              solve( ((#vr.3 < #vr.15) ∧
                      (∃ #t2.
                        (Unlock_3( '3', ~n, L_h ) @ #t2)
                       ∧
                        (#vr.3 < #t2) ∧
                        (#t2 < #vr.15) ∧
                        (∀ #t0 pp. (Unlock( pp, ~n, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                        (∀ pp lpp #t0.
                          (Lock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t0 = #vr.3) ∨ (#t2 < #t0))) ∧
                        (∀ pp lpp #t0.
                          (Unlock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                     (#vr.15 < #vr.3) )
                case case_1
                solve( State_111121111111( L_h, c, v, ~n ) ▶₀ #t2.1 )
                  case outsdecckeyv_0_11112111111
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( State_111112111111( L_h, v, ~n.1 ) ▶₀ #t2.1 )
                  case insertLhkeyvdec_0_11111211111
                  solve( (#t2.2 < #t2.3)  ∥ (#t2.2 = #t2.3) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    solve( Insert( L_h, <k, 'init'> ) @ #t2.2 )
                      case insertLhkinit_0_111111111111
                      solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.2 )
                        case eventNewKeyLhk_0_11111111111
                        by contradiction /* from formulas */
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case outsdecckeyv_0_11112111111
          solve( (∃ h2 k2 #t2 #t3.
                   (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                  ∧
                   (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #vr.13) ∧ (#t3 < #vr.13))  ∥
                 (∃ #t2. (EncUsing( z, t ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #vr.13))  ∥
                 (∃ h2 k2 #t2 #t3.
                   (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                  ∧
                   (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #vr.13) ∧ (#t3 < #vr.13))  ∥
                 (∃ #t2 #t3 h1 h2 k2.
                   (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                  ∧
                   (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #vr.13) ∧ (#t3 < #vr.13))  ∥
                 (∃ #t2 #t3 h1 h2 k2.
                   (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                  ∧
                   (¬(last(#t3))) ∧ (¬(last(#t2))) ∧ (#t2 < #vr.13) ∧ (#t3 < #vr.13)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( State_11121111( L_h.2, t, v, lock ) ▶₀ #t2 )
              case ifattvdec_0_1112111
              by contradiction /* cyclic */
            qed
          next
            case case_3
            by contradiction /* from formulas */
          next
            case case_4
            by contradiction /* from formulas */
          next
            case case_5
            by contradiction /* from formulas */
          qed
        next
          case outsenckeyvkeyv_0_1121111111_case_1
          solve( Insert( L_h, <k, 'dec'> ) @ #t2 )
            case insertLhkeyvdec_0_11111211111
            solve( State_11111211111( L_h, v, lock ) ▶₀ #t2 )
              case eventDecKeyLhkeyv_0_1111121111
              solve( ((#vr.3 < #vr.26) ∧
                      (∃ #t2.
                        (Unlock_3( '3', ~n, L_h ) @ #t2)
                       ∧
                        (#vr.3 < #t2) ∧
                        (#t2 < #vr.26) ∧
                        (∀ #t0 pp. (Unlock( pp, ~n, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                        (∀ pp lpp #t0.
                          (Lock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t0 = #vr.3) ∨ (#t2 < #t0))) ∧
                        (∀ pp lpp #t0.
                          (Unlock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                     (#vr.26 < #vr.3) )
                case case_1
                solve( State_111121111111( L_h, c, v, ~n ) ▶₀ #t2.1 )
                  case outsdecckeyv_0_11112111111
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( State_111112111111( L_h, v, ~n.1 ) ▶₀ #t2.1 )
                  case insertLhkeyvdec_0_11111211111
                  solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    solve( Insert( L_h2, <m, 'wrap'> ) @ #t2.2 )
                      case insertLhkeyvwrap_0_111111211111
                      solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                        case eventWrapKeyLhkeyv_0_11111121111
                        solve( Insert( L_h1, <k, 'wrap'> ) @ #t2.3 )
                          case insertLhkeyvwrap_0_111111211111
                          solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                            case eventWrapKeyLhkeyv_0_11111121111
                            by contradiction /* from formulas */
                          qed
                        next
                          case insertLhmwrap_0_121111111
                          solve( State_121111111( L_h.1, L_h1, k.1, k, v, lock ) ▶₀ #t2.3 )
                            case eventUnwrappedLhm_0_12111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    next
                      case insertLhmwrap_0_121111111
                      solve( State_121111111( L_h.1, L_h2, k.1, m, v, lock ) ▶₀ #t2.2 )
                        case eventUnwrappedLhm_0_12111111
                        solve( Insert( L_h1, <k, 'wrap'> ) @ #t2.3 )
                          case insertLhkeyvwrap_0_111111211111
                          solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                            case eventWrapKeyLhkeyv_0_11111121111
                            by contradiction /* from formulas */
                          qed
                        next
                          case insertLhmwrap_0_121111111
                          solve( State_121111111( L_h.2, L_h1, k.2, k, v, lock ) ▶₀ #t2.3 )
                            case eventUnwrappedLhm_0_12111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case outsenckeyvkeyv_0_1121111111_case_2
          solve( Insert( L_h, <k, 'dec'> ) @ #t2 )
            case insertLhkeyvdec_0_11111211111
            solve( State_11111211111( L_h, v, lock ) ▶₀ #t2 )
              case eventDecKeyLhkeyv_0_1111121111
              solve( ((#vr.3 < #vr.27) ∧
                      (∃ #t2.
                        (Unlock_3( '3', ~n, L_h ) @ #t2)
                       ∧
                        (#vr.3 < #t2) ∧
                        (#t2 < #vr.27) ∧
                        (∀ #t0 pp. (Unlock( pp, ~n, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                        (∀ pp lpp #t0.
                          (Lock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t0 = #vr.3) ∨ (#t2 < #t0))) ∧
                        (∀ pp lpp #t0.
                          (Unlock( pp, lpp, L_h ) @ #t0)
                         ⇒
                          ((#t0 < #vr.3) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                     (#vr.27 < #vr.3) )
                case case_1
                solve( State_111121111111( L_h, c, v, ~n ) ▶₀ #t2.1 )
                  case outsdecckeyv_0_11112111111
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( State_111112111111( L_h, v, ~n.1 ) ▶₀ #t2.1 )
                  case insertLhkeyvdec_0_11111211111
                  solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    solve( Insert( L_h2, <z, 'wrap'> ) @ #t2.2 )
                      case insertLhkeyvwrap_0_111111211111
                      solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                        case eventWrapKeyLhkeyv_0_11111121111
                        solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.3 )
                          case insertLhkeyvwrap_0_111111211111
                          solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                            case eventWrapKeyLhkeyv_0_11111121111
                            solve( ((#vr.19 < #vr.50) ∧
                                    (∃ #t2.
                                      (Unlock_5( '5', ~n.3, L_h1 ) @ #t2)
                                     ∧
                                      (#vr.19 < #t2) ∧
                                      (#t2 < #vr.50) ∧
                                      (∀ #t0 pp. (Unlock( pp, ~n.3, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                      (∀ pp lpp #t0.
                                        (Lock( pp, lpp, L_h1 ) @ #t0)
                                       ⇒
                                        ((#t0 < #vr.19) ∨ (#t0 = #vr.19) ∨ (#t2 < #t0))) ∧
                                      (∀ pp lpp #t0.
                                        (Unlock( pp, lpp, L_h1 ) @ #t0)
                                       ⇒
                                        ((#t0 < #vr.19) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                   (#vr.50 < #vr.19) )
                              case case_1
                              solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.3 ) ▶₀ #t2.4 )
                                case outsenckeyvkeyv_0_1121111111
                                by contradiction /* cyclic */
                              qed
                            next
                              case case_2
                              solve( State_11111121111111( L_h1, v, ~n.4 ) ▶₀ #t2.4 )
                                case eventWrapHandleLh_0_1111112111111
                                solve( (#t2.7 < #t2.8)  ∥ (#t2.7 = #t2.8) )
                                  case case_1
                                  by contradiction /* from formulas */
                                next
                                  case case_2
                                  solve( Insert( L_h, <k, 'init'> ) @ #t2.5 )
                                    case insertLhkinit_0_111111111111
                                    solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.5 )
                                      case eventNewKeyLhk_0_11111111111
                                      solve( State_11111111111111( ~n, k, ~n.7 ) ▶₀ #t2.6 )
                                        case outLh_0_1111111111111
                                        solve( Insert( L_h2, <z, 'init'> ) @ #t2.7 )
                                          case insertLhkinit_0_111111111111
                                          solve( State_111111111111( L_h2, z, lock ) ▶₀ #t2.7 )
                                            case eventNewKeyLhk_0_11111111111
                                            by contradiction /* impossible chain */
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        next
                          case insertLhmwrap_0_121111111
                          solve( State_121111111( L_h.1, L_h1, k.1, z.1, v, lock ) ▶₀ #t2.3 )
                            case eventUnwrappedLhm_0_12111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    next
                      case insertLhmwrap_0_121111111
                      solve( State_121111111( L_h.1, L_h2, k.1, z, v, lock ) ▶₀ #t2.2 )
                        case eventUnwrappedLhm_0_12111111
                        solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.3 )
                          case insertLhkeyvwrap_0_111111211111
                          solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                            case eventWrapKeyLhkeyv_0_11111121111
                            solve( ((#vr.19 < #vr.47) ∧
                                    (∃ #t2.
                                      (Unlock_5( '5', ~n.4, L_h1 ) @ #t2)
                                     ∧
                                      (#vr.19 < #t2) ∧
                                      (#t2 < #vr.47) ∧
                                      (∀ #t0 pp. (Unlock( pp, ~n.4, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                      (∀ pp lpp #t0.
                                        (Lock( pp, lpp, L_h1 ) @ #t0)
                                       ⇒
                                        ((#t0 < #vr.19) ∨ (#t0 = #vr.19) ∨ (#t2 < #t0))) ∧
                                      (∀ pp lpp #t0.
                                        (Unlock( pp, lpp, L_h1 ) @ #t0)
                                       ⇒
                                        ((#t0 < #vr.19) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                   (#vr.47 < #vr.19) )
                              case case_1
                              solve( State_11211111111( L_h1, L_h2, v1, v2, ~n.4 ) ▶₀ #t2.4 )
                                case outsenckeyvkeyv_0_1121111111
                                by contradiction /* cyclic */
                              qed
                            next
                              case case_2
                              solve( State_11111121111111( L_h1, v, ~n.5 ) ▶₀ #t2.4 )
                                case eventWrapHandleLh_0_1111112111111
                                solve( (#t2.7 < #t2.8)  ∥ (#t2.7 = #t2.8) )
                                  case case_1
                                  by contradiction /* from formulas */
                                next
                                  case case_2
                                  solve( Insert( L_h, <k, 'init'> ) @ #t2.5 )
                                    case insertLhkinit_0_111111111111
                                    solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.5 )
                                      case eventNewKeyLhk_0_11111111111
                                      solve( State_11111111111111( ~n, k.1, ~n.8 ) ▶₀ #t2.6 )
                                        case outLh_0_1111111111111
                                        solve( !KU( senc(z, k) ) @ #vk.12 )
                                          case c_senc
                                          by contradiction /* cyclic */
                                        next
                                          case outsdecckeyv_0_11112111111
                                          solve( (∃ h2 k2 #t2 #t3.
                                                   (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                  ∧
                                                   (¬(last(#t3))) ∧
                                                   (¬(last(#t2))) ∧
                                                   (#t2 < #vr.71) ∧
                                                   (#t3 < #vr.71))  ∥
                                                 (∃ #t2.
                                                   (EncUsing( z.2, t ) @ #t2)
                                                  ∧
                                                   (¬(last(#t2))) ∧ (#t2 < #vr.71))  ∥
                                                 (∃ h2 k2 #t2 #t3.
                                                   (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                  ∧
                                                   (¬(last(#t3))) ∧
                                                   (¬(last(#t2))) ∧
                                                   (#t2 < #vr.71) ∧
                                                   (#t3 < #vr.71))  ∥
                                                 (∃ #t2 #t3 h1 h2 k2.
                                                   (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                  ∧
                                                   (¬(last(#t3))) ∧
                                                   (¬(last(#t2))) ∧
                                                   (#t2 < #vr.71) ∧
                                                   (#t3 < #vr.71))  ∥
                                                 (∃ #t2 #t3 h1 h2 k2.
                                                   (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                  ∧
                                                   (¬(last(#t3))) ∧
                                                   (¬(last(#t2))) ∧
                                                   (#t2 < #vr.71) ∧
                                                   (#t3 < #vr.71)) )
                                            case case_1
                                            by contradiction /* from formulas */
                                          next
                                            case case_2
                                            solve( State_11121111( L_h.2, t, v, lock ) ▶₀ #t2.7 )
                                              case ifattvdec_0_1112111
                                              by contradiction /* cyclic */
                                            qed
                                          next
                                            case case_3
                                            by contradiction /* from formulas */
                                          next
                                            case case_4
                                            by contradiction /* from formulas */
                                          next
                                            case case_5
                                            by contradiction /* from formulas */
                                          qed
                                        next
                                          case outsenckeyvkeyv_0_1121111111_case_1
                                          solve( !KU( ~n.4 ) @ #vk.9 )
                                            case outLh_0_1211111111
                                            solve( (#t2.7 < #t2.11)  ∥ (#t2.7 = #t2.11) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( Insert( L_h, <k, 'wrap'> ) @ #t2.7 )
                                                case insertLhkeyvwrap_0_111111211111
                                                solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.7 )
                                                  case eventWrapKeyLhkeyv_0_11111121111
                                                  solve( ((#vr.40 < #vr.85) ∧
                                                          (∃ #t2.
                                                            (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                           ∧
                                                            (#vr.40 < #t2) ∧
                                                            (#t2 < #vr.85) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, L_h ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.40) ∨
                                                               (#t0 = #vr.40) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, L_h ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.40) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.85 < #vr.40) )
                                                    case case_1
                                                    solve( State_12111111111( L_h, L_h2.1, k.1, m.1, v, ~n.5
                                                           ) ▶₀ #t2.8 )
                                                      case outLh_0_1211111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111121111111( L_h, v, ~n.9 ) ▶₀ #t2.8 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                        case case_1
                                                        by contradiction /* from formulas */
                                                      next
                                                        case case_2
                                                        solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.9 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z.1, lock
                                                                 ) ▶₀ #t2.9 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case insertLhmwrap_0_121111111
                                                solve( State_121111111( L_h.1, L_h, k.1, k, v, lock
                                                       ) ▶₀ #t2.7 )
                                                  case eventUnwrappedLhm_0_12111111
                                                  solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.8 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( L_h1, z.1, lock ) ▶₀ #t2.8 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      by contradiction /* from formulas */
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case outsdecckeyv_0_11112111111
                                            solve( (∃ h2 k2 #t2 #t3.
                                                     (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.82) ∧
                                                     (#t3 < #vr.82))  ∥
                                                   (∃ #t2.
                                                     (EncUsing( z.2, t ) @ #t2)
                                                    ∧
                                                     (¬(last(#t2))) ∧ (#t2 < #vr.82))  ∥
                                                   (∃ h2 k2 #t2 #t3.
                                                     (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.82) ∧
                                                     (#t3 < #vr.82))  ∥
                                                   (∃ #t2 #t3 h1 h2 k2.
                                                     (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.82) ∧
                                                     (#t3 < #vr.82))  ∥
                                                   (∃ #t2 #t3 h1 h2 k2.
                                                     (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.82) ∧
                                                     (#t3 < #vr.82)) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( State_11121111( L_h.2, t, v, lock ) ▶₀ #t2.7 )
                                                case ifattvdec_0_1112111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            next
                                              case case_5
                                              by contradiction /* from formulas */
                                            qed
                                          next
                                            case outsenckeyvkeyv_0_1121111111
                                            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.7 )
                                              case insertLhkeyvwrap_0_111111211111
                                              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.7 )
                                                case eventWrapKeyLhkeyv_0_11111121111
                                                solve( ((#vr.40 < #vr.96) ∧
                                                        (∃ #t2.
                                                          (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                         ∧
                                                          (#vr.40 < #t2) ∧
                                                          (#t2 < #vr.96) ∧
                                                          (∀ #t0 pp.
                                                            (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                          (∀ pp lpp #t0.
                                                            (Lock( pp, lpp, L_h ) @ #t0)
                                                           ⇒
                                                            ((#t0 < #vr.40) ∨ (#t0 = #vr.40) ∨ (#t2 < #t0))) ∧
                                                          (∀ pp lpp #t0.
                                                            (Unlock( pp, lpp, L_h ) @ #t0)
                                                           ⇒
                                                            ((#t0 < #vr.40) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                       (#vr.96 < #vr.40) )
                                                  case case_1
                                                  solve( State_12111111111( L_h, L_h2.2, k.1, m.1, v, ~n.5
                                                         ) ▶₀ #t2.8 )
                                                    case outLh_0_1211111111
                                                    by contradiction /* cyclic */
                                                  qed
                                                next
                                                  case case_2
                                                  solve( State_11111121111111( L_h, v, ~n.9 ) ▶₀ #t2.8 )
                                                    case eventWrapHandleLh_0_1111112111111
                                                    solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                      case case_1
                                                      by contradiction /* from formulas */
                                                    next
                                                      case case_2
                                                      solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.9 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z.1, lock
                                                               ) ▶₀ #t2.9 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case insertLhmwrap_0_121111111
                                              solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.7 )
                                                case eventUnwrappedLhm_0_12111111
                                                solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.8 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( L_h1, z.1, lock ) ▶₀ #t2.8 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    by contradiction /* from formulas */
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case outsenckeyvkeyv_0_1121111111_case_2
                                          solve( !KU( ~n.4 ) @ #vk.9 )
                                            case outLh_0_1211111111
                                            solve( (#t2.7 < #t2.11)  ∥ (#t2.7 = #t2.11) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( Insert( L_h, <k, 'wrap'> ) @ #t2.7 )
                                                case insertLhkeyvwrap_0_111111211111
                                                solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.7 )
                                                  case eventWrapKeyLhkeyv_0_11111121111
                                                  solve( ((#vr.40 < #vr.86) ∧
                                                          (∃ #t2.
                                                            (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                           ∧
                                                            (#vr.40 < #t2) ∧
                                                            (#t2 < #vr.86) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, L_h ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.40) ∨
                                                               (#t0 = #vr.40) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, L_h ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.40) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.86 < #vr.40) )
                                                    case case_1
                                                    solve( State_12111111111( L_h, L_h2.1, k.1, m.1, v, ~n.5
                                                           ) ▶₀ #t2.8 )
                                                      case outLh_0_1211111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111121111111( L_h, v, ~n.9 ) ▶₀ #t2.8 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                        case case_1
                                                        by contradiction /* from formulas */
                                                      next
                                                        case case_2
                                                        solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.9 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z.1, lock
                                                                 ) ▶₀ #t2.9 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case insertLhmwrap_0_121111111
                                                solve( State_121111111( L_h.1, L_h, k.1, k, v, lock
                                                       ) ▶₀ #t2.7 )
                                                  case eventUnwrappedLhm_0_12111111
                                                  solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.8 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( L_h1, z.1, lock ) ▶₀ #t2.8 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      by contradiction /* from formulas */
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case outsdecckeyv_0_11112111111
                                            solve( (∃ h2 k2 #t2 #t3.
                                                     (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.83) ∧
                                                     (#t3 < #vr.83))  ∥
                                                   (∃ #t2.
                                                     (EncUsing( z.4, t ) @ #t2)
                                                    ∧
                                                     (¬(last(#t2))) ∧ (#t2 < #vr.83))  ∥
                                                   (∃ h2 k2 #t2 #t3.
                                                     (Unwrapped( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.83) ∧
                                                     (#t3 < #vr.83))  ∥
                                                   (∃ #t2 #t3 h1 h2 k2.
                                                     (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.83) ∧
                                                     (#t3 < #vr.83))  ∥
                                                   (∃ #t2 #t3 h1 h2 k2.
                                                     (Unwrapped( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
                                                    ∧
                                                     (¬(last(#t3))) ∧
                                                     (¬(last(#t2))) ∧
                                                     (#t2 < #vr.83) ∧
                                                     (#t3 < #vr.83)) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( State_11121111( L_h.2, t, v, lock ) ▶₀ #t2.7 )
                                                case ifattvdec_0_1112111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            next
                                              case case_5
                                              by contradiction /* from formulas */
                                            qed
                                          next
                                            case outsenckeyvkeyv_0_1121111111
                                            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.7 )
                                              case insertLhkeyvwrap_0_111111211111
                                              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.7 )
                                                case eventWrapKeyLhkeyv_0_11111121111
                                                solve( ((#vr.40 < #vr.97) ∧
                                                        (∃ #t2.
                                                          (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                         ∧
                                                          (#vr.40 < #t2) ∧
                                                          (#t2 < #vr.97) ∧
                                                          (∀ #t0 pp.
                                                            (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                          (∀ pp lpp #t0.
                                                            (Lock( pp, lpp, L_h ) @ #t0)
                                                           ⇒
                                                            ((#t0 < #vr.40) ∨ (#t0 = #vr.40) ∨ (#t2 < #t0))) ∧
                                                          (∀ pp lpp #t0.
                                                            (Unlock( pp, lpp, L_h ) @ #t0)
                                                           ⇒
                                                            ((#t0 < #vr.40) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                       (#vr.97 < #vr.40) )
                                                  case case_1
                                                  solve( State_12111111111( L_h, L_h2.2, k.1, m.1, v, ~n.5
                                                         ) ▶₀ #t2.8 )
                                                    case outLh_0_1211111111
                                                    by contradiction /* cyclic */
                                                  qed
                                                next
                                                  case case_2
                                                  solve( State_11111121111111( L_h, v, ~n.9 ) ▶₀ #t2.8 )
                                                    case eventWrapHandleLh_0_1111112111111
                                                    solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                      case case_1
                                                      by contradiction /* from formulas */
                                                    next
                                                      case case_2
                                                      solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.9 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z.1, lock
                                                               ) ▶₀ #t2.9 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case insertLhmwrap_0_121111111
                                              solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.7 )
                                                case eventUnwrappedLhm_0_12111111
                                                solve( Insert( L_h1, <z.1, 'init'> ) @ #t2.8 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( L_h1, z.1, lock ) ▶₀ #t2.8 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    by contradiction /* from formulas */
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case outsencmkeyv_0_111211111
                                          by contradiction /* cyclic */
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        next
                          case insertLhmwrap_0_121111111
                          solve( State_121111111( L_h.2, L_h1, k.2, z.1, v, lock ) ▶₀ #t2.3 )
                            case eventUnwrappedLhm_0_12111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case outsencmkeyv_0_111211111
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    next
      case case_4
      by contradiction /* from formulas */
    next
      case case_5
      by contradiction /* from formulas */
    next
      case case_6
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (#t1.1 = #t2)  ∥ (#t2 < #t1.1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_3
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_4
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_5
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_3( '3', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_4( '4', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_8
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_5( '5', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_9
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock_6( '6', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1.1 = #t2) ∨
              (#t2 < #t1.1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (¬(#t0 = #t1.1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (¬(#t0 = #t1.1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1.1) ∨ (#t1.1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma wrap_key_origins [use_induction, reuse]:
  all-traces
  "∀ h2 k #t2.
    (Unwrapped( h2, k ) @ #t2) ⇒
    (((((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ (#t1 < #t2)) ∧
        (∃ hp #t0.
          ((WrapKey( hp, k ) @ #t0) ∧ ((#t0 = #t2) ∨ (#t0 < #t2))) ∧
          (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ (#t0 < #t1)))) ∨
       (∃ h k2 #t1 #t0.
         (((NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧ (#t1 < #t2)) ∧
         (#t0 < #t2))) ∨
      (∃ #t0 #t1 h1 h2.1 k.1.
        (((WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)) ∧
         (#t0 < #t2)) ∧
        (#t1 < #t2))) ∨
     (∃ #t0 #t1 h1 h2.1 k.1.
       (((Unwrapped( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)) ∧
        (#t0 < #t2)) ∧
       (#t1 < #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ h2 k #t2.
  (Unwrapped( h2, k ) @ #t2)
 ∧
  (((∀ h1 #t1. (NewKey( h1, k ) @ #t1) ⇒ ¬(#t1 < #t2)) ∨
    (∀ hp #t0.
      (WrapKey( hp, k ) @ #t0)
     ⇒
      (((¬(#t0 = #t2)) ∧ (¬(#t0 < #t2))) ∨
       (∃ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ∧ ¬(#t0 < #t1)))))) ∧
  (∀ h k2 #t1 #t0.
    (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
   ⇒
    ((¬(#t1 < #t2)) ∨ (¬(#t0 < #t2)))) ∧
  (∀ #t0 #t1 h1 h2.1 k.1.
    (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
   ⇒
    ((¬(#t0 < #t2)) ∨ (¬(#t1 < #t2)))) ∧
  (∀ #t0 #t1 h1 h2.1 k.1.
    (Unwrapped( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
   ⇒
    ((¬(#t0 < #t2)) ∨ (¬(#t1 < #t2))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ⇒ ¬(#t1 < #t2))  ∥
         (∀ hp #t0.
           (WrapKey( hp, k.1 ) @ #t0)
          ⇒
           (((¬(#t0 = #t2)) ∧ (¬(#t0 < #t2))) ∨
            (∃ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ∧ ¬(#t0 < #t1)))) )
    case case_1
    solve( (∀ h2 k #t2.
             (Unwrapped( h2, k ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2)) ∧
               (∃ hp #t0.
                 (WrapKey( hp, k ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                 (∀ hpp #t1.
                   (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1))))) ∨
              (∃ h k2 #t1 #t0.
                (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
               ∧
                (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2) ∧ (#t0 < #t2)) ∨
              (∃ #t0 #t1 h1 h2.1 k.1.
                (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
               ∧
                (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2)) ∨
              (∃ #t0 #t1 h1 h2.1 k.1.
                (Unwrapped( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
               ∧
                (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2))))  ∥
           (∃ x y #t3.
             (IsIn( x, y ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (∀ #t2.
               (Insert( x, y ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t1 yp.
                  (Insert( x, yp ) @ #t1)
                 ∧
                  (¬(last(#t1))) ∧
                  (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                  (¬(#t1 = #t2)) ∧
                  (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_0( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_1( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_2( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_3( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_4( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_5( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_6( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3))) )
      case case_1
      solve( (last(#t2))  ∥
             ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2)) ∧
              (∃ hp #t0.
                (WrapKey( hp, k.1 ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                (∀ hpp #t1.
                  (Unwrapped( hpp, k.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2) ∧ (#t0 < #t2))  ∥
             (∃ #t0 #t1 h1 h2 k.
               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
              ∧
               (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2))  ∥
             (∃ #t0 #t1 h1 h2 k.
               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
              ∧
               (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2)) )
        case case_1
        solve( State_12111111( L_h, h2, k, k.1, v, lock ) ▶₀ #t2 )
          case newLh_0_1211111
          solve( !KU( senc(k.1, k) ) @ #vk.2 )
            case c_senc
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.13) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.13) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.13 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h, <k, 'init'> ) @ #t2.3 )
                        case insertLhkinit_0_111111111111
                        solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.3 )
                          case eventNewKeyLhk_0_11111111111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.10)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.10) ∨ (#t0 < #vr.10))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.10) ∧ (#t0 < #vr.10))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.10) ∧ (#t1 < #vr.10))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.10) ∧ (#t1 < #vr.10)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsdecckeyv_0_11112111111_case_1
            by contradiction /* from formulas */
          next
            case outsdecckeyv_0_11112111111_case_2
            solve( ((∃ h1 #t1.
                      (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.1)) ∧
                    (∃ hp #t0.
                      (WrapKey( hp, k2 ) @ #t0)
                     ∧
                      (¬(last(#t0))) ∧
                      (((#t0 = #t2.1) ∨ (#t0 < #t2.1))) ∧
                      (∀ hpp #t1.
                        (Unwrapped( hpp, k2 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                   (∃ h k2 #t1 #t0.
                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                    ∧
                     (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.1) ∧ (#t0 < #t2.1))  ∥
                   (∃ #t0 #t1 h1 h2 k.
                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2.1) ∧ (#t1 < #t2.1))  ∥
                   (∃ #t0 #t1 h1 h2 k.
                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2.1) ∧ (#t1 < #t2.1)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            next
              case case_4
              by contradiction /* from formulas */
            qed
          next
            case outsdecckeyv_0_11112111111_case_3
            by contradiction /* from formulas */
          next
            case outsdecckeyv_0_11112111111_case_4
            by contradiction /* from formulas */
          next
            case outsenckeyvkeyv_0_1121111111_case_1
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.24) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.24) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.24 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2.1, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.5 < #t2.6)  ∥ (#t2.5 = #t2.6) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h2, <k.1, 'wrap'> ) @ #t2.3 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.3 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <k, 'wrap'> ) @ #t2.4 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.4 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.16 < #vr.49) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.4, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.16 < #t2) ∧
                                        (#t2 < #vr.49) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.4, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.16) ∨ (#t0 = #vr.16) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.16) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.49 < #vr.16) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.4 ) ▶₀ #t2.5 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.5 ) ▶₀ #t2.5 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( Insert( L_h, <k, 'init'> ) @ #t2.6 )
                                      case insertLhkinit_0_111111111111
                                      solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.6 )
                                        case eventNewKeyLhk_0_11111111111
                                        solve( State_11111111111111( ~n, k.1, ~n.8 ) ▶₀ #t2.7 )
                                          case outLh_0_1111111111111
                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                            case insertLhkinit_0_111111111111
                                            solve( State_111111111111( L_h2, k, lock ) ▶₀ #t2.8 )
                                              case eventNewKeyLhk_0_11111111111
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, k, v, lock ) ▶₀ #t2.4 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.46)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, k ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.46) ∨ (#t0 < #vr.46))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.46) ∧ (#t0 < #vr.46))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.46) ∧ (#t1 < #vr.46))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.46) ∧ (#t1 < #vr.46)) )
                                case case_1
                                solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                                  case newk_0_1111111111
                                  solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                                    case ifattvinit_0_1111112111
                                    solve( Insert( L_h, <~n, 'init'> ) @ #t2.5 )
                                      case insertLhkinit_0_111111111111
                                      solve( State_111111111111( L_h, ~n, lock ) ▶₀ #t2.5 )
                                        case eventNewKeyLhk_0_11111111111
                                        solve( State_11111111111111( ~n.2, k.2, ~n.3 ) ▶₀ #t2.6 )
                                          case outLh_0_1111111111111
                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.7 )
                                            case insertLhkinit_0_111111111111
                                            solve( State_111111111111( L_h2, k, lock ) ▶₀ #t2.7 )
                                              case eventNewKeyLhk_0_11111111111
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, k.1, v, lock ) ▶₀ #t2.3 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, k.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.34)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k.1 ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.34) ∨ (#t0 < #vr.34))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, k.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.34) ∧ (#t0 < #vr.34))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.34) ∧ (#t1 < #vr.34))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.34) ∧ (#t1 < #vr.34)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.21)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.21) ∨ (#t0 < #vr.21))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.21) ∧ (#t0 < #vr.21))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.21) ∧ (#t1 < #vr.21))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.21) ∧ (#t1 < #vr.21)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h2, <k, 'wrap'> ) @ #t2.2 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <~n, 'wrap'> ) @ #t2.3 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, <~n, x>, lock ) ▶₀ #t2.3 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.16 < #vr.67) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.10, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.16 < #t2) ∧
                                        (#t2 < #vr.67) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.10, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.16) ∨ (#t0 = #vr.16) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.16) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.67 < #vr.16) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.10 ) ▶₀ #t2.4 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.9 ) ▶₀ #t2.4 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( !KU( senc(~n, k.1) ) @ #vk.10 )
                                      case c_senc
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_1
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_2
                                      solve( ((∃ h1 #t1.
                                                (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                              (∃ hp #t0.
                                                (WrapKey( hp, k2 ) @ #t0)
                                               ∧
                                                (¬(last(#t0))) ∧
                                                (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                (∀ hpp #t1.
                                                  (Unwrapped( hpp, k2 ) @ #t1)
                                                 ⇒
                                                  ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                             (∃ h k2 #t1 #t0.
                                               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                              ∧
                                               (¬(last(#t0))) ∧
                                               (¬(last(#t1))) ∧
                                               (#t1 < #t2.5) ∧
                                               (#t0 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5)) )
                                        case case_1
                                        by contradiction /* from formulas */
                                      next
                                        case case_2
                                        by contradiction /* from formulas */
                                      next
                                        case case_3
                                        by contradiction /* from formulas */
                                      next
                                        case case_4
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case outsdecckeyv_0_11112111111_case_3
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_4
                                      by contradiction /* from formulas */
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_1
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.26 < #vr.92) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.26 < #t2) ∧
                                                        (#t2 < #vr.92) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.92 < #vr.26) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.89)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.89) ∨ (#t0 < #vr.89))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.89) ∧
                                                       (#t0 < #vr.89))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.89) ∧
                                                       (#t1 < #vr.89))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.89) ∧
                                                       (#t1 < #vr.89)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.26 < #vr.103) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.26 < #t2) ∧
                                                      (#t2 < #vr.103) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.103 < #vr.26) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.100)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.100) ∨ (#t0 < #vr.100))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.100) ∧
                                                     (#t0 < #vr.100))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.100) ∧
                                                     (#t1 < #vr.100))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.100) ∧
                                                     (#t1 < #vr.100)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_2
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.26 < #vr.93) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.26 < #t2) ∧
                                                        (#t2 < #vr.93) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.93 < #vr.26) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.90)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.90) ∨ (#t0 < #vr.90))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.90) ∧
                                                       (#t0 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.26 < #vr.104) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.26 < #t2) ∧
                                                      (#t2 < #vr.104) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.104 < #vr.26) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.101)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.101) ∨ (#t0 < #vr.101))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.101) ∧
                                                     (#t0 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsencmkeyv_0_111211111
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, ~n, v, lock ) ▶₀ #t2.3 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, ~n ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.64)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, ~n ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.64) ∨ (#t0 < #vr.64))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, ~n ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.64) ∧ (#t0 < #vr.64))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.64) ∧ (#t1 < #vr.64))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.64) ∧ (#t1 < #vr.64)) )
                                case case_1
                                solve( State_11111111111( h1, ~n, lock ) ▶₀ #t1.1 )
                                  case newk_0_1111111111
                                  solve( State_11111121111( hp.1, <~n, x>, lock ) ▶₀ #t0.1 )
                                    case ifattvinit_0_1111112111
                                    solve( !KU( senc(~n, k.1) ) @ #vk.9 )
                                      case c_senc
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_1
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_2
                                      solve( ((∃ h1 #t1.
                                                (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.4)) ∧
                                              (∃ hp #t0.
                                                (WrapKey( hp, k2 ) @ #t0)
                                               ∧
                                                (¬(last(#t0))) ∧
                                                (((#t0 = #t2.4) ∨ (#t0 < #t2.4))) ∧
                                                (∀ hpp #t1.
                                                  (Unwrapped( hpp, k2 ) @ #t1)
                                                 ⇒
                                                  ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                             (∃ h k2 #t1 #t0.
                                               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                              ∧
                                               (¬(last(#t0))) ∧
                                               (¬(last(#t1))) ∧
                                               (#t1 < #t2.4) ∧
                                               (#t0 < #t2.4))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.4) ∧
                                               (#t1 < #t2.4))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.4) ∧
                                               (#t1 < #t2.4)) )
                                        case case_1
                                        by contradiction /* from formulas */
                                      next
                                        case case_2
                                        by contradiction /* from formulas */
                                      next
                                        case case_3
                                        by contradiction /* from formulas */
                                      next
                                        case case_4
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case outsdecckeyv_0_11112111111_case_3
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_4
                                      by contradiction /* from formulas */
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_1
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.4 < #t2.11)  ∥ (#t2.4 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.4 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.4 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.26 < #vr.99) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.8, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.26 < #t2) ∧
                                                        (#t2 < #vr.99) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.8, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.99 < #vr.26) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.3, m, v, ~n.8
                                                       ) ▶₀ #t2.5 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.13 ) ▶₀ #t2.5 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.3, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.2, L_h, k.3, k.1, v, lock ) ▶₀ #t2.4 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.96)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.96) ∨ (#t0 < #vr.96))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.96) ∧
                                                       (#t0 < #vr.96))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.96) ∧
                                                       (#t1 < #vr.96))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.96) ∧
                                                       (#t1 < #vr.96)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.2, <~n.9, x>, lock ) ▶₀ #t0.2 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.5 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.5 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.6 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.3, ~n.3
                                                                 ) ▶₀ #t2.6 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.7 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.7 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.4)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.4) ∨ (#t0 < #t2.4))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.4) ∧
                                                 (#t0 < #t2.4))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.4) ∧
                                                 (#t1 < #t2.4))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.4) ∧
                                                 (#t1 < #t2.4)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.4 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.4 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.26 < #vr.110) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.8, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.26 < #t2) ∧
                                                      (#t2 < #vr.110) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.8, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.110 < #vr.26) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.3, m, v, ~n.8
                                                     ) ▶₀ #t2.5 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.13 ) ▶₀ #t2.5 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.3, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.2, L_h, k.3, k.1, v, lock ) ▶₀ #t2.4 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.107)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.107) ∨ (#t0 < #vr.107))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.107) ∧
                                                     (#t0 < #vr.107))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.107) ∧
                                                     (#t1 < #vr.107))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.107) ∧
                                                     (#t1 < #vr.107)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.2, <~n.9, x>, lock ) ▶₀ #t0.2 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.5 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.5 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.6 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.3, ~n.3
                                                               ) ▶₀ #t2.6 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.7 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.7 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_2
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.4 < #t2.11)  ∥ (#t2.4 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.4 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.4 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.26 < #vr.100) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.8, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.26 < #t2) ∧
                                                        (#t2 < #vr.100) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.8, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.100 < #vr.26) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.3, m, v, ~n.8
                                                       ) ▶₀ #t2.5 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.13 ) ▶₀ #t2.5 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.3, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.2, L_h, k.3, k.1, v, lock ) ▶₀ #t2.4 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.97)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.97) ∨ (#t0 < #vr.97))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.97) ∧
                                                       (#t0 < #vr.97))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.97) ∧
                                                       (#t1 < #vr.97))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.97) ∧
                                                       (#t1 < #vr.97)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.2, <~n.9, x>, lock ) ▶₀ #t0.2 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.5 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.5 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.43 < #vr.31) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.43 < #t2) ∧
                                                                  (#t2 < #vr.31) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t0 = #vr.43) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.43) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.31 < #vr.43) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.6 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.3, ~n.3
                                                                 ) ▶₀ #t2.6 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <k, 'init'> ) @ #t2.7 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, k, lock
                                                                     ) ▶₀ #t2.7 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* from formulas */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.4)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.4) ∨ (#t0 < #t2.4))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.4) ∧
                                                 (#t0 < #t2.4))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.4) ∧
                                                 (#t1 < #t2.4))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.4) ∧
                                                 (#t1 < #t2.4)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.4 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.4 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.26 < #vr.111) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.8, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.26 < #t2) ∧
                                                      (#t2 < #vr.111) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.8, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t0 = #vr.26) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.26) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.111 < #vr.26) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.3, m, v, ~n.8
                                                     ) ▶₀ #t2.5 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.13 ) ▶₀ #t2.5 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.3, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.2, L_h, k.3, k.1, v, lock ) ▶₀ #t2.4 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.108)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.108) ∨ (#t0 < #vr.108))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.108) ∧
                                                     (#t0 < #vr.108))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.108) ∧
                                                     (#t1 < #vr.108))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.108) ∧
                                                     (#t1 < #vr.108)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.2, <~n.9, x>, lock ) ▶₀ #t0.2 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.5 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.5 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.43 < #vr.31) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.43 < #t2) ∧
                                                                (#t2 < #vr.31) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t0 = #vr.43) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.43) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.31 < #vr.43) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.6 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.3, ~n.3
                                                               ) ▶₀ #t2.6 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <k, 'init'> ) @ #t2.7 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, k, lock
                                                                   ) ▶₀ #t2.7 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* from formulas */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsencmkeyv_0_111211111
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, k, v, lock ) ▶₀ #t2.2 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.52)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.52) ∨ (#t0 < #vr.52))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.52) ∧ (#t0 < #vr.52))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.52) ∧ (#t1 < #vr.52))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.52) ∧ (#t1 < #vr.52)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsenckeyvkeyv_0_1121111111_case_2
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.25) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.25) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.25 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2.1, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.5 < #t2.6)  ∥ (#t2.5 = #t2.6) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h2, <z, 'wrap'> ) @ #t2.3 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.3 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.4 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.4 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.17 < #vr.50) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.4, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.17 < #t2) ∧
                                        (#t2 < #vr.50) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.4, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.50 < #vr.17) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.4 ) ▶₀ #t2.5 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.5 ) ▶₀ #t2.5 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( Insert( L_h, <k, 'init'> ) @ #t2.6 )
                                      case insertLhkinit_0_111111111111
                                      solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.6 )
                                        case eventNewKeyLhk_0_11111111111
                                        solve( State_11111111111111( ~n, k.1, ~n.8 ) ▶₀ #t2.7 )
                                          case outLh_0_1111111111111
                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                            case insertLhkinit_0_111111111111
                                            solve( State_111111111111( L_h2, z, lock ) ▶₀ #t2.8 )
                                              case eventNewKeyLhk_0_11111111111
                                              by contradiction /* impossible chain */
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, z.1, v, lock ) ▶₀ #t2.4 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, z.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.47)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, z.1 ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.47) ∨ (#t0 < #vr.47))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, z.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.47) ∧ (#t0 < #vr.47))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.47) ∧ (#t1 < #vr.47))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.47) ∧ (#t1 < #vr.47)) )
                                case case_1
                                by contradiction /* from formulas */
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, z, v, lock ) ▶₀ #t2.3 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, z ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.35)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, z ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.35) ∨ (#t0 < #vr.35))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, z ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.35) ∧ (#t0 < #vr.35))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.35) ∧ (#t1 < #vr.35))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.35) ∧ (#t1 < #vr.35)) )
                            case case_1
                            solve( State_11111111111( h1, z, lock ) ▶₀ #t1 )
                              case newk_0_1111111111
                              by contradiction /* impossible chain */
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.22)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.22) ∨ (#t0 < #vr.22))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.22) ∧ (#t0 < #vr.22))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.22) ∧ (#t1 < #vr.22))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.22) ∧ (#t1 < #vr.22)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h2, <z, 'wrap'> ) @ #t2.2 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.3 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.17 < #vr.68) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.10, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.17 < #t2) ∧
                                        (#t2 < #vr.68) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.10, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.68 < #vr.17) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.10 ) ▶₀ #t2.4 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.9 ) ▶₀ #t2.4 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( !KU( senc(~n, k.1) ) @ #vk.11 )
                                      case c_senc
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_1
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_2
                                      solve( ((∃ h1 #t1.
                                                (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                              (∃ hp #t0.
                                                (WrapKey( hp, k2 ) @ #t0)
                                               ∧
                                                (¬(last(#t0))) ∧
                                                (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                (∀ hpp #t1.
                                                  (Unwrapped( hpp, k2 ) @ #t1)
                                                 ⇒
                                                  ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                             (∃ h k2 #t1 #t0.
                                               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                              ∧
                                               (¬(last(#t0))) ∧
                                               (¬(last(#t1))) ∧
                                               (#t1 < #t2.5) ∧
                                               (#t0 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5)) )
                                        case case_1
                                        by contradiction /* from formulas */
                                      next
                                        case case_2
                                        by contradiction /* from formulas */
                                      next
                                        case case_3
                                        by contradiction /* from formulas */
                                      next
                                        case case_4
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case outsdecckeyv_0_11112111111_case_3
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_4
                                      by contradiction /* from formulas */
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_1
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.27 < #vr.93) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.27 < #t2) ∧
                                                        (#t2 < #vr.93) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.93 < #vr.27) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.90)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.90) ∨ (#t0 < #vr.90))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.90) ∧
                                                       (#t0 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.27 < #vr.104) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.27 < #t2) ∧
                                                      (#t2 < #vr.104) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.104 < #vr.27) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.101)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.101) ∨ (#t0 < #vr.101))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.101) ∧
                                                     (#t0 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_2
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.27 < #vr.94) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.27 < #t2) ∧
                                                        (#t2 < #vr.94) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.94 < #vr.27) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.91)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.91) ∨ (#t0 < #vr.91))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.91) ∧
                                                       (#t0 < #vr.91))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.91) ∧
                                                       (#t1 < #vr.91))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.91) ∧
                                                       (#t1 < #vr.91)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.27 < #vr.105) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.27 < #t2) ∧
                                                      (#t2 < #vr.105) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.105 < #vr.27) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.102)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.102) ∨ (#t0 < #vr.102))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.102) ∧
                                                     (#t0 < #vr.102))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.102) ∧
                                                     (#t1 < #vr.102))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.102) ∧
                                                     (#t1 < #vr.102)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsencmkeyv_0_111211111
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, z.1, v, lock ) ▶₀ #t2.3 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, z.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.65)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, z.1 ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.65) ∨ (#t0 < #vr.65))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, z.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.65) ∧ (#t0 < #vr.65))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.65) ∧ (#t1 < #vr.65))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.65) ∧ (#t1 < #vr.65)) )
                                case case_1
                                by contradiction /* from formulas */
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, z, v, lock ) ▶₀ #t2.2 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, z ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.53)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, z ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.53) ∨ (#t0 < #vr.53))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, z ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.53) ∧ (#t0 < #vr.53))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.53) ∧ (#t1 < #vr.53))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.53) ∧ (#t1 < #vr.53)) )
                            case case_1
                            solve( State_11111111111( h1, z, lock ) ▶₀ #t1.1 )
                              case newk_0_1111111111
                              by contradiction /* impossible chain */
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsencmkeyv_0_111211111
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.23) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.23) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.23 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h.1, <k, 'dec'> ) @ #t2.3 )
                        case insertLhkeyvdec_0_11111211111
                        solve( State_11111211111( L_h.1, v, lock ) ▶₀ #t2.3 )
                          case eventDecKeyLhkeyv_0_1111121111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.20)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.20) ∨ (#t0 < #vr.20))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.20) ∧ (#t0 < #vr.20))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.20) ∧ (#t1 < #vr.20))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.20) ∧ (#t1 < #vr.20)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h.1, <~n, 'dec'> ) @ #t2.2 )
                        case insertLhkeyvdec_0_11111211111
                        solve( State_11111211111( L_h.1, <~n, x>, lock ) ▶₀ #t2.2 )
                          case eventDecKeyLhkeyv_0_1111121111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        by contradiction /* from formulas */
      next
        case case_4
        by contradiction /* from formulas */
      next
        case case_5
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (#t1 = #t2.1)  ∥ (#t2.1 < #t1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_3
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_5
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_6
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_3( '3', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_7
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_4( '4', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_8
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_5( '5', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_9
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_6( '6', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( (∀ h2 k #t2.
             (Unwrapped( h2, k ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2)) ∧
               (∃ hp #t0.
                 (WrapKey( hp, k ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                 (∀ hpp #t1.
                   (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1))))) ∨
              (∃ h k2 #t1 #t0.
                (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
               ∧
                (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2) ∧ (#t0 < #t2)) ∨
              (∃ #t0 #t1 h1 h2.1 k.1.
                (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
               ∧
                (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2)) ∨
              (∃ #t0 #t1 h1 h2.1 k.1.
                (Unwrapped( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
               ∧
                (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2))))  ∥
           (∃ x y #t3.
             (IsIn( x, y ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (∀ #t2.
               (Insert( x, y ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t1 yp.
                  (Insert( x, yp ) @ #t1)
                 ∧
                  (¬(last(#t1))) ∧
                  (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                  (¬(#t1 = #t2)) ∧
                  (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_0( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_1( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_2( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_3( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_4( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_5( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_6( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3))) )
      case case_1
      solve( (last(#t2))  ∥
             ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2)) ∧
              (∃ hp #t0.
                (WrapKey( hp, k.1 ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                (∀ hpp #t1.
                  (Unwrapped( hpp, k.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2) ∧ (#t0 < #t2))  ∥
             (∃ #t0 #t1 h1 h2 k.
               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
              ∧
               (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2))  ∥
             (∃ #t0 #t1 h1 h2 k.
               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
              ∧
               (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2) ∧ (#t1 < #t2)) )
        case case_1
        solve( State_12111111( L_h, h2, k, k.1, v, lock ) ▶₀ #t2 )
          case newLh_0_1211111
          solve( !KU( senc(k.1, k) ) @ #vk.2 )
            case c_senc
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.13) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.13) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.13 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h, <k, 'init'> ) @ #t2.3 )
                        case insertLhkinit_0_111111111111
                        solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.3 )
                          case eventNewKeyLhk_0_11111111111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.10)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.10) ∨ (#t0 < #vr.10))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.10) ∧ (#t0 < #vr.10))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.10) ∧ (#t1 < #vr.10))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.10) ∧ (#t1 < #vr.10)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsdecckeyv_0_11112111111_case_1
            by contradiction /* from formulas */
          next
            case outsdecckeyv_0_11112111111_case_2
            solve( ((∃ h1 #t1.
                      (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.1)) ∧
                    (∃ hp #t0.
                      (WrapKey( hp, k2 ) @ #t0)
                     ∧
                      (¬(last(#t0))) ∧
                      (((#t0 = #t2.1) ∨ (#t0 < #t2.1))) ∧
                      (∀ hpp #t1.
                        (Unwrapped( hpp, k2 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                   (∃ h k2 #t1 #t0.
                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                    ∧
                     (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.1) ∧ (#t0 < #t2.1))  ∥
                   (∃ #t0 #t1 h1 h2 k.
                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2.1) ∧ (#t1 < #t2.1))  ∥
                   (∃ #t0 #t1 h1 h2 k.
                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t2.1) ∧ (#t1 < #t2.1)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            next
              case case_4
              by contradiction /* from formulas */
            qed
          next
            case outsdecckeyv_0_11112111111_case_3
            by contradiction /* from formulas */
          next
            case outsdecckeyv_0_11112111111_case_4
            by contradiction /* from formulas */
          next
            case outsenckeyvkeyv_0_1121111111_case_1
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.24) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.24) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.24 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2.1, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.5 < #t2.6)  ∥ (#t2.5 = #t2.6) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h2, <k.1, 'wrap'> ) @ #t2.3 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.3 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( ((∃ h1 #t1.1.
                                    (NewKey( h1, k.1 ) @ #t1.1) ∧ (¬(last(#t1.1))) ∧ (#t1.1 < #t1)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k.1 ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #t1) ∨ (#t0 < #t1))) ∧
                                    (∀ hpp #t1.1.
                                      (Unwrapped( hpp, k.1 ) @ #t1.1) ⇒ ((last(#t1.1)) ∨ (#t0 < #t1.1)))))  ∥
                                 (∃ h k2 #t1.1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1.1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1.1))) ∧ (#t1.1 < #t1) ∧ (#t0 < #t1))  ∥
                                 (∃ #t0 #t1.1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1.1)
                                  ∧
                                   (¬(last(#t1.1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t1) ∧ (#t1.1 < #t1))  ∥
                                 (∃ #t0 #t1.1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1.1)
                                  ∧
                                   (¬(last(#t1.1))) ∧ (¬(last(#t0))) ∧ (#t0 < #t1) ∧ (#t1.1 < #t1)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, k.1, v, lock ) ▶₀ #t2.3 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, k.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.34)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k.1 ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.34) ∨ (#t0 < #vr.34))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, k.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.34) ∧ (#t0 < #vr.34))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.34) ∧ (#t1 < #vr.34))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.34) ∧ (#t1 < #vr.34)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.21)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.21) ∨ (#t0 < #vr.21))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.21) ∧ (#t0 < #vr.21))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.21) ∧ (#t1 < #vr.21))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.21) ∧ (#t1 < #vr.21)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h2, <k, 'wrap'> ) @ #t2.2 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( ((∃ h1 #t1.2.
                                    (NewKey( h1, k ) @ #t1.2) ∧ (¬(last(#t1.2))) ∧ (#t1.2 < #t1.1)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #t1.1) ∨ (#t0 < #t1.1))) ∧
                                    (∀ hpp #t1.2.
                                      (Unwrapped( hpp, k ) @ #t1.2) ⇒ ((last(#t1.2)) ∨ (#t0 < #t1.2)))))  ∥
                                 (∃ h k2 #t1.2 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1.2)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1.2))) ∧ (#t1.2 < #t1.1) ∧ (#t0 < #t1.1))  ∥
                                 (∃ #t0 #t1.2 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1.2)
                                  ∧
                                   (¬(last(#t1.2))) ∧ (¬(last(#t0))) ∧ (#t0 < #t1.1) ∧ (#t1.2 < #t1.1))  ∥
                                 (∃ #t0 #t1.2 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1.2)
                                  ∧
                                   (¬(last(#t1.2))) ∧ (¬(last(#t0))) ∧ (#t0 < #t1.1) ∧ (#t1.2 < #t1.1)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, k, v, lock ) ▶₀ #t2.2 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.52)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, k ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.52) ∨ (#t0 < #vr.52))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.52) ∧ (#t0 < #vr.52))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.52) ∧ (#t1 < #vr.52))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.52) ∧ (#t1 < #vr.52)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsenckeyvkeyv_0_1121111111_case_2
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.25) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.25) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.25 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2.1, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.5 < #t2.6)  ∥ (#t2.5 = #t2.6) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h2, <z, 'wrap'> ) @ #t2.3 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.3 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.4 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.4 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.17 < #vr.50) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.4, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.17 < #t2) ∧
                                        (#t2 < #vr.50) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.4, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.50 < #vr.17) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.4 ) ▶₀ #t2.5 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.5 ) ▶₀ #t2.5 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( Insert( L_h, <k, 'init'> ) @ #t2.6 )
                                      case insertLhkinit_0_111111111111
                                      solve( State_111111111111( L_h, k, lock ) ▶₀ #t2.6 )
                                        case eventNewKeyLhk_0_11111111111
                                        solve( State_11111111111111( ~n, k.1, ~n.8 ) ▶₀ #t2.7 )
                                          case outLh_0_1111111111111
                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                            case insertLhkinit_0_111111111111
                                            solve( State_111111111111( L_h2, z, lock ) ▶₀ #t2.8 )
                                              case eventNewKeyLhk_0_11111111111
                                              by contradiction /* impossible chain */
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, z.1, v, lock ) ▶₀ #t2.4 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, z.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.47)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, z.1 ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.47) ∨ (#t0 < #vr.47))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, z.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.47) ∧ (#t0 < #vr.47))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.47) ∧ (#t1 < #vr.47))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.47) ∧ (#t1 < #vr.47)) )
                                case case_1
                                by contradiction /* from formulas */
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, z, v, lock ) ▶₀ #t2.3 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, z ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.35)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, z ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.35) ∨ (#t0 < #vr.35))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, z ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.35) ∧ (#t0 < #vr.35))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.35) ∧ (#t1 < #vr.35))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.35) ∧ (#t1 < #vr.35)) )
                            case case_1
                            solve( State_11111111111( h1, z, lock ) ▶₀ #t1 )
                              case newk_0_1111111111
                              by contradiction /* impossible chain */
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.22)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.22) ∨ (#t0 < #vr.22))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.22) ∧ (#t0 < #vr.22))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.22) ∧ (#t1 < #vr.22))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.22) ∧ (#t1 < #vr.22)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h2, <z, 'wrap'> ) @ #t2.2 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2.2 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.3 )
                            case insertLhkeyvwrap_0_111111211111
                            solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.3 )
                              case eventWrapKeyLhkeyv_0_11111121111
                              solve( ((#vr.17 < #vr.68) ∧
                                      (∃ #t2.
                                        (Unlock_5( '5', ~n.10, L_h1 ) @ #t2)
                                       ∧
                                        (#vr.17 < #t2) ∧
                                        (#t2 < #vr.68) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.10, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t0 = #vr.17) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, L_h1 ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.17) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.68 < #vr.17) )
                                case case_1
                                solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.10 ) ▶₀ #t2.4 )
                                  case outsenckeyvkeyv_0_1121111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111121111111( L_h1, v, ~n.9 ) ▶₀ #t2.4 )
                                  case eventWrapHandleLh_0_1111112111111
                                  solve( (#t2.8 < #t2.9)  ∥ (#t2.8 = #t2.9) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    solve( !KU( senc(~n, k.1) ) @ #vk.11 )
                                      case c_senc
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_1
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_2
                                      solve( ((∃ h1 #t1.
                                                (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                              (∃ hp #t0.
                                                (WrapKey( hp, k2 ) @ #t0)
                                               ∧
                                                (¬(last(#t0))) ∧
                                                (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                (∀ hpp #t1.
                                                  (Unwrapped( hpp, k2 ) @ #t1)
                                                 ⇒
                                                  ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                             (∃ h k2 #t1 #t0.
                                               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                              ∧
                                               (¬(last(#t0))) ∧
                                               (¬(last(#t1))) ∧
                                               (#t1 < #t2.5) ∧
                                               (#t0 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5))  ∥
                                             (∃ #t0 #t1 h1 h2 k.
                                               (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                              ∧
                                               (¬(last(#t1))) ∧
                                               (¬(last(#t0))) ∧
                                               (#t0 < #t2.5) ∧
                                               (#t1 < #t2.5)) )
                                        case case_1
                                        by contradiction /* from formulas */
                                      next
                                        case case_2
                                        by contradiction /* from formulas */
                                      next
                                        case case_3
                                        by contradiction /* from formulas */
                                      next
                                        case case_4
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case outsdecckeyv_0_11112111111_case_3
                                      by contradiction /* from formulas */
                                    next
                                      case outsdecckeyv_0_11112111111_case_4
                                      by contradiction /* from formulas */
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_1
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.27 < #vr.93) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.27 < #t2) ∧
                                                        (#t2 < #vr.93) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.93 < #vr.27) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.90)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.90) ∨ (#t0 < #vr.90))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.90) ∧
                                                       (#t0 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.90) ∧
                                                       (#t1 < #vr.90)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.27 < #vr.104) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.27 < #t2) ∧
                                                      (#t2 < #vr.104) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.104 < #vr.27) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.101)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.101) ∨ (#t0 < #vr.101))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.101) ∧
                                                     (#t0 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.101) ∧
                                                     (#t1 < #vr.101)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsenckeyvkeyv_0_1121111111_case_2
                                      solve( !KU( ~n.4 ) @ #vk.3 )
                                        case outLh_0_1211111111
                                        solve( (#t2.5 < #t2.11)  ∥ (#t2.5 = #t2.11) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                            case insertLhkeyvwrap_0_111111211111
                                            solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                              case eventWrapKeyLhkeyv_0_11111121111
                                              solve( ((#vr.27 < #vr.94) ∧
                                                      (∃ #t2.
                                                        (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                       ∧
                                                        (#vr.27 < #t2) ∧
                                                        (#t2 < #vr.94) ∧
                                                        (∀ #t0 pp.
                                                          (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                        (∀ pp lpp #t0.
                                                          (Lock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                        (∀ pp lpp #t0.
                                                          (Unlock( pp, lpp, L_h ) @ #t0)
                                                         ⇒
                                                          ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                     (#vr.94 < #vr.27) )
                                                case case_1
                                                solve( State_12111111111( L_h, L_h2.2, k.2, m, v, ~n.7
                                                       ) ▶₀ #t2.6 )
                                                  case outLh_0_1211111111
                                                  by contradiction /* cyclic */
                                                qed
                                              next
                                                case case_2
                                                solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                  case eventWrapHandleLh_0_1111112111111
                                                  solve( (#t2.12 < #t2.13)  ∥ (#t2.12 = #t2.13) )
                                                    case case_1
                                                    by contradiction /* from formulas */
                                                  next
                                                    case case_2
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.8 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.8 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.9 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case insertLhmwrap_0_121111111
                                            solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                              case eventUnwrappedLhm_0_12111111
                                              solve( ((∃ h1 #t1.
                                                        (NewKey( h1, k.1 ) @ #t1)
                                                       ∧
                                                        (¬(last(#t1))) ∧ (#t1 < #vr.91)) ∧
                                                      (∃ hp #t0.
                                                        (WrapKey( hp, k.1 ) @ #t0)
                                                       ∧
                                                        (¬(last(#t0))) ∧
                                                        (((#t0 = #vr.91) ∨ (#t0 < #vr.91))) ∧
                                                        (∀ hpp #t1.
                                                          (Unwrapped( hpp, k.1 ) @ #t1)
                                                         ⇒
                                                          ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                     (∃ h k2 #t1 #t0.
                                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                      ∧
                                                       (¬(last(#t0))) ∧
                                                       (¬(last(#t1))) ∧
                                                       (#t1 < #vr.91) ∧
                                                       (#t0 < #vr.91))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.91) ∧
                                                       (#t1 < #vr.91))  ∥
                                                     (∃ #t0 #t1 h1 h2 k.
                                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                      ∧
                                                       (¬(last(#t1))) ∧
                                                       (¬(last(#t0))) ∧
                                                       (#t0 < #vr.91) ∧
                                                       (#t1 < #vr.91)) )
                                                case case_1
                                                solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                  case newk_0_1111111111
                                                  solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                    case ifattvinit_0_1111112111
                                                    solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                      case insertLhkinit_0_111111111111
                                                      solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                        case eventNewKeyLhk_0_11111111111
                                                        solve( ((#vr.44 < #vr.32) ∧
                                                                (∃ #t2.
                                                                  (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                                 ∧
                                                                  (#vr.44 < #t2) ∧
                                                                  (#t2 < #vr.32) ∧
                                                                  (∀ #t0 pp.
                                                                    (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                   ⇒
                                                                    #t0 = #t2) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Lock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t0 = #vr.44) ∨
                                                                     (#t2 < #t0))) ∧
                                                                  (∀ pp lpp #t0.
                                                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                                                   ⇒
                                                                    ((#t0 < #vr.44) ∨
                                                                     (#t2 < #t0) ∨
                                                                     (#t2 = #t0)))))  ∥
                                                               (#vr.32 < #vr.44) )
                                                          case case_1
                                                          solve( State_11111121111111( ~n, v, ~n.2
                                                                 ) ▶₀ #t2.7 )
                                                            case eventWrapHandleLh_0_1111112111111
                                                            by contradiction /* cyclic */
                                                          qed
                                                        next
                                                          case case_2
                                                          solve( State_11111111111111( ~n, k.2, ~n.3
                                                                 ) ▶₀ #t2.7 )
                                                            case outLh_0_1111111111111
                                                            solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                              case insertLhkinit_0_111111111111
                                                              solve( State_111111111111( L_h2, z, lock
                                                                     ) ▶₀ #t2.8 )
                                                                case eventNewKeyLhk_0_11111111111
                                                                by contradiction /* impossible chain */
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              next
                                                case case_2
                                                by contradiction /* from formulas */
                                              next
                                                case case_3
                                                by contradiction /* from formulas */
                                              next
                                                case case_4
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_1
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_2
                                        solve( ((∃ h1 #t1.
                                                  (NewKey( h1, k2 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2.5)) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k2 ) @ #t0)
                                                 ∧
                                                  (¬(last(#t0))) ∧
                                                  (((#t0 = #t2.5) ∨ (#t0 < #t2.5))) ∧
                                                  (∀ hpp #t1.
                                                    (Unwrapped( hpp, k2 ) @ #t1)
                                                   ⇒
                                                    ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (¬(last(#t0))) ∧
                                                 (¬(last(#t1))) ∧
                                                 (#t1 < #t2.5) ∧
                                                 (#t0 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (¬(last(#t1))) ∧
                                                 (¬(last(#t0))) ∧
                                                 (#t0 < #t2.5) ∧
                                                 (#t1 < #t2.5)) )
                                          case case_1
                                          by contradiction /* from formulas */
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      next
                                        case outsdecckeyv_0_11112111111_case_3
                                        by contradiction /* from formulas */
                                      next
                                        case outsdecckeyv_0_11112111111_case_4
                                        by contradiction /* from formulas */
                                      next
                                        case outsenckeyvkeyv_0_1121111111
                                        solve( Insert( L_h, <k.1, 'wrap'> ) @ #t2.5 )
                                          case insertLhkeyvwrap_0_111111211111
                                          solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.5 )
                                            case eventWrapKeyLhkeyv_0_11111121111
                                            solve( ((#vr.27 < #vr.105) ∧
                                                    (∃ #t2.
                                                      (Unlock_6( '6', ~n.7, L_h ) @ #t2)
                                                     ∧
                                                      (#vr.27 < #t2) ∧
                                                      (#t2 < #vr.105) ∧
                                                      (∀ #t0 pp.
                                                        (Unlock( pp, ~n.7, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                      (∀ pp lpp #t0.
                                                        (Lock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t0 = #vr.27) ∨ (#t2 < #t0))) ∧
                                                      (∀ pp lpp #t0.
                                                        (Unlock( pp, lpp, L_h ) @ #t0)
                                                       ⇒
                                                        ((#t0 < #vr.27) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                   (#vr.105 < #vr.27) )
                                              case case_1
                                              solve( State_12111111111( L_h, L_h2.3, k.2, m, v, ~n.7
                                                     ) ▶₀ #t2.6 )
                                                case outLh_0_1211111111
                                                by contradiction /* cyclic */
                                              qed
                                            next
                                              case case_2
                                              solve( State_11111121111111( L_h, v, ~n.11 ) ▶₀ #t2.6 )
                                                case eventWrapHandleLh_0_1111112111111
                                                solve( (#t2.14 < #t2.15)  ∥ (#t2.14 = #t2.15) )
                                                  case case_1
                                                  by contradiction /* from formulas */
                                                next
                                                  case case_2
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.7 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.7 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.8 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.8 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.9 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.9 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case insertLhmwrap_0_121111111
                                          solve( State_121111111( L_h.1, L_h, k.2, k.1, v, lock ) ▶₀ #t2.5 )
                                            case eventUnwrappedLhm_0_12111111
                                            solve( ((∃ h1 #t1.
                                                      (NewKey( h1, k.1 ) @ #t1)
                                                     ∧
                                                      (¬(last(#t1))) ∧ (#t1 < #vr.102)) ∧
                                                    (∃ hp #t0.
                                                      (WrapKey( hp, k.1 ) @ #t0)
                                                     ∧
                                                      (¬(last(#t0))) ∧
                                                      (((#t0 = #vr.102) ∨ (#t0 < #vr.102))) ∧
                                                      (∀ hpp #t1.
                                                        (Unwrapped( hpp, k.1 ) @ #t1)
                                                       ⇒
                                                        ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                                   (∃ h k2 #t1 #t0.
                                                     (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                    ∧
                                                     (¬(last(#t0))) ∧
                                                     (¬(last(#t1))) ∧
                                                     (#t1 < #vr.102) ∧
                                                     (#t0 < #vr.102))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.102) ∧
                                                     (#t1 < #vr.102))  ∥
                                                   (∃ #t0 #t1 h1 h2 k.
                                                     (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                    ∧
                                                     (¬(last(#t1))) ∧
                                                     (¬(last(#t0))) ∧
                                                     (#t0 < #vr.102) ∧
                                                     (#t1 < #vr.102)) )
                                              case case_1
                                              solve( State_11111111111( h1, k.1, lock ) ▶₀ #t1.1 )
                                                case newk_0_1111111111
                                                solve( State_11111121111( hp.1, <~n.7, x>, lock ) ▶₀ #t0.1 )
                                                  case ifattvinit_0_1111112111
                                                  solve( Insert( hp, <~n, 'init'> ) @ #t2.6 )
                                                    case insertLhkinit_0_111111111111
                                                    solve( State_111111111111( hp, ~n, lock ) ▶₀ #t2.6 )
                                                      case eventNewKeyLhk_0_11111111111
                                                      solve( ((#vr.44 < #vr.32) ∧
                                                              (∃ #t2.
                                                                (Unlock_1( '1', ~n.2, ~n ) @ #t2)
                                                               ∧
                                                                (#vr.44 < #t2) ∧
                                                                (#t2 < #vr.32) ∧
                                                                (∀ #t0 pp.
                                                                  (Unlock( pp, ~n.2, ~n ) @ #t0)
                                                                 ⇒
                                                                  #t0 = #t2) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Lock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t0 = #vr.44) ∨
                                                                   (#t2 < #t0))) ∧
                                                                (∀ pp lpp #t0.
                                                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                                                 ⇒
                                                                  ((#t0 < #vr.44) ∨
                                                                   (#t2 < #t0) ∨
                                                                   (#t2 = #t0)))))  ∥
                                                             (#vr.32 < #vr.44) )
                                                        case case_1
                                                        solve( State_11111121111111( ~n, v, ~n.2 ) ▶₀ #t2.7 )
                                                          case eventWrapHandleLh_0_1111112111111
                                                          by contradiction /* cyclic */
                                                        qed
                                                      next
                                                        case case_2
                                                        solve( State_11111111111111( ~n, k.2, ~n.3
                                                               ) ▶₀ #t2.7 )
                                                          case outLh_0_1111111111111
                                                          solve( Insert( L_h2, <z, 'init'> ) @ #t2.8 )
                                                            case insertLhkinit_0_111111111111
                                                            solve( State_111111111111( L_h2, z, lock
                                                                   ) ▶₀ #t2.8 )
                                                              case eventNewKeyLhk_0_11111111111
                                                              by contradiction /* impossible chain */
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            next
                                              case case_2
                                              by contradiction /* from formulas */
                                            next
                                              case case_3
                                              by contradiction /* from formulas */
                                            next
                                              case case_4
                                              by contradiction /* from formulas */
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case outsencmkeyv_0_111211111
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          next
                            case insertLhmwrap_0_121111111
                            solve( State_121111111( L_h.1, L_h1, k.2, z.1, v, lock ) ▶₀ #t2.3 )
                              case eventUnwrappedLhm_0_12111111
                              solve( ((∃ h1 #t1.
                                        (NewKey( h1, z.1 ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.65)) ∧
                                      (∃ hp #t0.
                                        (WrapKey( hp, z.1 ) @ #t0)
                                       ∧
                                        (¬(last(#t0))) ∧
                                        (((#t0 = #vr.65) ∨ (#t0 < #vr.65))) ∧
                                        (∀ hpp #t1.
                                          (Unwrapped( hpp, z.1 ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                     (∃ h k2 #t1 #t0.
                                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                      ∧
                                       (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.65) ∧ (#t0 < #vr.65))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.65) ∧ (#t1 < #vr.65))  ∥
                                     (∃ #t0 #t1 h1 h2 k.
                                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                      ∧
                                       (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.65) ∧ (#t1 < #vr.65)) )
                                case case_1
                                by contradiction /* from formulas */
                              next
                                case case_2
                                by contradiction /* from formulas */
                              next
                                case case_3
                                by contradiction /* from formulas */
                              next
                                case case_4
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h2, k.2, z, v, lock ) ▶₀ #t2.2 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1.
                                    (NewKey( h1, z ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.53)) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, z ) @ #t0)
                                   ∧
                                    (¬(last(#t0))) ∧
                                    (((#t0 = #vr.53) ∨ (#t0 < #vr.53))) ∧
                                    (∀ hpp #t1.
                                      (Unwrapped( hpp, z ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.53) ∧ (#t0 < #vr.53))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.53) ∧ (#t1 < #vr.53))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.53) ∧ (#t1 < #vr.53)) )
                            case case_1
                            solve( State_11111111111( h1, z, lock ) ▶₀ #t1.1 )
                              case newk_0_1111111111
                              by contradiction /* impossible chain */
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case outsencmkeyv_0_111211111
            solve( Insert( L_h, <k, 'wrap'> ) @ #t2.1 )
              case insertLhkeyvwrap_0_111111211111
              solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.1 )
                case eventWrapKeyLhkeyv_0_11111121111
                solve( ((#vr.4 < #vr.23) ∧
                        (∃ #t2.
                          (Unlock_6( '6', ~n.1, L_h ) @ #t2)
                         ∧
                          (#vr.4 < #t2) ∧
                          (#t2 < #vr.23) ∧
                          (∀ #t0 pp. (Unlock( pp, ~n.1, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ pp lpp #t0.
                            (Lock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t0 = #vr.4) ∨ (#t2 < #t0))) ∧
                          (∀ pp lpp #t0.
                            (Unlock( pp, lpp, L_h ) @ #t0)
                           ⇒
                            ((#t0 < #vr.4) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                       (#vr.23 < #vr.4) )
                  case case_1
                  solve( State_12111111111( L_h, L_h2, k.2, m, v, ~n.1 ) ▶₀ #t2.2 )
                    case outLh_0_1211111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_11111121111111( L_h, v, ~n.2 ) ▶₀ #t2.2 )
                    case eventWrapHandleLh_0_1111112111111
                    solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      solve( Insert( L_h.1, <k, 'dec'> ) @ #t2.3 )
                        case insertLhkeyvdec_0_11111211111
                        solve( State_11111211111( L_h.1, v, lock ) ▶₀ #t2.3 )
                          case eventDecKeyLhkeyv_0_1111121111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case insertLhmwrap_0_121111111
              solve( State_121111111( L_h.1, L_h, k.2, k, v, lock ) ▶₀ #t2.1 )
                case eventUnwrappedLhm_0_12111111
                solve( ((∃ h1 #t1.
                          (NewKey( h1, k ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.20)) ∧
                        (∃ hp #t0.
                          (WrapKey( hp, k ) @ #t0)
                         ∧
                          (¬(last(#t0))) ∧
                          (((#t0 = #vr.20) ∨ (#t0 < #vr.20))) ∧
                          (∀ hpp #t1.
                            (Unwrapped( hpp, k ) @ #t1) ⇒ ((last(#t1)) ∨ (#t0 < #t1)))))  ∥
                       (∃ h k2 #t1 #t0.
                         (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #vr.20) ∧ (#t0 < #vr.20))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.20) ∧ (#t1 < #vr.20))  ∥
                       (∃ #t0 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (¬(last(#t1))) ∧ (¬(last(#t0))) ∧ (#t0 < #vr.20) ∧ (#t1 < #vr.20)) )
                  case case_1
                  solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                    case newk_0_1111111111
                    solve( State_11111121111( hp, <~n, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h.1, <~n, 'dec'> ) @ #t2.2 )
                        case insertLhkeyvdec_0_11111211111
                        solve( State_11111211111( L_h.1, <~n, x>, lock ) ▶₀ #t2.2 )
                          case eventDecKeyLhkeyv_0_1111121111
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                next
                  case case_4
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        by contradiction /* from formulas */
      next
        case case_4
        by contradiction /* from formulas */
      next
        case case_5
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (#t1 = #t2.1)  ∥ (#t2.1 < #t1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_3
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_5
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_6
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_3( '3', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_7
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_4( '4', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_8
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_5( '5', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_9
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_6( '6', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, x ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                   (¬(#t2.1 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma no_key_is_wrap_and_dec_ind [use_induction, reuse]:
  all-traces
  "∀ #t2 #t3 h1 h2 k.
    ((DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)) ⇒
    (∃ h k2 #t1 #t0.
      ((NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧
      (((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))"
/*
guarded formula characterizing all counter-examples:
"∃ #t2 #t3 h1 h2 k.
  (DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)
 ∧
  ∀ h k2 #t1 #t0.
   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
  ⇒
   (((¬(#t1 < #t3)) ∨ (¬(#t0 < #t3)))) ∧
   (((¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #t2 #t3 h1 h2 k.
           (DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)
          ⇒
           ((last(#t3)) ∨
            (last(#t2)) ∨
            (∃ h k2 #t1 #t0.
              (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
             ∧
              (¬(last(#t0))) ∧
              (¬(last(#t1))) ∧
              ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2)))))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_3( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_4( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_5( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_6( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#t3))  ∥ (last(#t2))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (¬(last(#t0))) ∧
             (¬(last(#t1))) ∧
             ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))) )
      case case_1
      solve( State_1111121111( h1, v, lock ) ▶₀ #t2 )
        case ifattvinit_0_111112111
        solve( State_11111121111( h2, v, lock ) ▶₀ #t3 )
          case ifattvinit_0_1111112111
          solve( Insert( h1, <k, 'init'> ) @ #t2.1 )
            case insertLhkinit_0_111111111111
            solve( State_111111111111( h1, k, lock ) ▶₀ #t2.1 )
              case eventNewKeyLhk_0_11111111111
              solve( ((#vr.2 < #vr.25) ∧
                      (∃ #t2.
                        (Unlock_2( '2', ~n.2, ~n ) @ #t2)
                       ∧
                        (#vr.2 < #t2) ∧
                        (#t2 < #vr.25) ∧
                        (∀ #t0 pp. (Unlock( pp, ~n.2, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                        (∀ pp lpp #t0.
                          (Lock( pp, lpp, ~n ) @ #t0)
                         ⇒
                          ((#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0))) ∧
                        (∀ pp lpp #t0.
                          (Unlock( pp, lpp, ~n ) @ #t0)
                         ⇒
                          ((#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                     (#vr.25 < #vr.2) )
                case case_1
                solve( State_111112111111( ~n, v, ~n.2 ) ▶₀ #t2.2 )
                  case insertLhkeyvdec_0_11111211111
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( State_11111111111111( ~n, k, ~n.4 ) ▶₀ #t2.2 )
                  case outLh_0_1111111111111
                  solve( Insert( h2, <~n.1, 'init'> ) @ #t2.3 )
                    case insertLhkinit_0_111111111111
                    solve( State_111111111111( h2, ~n.1, lock ) ▶₀ #t2.3 )
                      case eventNewKeyLhk_0_11111111111
                      solve( ((#vr.14 < #vr.25) ∧
                              (∃ #t2.
                                (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                               ∧
                                (#vr.14 < #t2) ∧
                                (#t2 < #vr.25) ∧
                                (∀ #t0 pp. (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                (∀ pp lpp #t0.
                                  (Lock( pp, lpp, ~n ) @ #t0)
                                 ⇒
                                  ((#t0 < #vr.14) ∨ (#t0 = #vr.14) ∨ (#t2 < #t0))) ∧
                                (∀ pp lpp #t0.
                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                 ⇒
                                  ((#t0 < #vr.14) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                             (#vr.25 < #vr.14) )
                        case case_1
                        solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.3 )
                          case eventWrapHandleLh_0_1111112111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( ((#vr.2 < #vr.14) ∧
                                (∃ #t2.
                                  (Unlock_2( '2', ~n.2, ~n ) @ #t2)
                                 ∧
                                  (#vr.2 < #t2) ∧
                                  (#t2 < #vr.14) ∧
                                  (∀ #t0 pp. (Unlock( pp, ~n.2, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                  (∀ pp lpp #t0.
                                    (Lock( pp, lpp, ~n ) @ #t0)
                                   ⇒
                                    ((#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0))) ∧
                                  (∀ pp lpp #t0.
                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                   ⇒
                                    ((#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                               (#vr.14 < #vr.2) )
                          case case_1
                          solve( State_111112111111( ~n, v, ~n.2 ) ▶₀ #t2.3 )
                            case insertLhkeyvdec_0_11111211111
                            by contradiction /* from formulas */
                          qed
                        next
                          case case_2
                          solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.3 )
                            case eventWrapHandleLh_0_1111112111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case case_2
      solve( State_1111121111( h1, v, lock ) ▶₀ #t2 )
        case ifattvinit_0_111112111
        solve( State_11111121111( h2, v, lock ) ▶₀ #t3 )
          case ifattvinit_0_1111112111
          solve( Insert( h1, <k, 'init'> ) @ #t2.1 )
            case insertLhkinit_0_111111111111
            solve( State_111111111111( h1, k, lock ) ▶₀ #t2.1 )
              case eventNewKeyLhk_0_11111111111
              solve( ((#vr.2 < #vr.25) ∧
                      (∃ #t2.
                        (Unlock_2( '2', ~n.2, ~n ) @ #t2)
                       ∧
                        (#vr.2 < #t2) ∧
                        (#t2 < #vr.25) ∧
                        (∀ #t0 pp. (Unlock( pp, ~n.2, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                        (∀ pp lpp #t0.
                          (Lock( pp, lpp, ~n ) @ #t0)
                         ⇒
                          ((#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0))) ∧
                        (∀ pp lpp #t0.
                          (Unlock( pp, lpp, ~n ) @ #t0)
                         ⇒
                          ((#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                     (#vr.25 < #vr.2) )
                case case_1
                solve( State_111112111111( ~n, v, ~n.2 ) ▶₀ #t2.2 )
                  case insertLhkeyvdec_0_11111211111
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( State_11111111111111( ~n, k, ~n.4 ) ▶₀ #t2.2 )
                  case outLh_0_1111111111111
                  solve( Insert( h2, <~n.1, 'init'> ) @ #t2.3 )
                    case insertLhkinit_0_111111111111
                    solve( State_111111111111( h2, ~n.1, lock ) ▶₀ #t2.3 )
                      case eventNewKeyLhk_0_11111111111
                      solve( ((#vr.14 < #vr.25) ∧
                              (∃ #t2.
                                (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                               ∧
                                (#vr.14 < #t2) ∧
                                (#t2 < #vr.25) ∧
                                (∀ #t0 pp. (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                (∀ pp lpp #t0.
                                  (Lock( pp, lpp, ~n ) @ #t0)
                                 ⇒
                                  ((#t0 < #vr.14) ∨ (#t0 = #vr.14) ∨ (#t2 < #t0))) ∧
                                (∀ pp lpp #t0.
                                  (Unlock( pp, lpp, ~n ) @ #t0)
                                 ⇒
                                  ((#t0 < #vr.14) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                             (#vr.25 < #vr.14) )
                        case case_1
                        solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.3 )
                          case eventWrapHandleLh_0_1111112111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( ((#vr.2 < #vr.14) ∧
                                (∃ #t2.
                                  (Unlock_2( '2', ~n.2, ~n ) @ #t2)
                                 ∧
                                  (#vr.2 < #t2) ∧
                                  (#t2 < #vr.14) ∧
                                  (∀ #t0 pp. (Unlock( pp, ~n.2, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                  (∀ pp lpp #t0.
                                    (Lock( pp, lpp, ~n ) @ #t0)
                                   ⇒
                                    ((#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0))) ∧
                                  (∀ pp lpp #t0.
                                    (Unlock( pp, lpp, ~n ) @ #t0)
                                   ⇒
                                    ((#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                               (#vr.14 < #vr.2) )
                          case case_1
                          solve( State_111112111111( ~n, v, ~n.2 ) ▶₀ #t2.3 )
                            case insertLhkeyvdec_0_11111211111
                            by contradiction /* from formulas */
                          qed
                        next
                          case case_2
                          solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.3 )
                            case eventWrapHandleLh_0_1111112111111
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case case_3
      solve( ((#t1 < #t3) ∧ (#t0 < #t3))  ∥ ((#t1 < #t2) ∧ (#t0 < #t2)) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    solve( (#t1 = #t2.1)  ∥ (#t2.1 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_3
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_4
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_5
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_3( '3', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_4( '4', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_8
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_5( '5', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_9
    solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
           (∀ #t2.
             (Unlock_6( '6', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3.1) ∨
              (#t3.1 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma no_key_is_wrap_and_dec_ind2 [use_induction, reuse]:
  all-traces
  "∀ #t2 #t3 h1 h2 k.
    ((DecKey( h1, k ) @ #t2) ∧ (Unwrapped( h2, k ) @ #t3)) ⇒
    (∃ h k2 #t1 #t0.
      ((NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧
      (((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))"
/*
guarded formula characterizing all counter-examples:
"∃ #t2 #t3 h1 h2 k.
  (DecKey( h1, k ) @ #t2) ∧ (Unwrapped( h2, k ) @ #t3)
 ∧
  ∀ h k2 #t1 #t0.
   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
  ⇒
   (((¬(#t1 < #t3)) ∨ (¬(#t0 < #t3)))) ∧
   (((¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #t2 #t3 h1 h2 k.
           (DecKey( h1, k ) @ #t2) ∧ (Unwrapped( h2, k ) @ #t3)
          ⇒
           ((last(#t3)) ∨
            (last(#t2)) ∨
            (∃ h k2 #t1 #t0.
              (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
             ∧
              (¬(last(#t0))) ∧
              (¬(last(#t1))) ∧
              ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2)))))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_3( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_4( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_5( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_6( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (last(#t3))  ∥ (last(#t2))  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (¬(last(#t0))) ∧
               (¬(last(#t1))) ∧
               ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
               ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (last(#t3))  ∥ (last(#t2))  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (¬(last(#t0))) ∧
               (¬(last(#t1))) ∧
               ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
               ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_4
      solve( (last(#t3))  ∥ (last(#t2))  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (¬(last(#t0))) ∧
               (¬(last(#t1))) ∧
               ((((#t1 < #t3) ∧ (#t0 < #t3)) ∨ ((#t1 < #t2) ∧ (#t0 < #t2))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                (∃ hp #t0.1.
                  (WrapKey( hp, k.1 ) @ #t0.1)
                 ∧
                  (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                  (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
               (∃ h k2 #t1 #t0.1.
                 (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                ∧
                 (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
               (∃ #t0.1 #t1 h1 h2 k.
                 (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                ∧
                 (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
               (∃ #t0.1 #t1 h1 h2 k.
                 (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                ∧
                 (#t0.1 < #t0) ∧ (#t1 < #t0)) )
          case case_1
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          by contradiction /* from formulas */
        next
          case case_3
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_4
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1.1 = #t2.1)  ∥ (#t2.1 < #t1.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1.1 = #t2.1)  ∥ (#t2.1 < #t1.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_4
      solve( (#t1.1 = #t2.1)  ∥ (#t2.1 < #t1.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_4
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_5
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_3( '3', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_3( '3', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_3( '3', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_4( '4', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_4( '4', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_4( '4', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_8
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_5( '5', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_5( '5', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_5( '5', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.5 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.5 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.5 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_9
    solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3) ∧
            (∃ hp #t0.
              (WrapKey( hp, k ) @ #t0)
             ∧
              (((#t0 = #t3) ∨ (#t0 < #t3))) ∧
              (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_6( '6', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t2) ∧ (#t0.1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_6( '6', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                 ((#t1.2 < #t1.1) ∧ (#t0.1 < #t1.1)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_4
      solve( (#t1 = #t3.1)  ∥ (#t3.1 < #t1)  ∥
             (∀ #t2.
               (Unlock_6( '6', ~n, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3.1) ∨
                (#t3.1 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3.1 = #t1)  ∥ (#t1 < #t3.1) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k.1 ) @ #t1) ∧ #t1 < #t0) ∧
                  (∃ hp #t0.1.
                    (WrapKey( hp, k.1 ) @ #t0.1)
                   ∧
                    (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k.1 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.1.
                   (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                 (∃ #t0.1 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0.1 < #t0) ∧ (#t1 < #t0)) )
            case case_1
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.1) ∧ (#t0.2 < #t1.1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_3
              solve( ((#t1.3 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     ((#t1.3 < #t1.2) ∧ (#t0.2 < #t1.2)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_4
            solve( (∃ #t0 pp.
                     (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
                   (∃ pp lpp #t0.
                     (Lock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (¬(#t0 = #t1)) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
                   (∃ pp lpp #t0.
                     (Unlock( pp, lpp, x ) @ #t0)
                    ∧
                     (¬(last(#t0))) ∧
                     (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                     (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                     (¬(#t2.1 = #t0))) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( ((∃ h1 #t1. (NewKey( h1, k.6 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.6 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.6 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_3
              solve( ((∃ h1 #t1. (NewKey( h1, k.6 ) @ #t1) ∧ #t1 < #t0.1) ∧
                      (∃ hp #t0.2.
                        (WrapKey( hp, k.6 ) @ #t0.2)
                       ∧
                        (((#t0.2 = #t0.1) ∨ (#t0.2 < #t0.1))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, k.6 ) @ #t1) ⇒ #t0.2 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.2.
                       (NewKey( h, k2 ) @ #t0.2) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #t0.1) ∧ (#t0.2 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1))  ∥
                     (∃ #t0.2 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0.2) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0.2 < #t0.1) ∧ (#t1 < #t0.1)) )
                case case_1
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( (#t0.4 = #t1)  ∥ (#t1 < #t0.4) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.4)  ∥ (#t0.4 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_4
                solve( (#t0.3 = #t1)  ∥ (#t1 < #t0.3) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  solve( (#t2.1 = #t0.3)  ∥ (#t0.3 < #t2.1) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma cannot_obtain_key_ind [reuse, use_induction]:
  all-traces "¬(∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (!KU( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (!KU( k ) @ #j)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #i #j h k.
           (NewKey( h, k ) @ #i) ∧ (!KU( k ) @ #j) ⇒ ((last(#j)) ∨ (last(#i))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_3( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_4( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_5( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_6( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#j))  ∥ (last(#i)) )
      case case_1
      solve( State_11111111111( h, k, lock ) ▶₀ #i )
        case newk_0_1111111111
        solve( !KU( ~n.1 ) @ #j )
          case outsdecckeyv_0_11112111111_case_1
          by contradiction /* from formulas */
        next
          case outsdecckeyv_0_11112111111_case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2) ∧
                  (∃ hp #t0.
                    (WrapKey( hp, k2 ) @ #t0)
                   ∧
                    (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.
                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t2) ∧ (#t0 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          next
            case case_4
            by contradiction /* from formulas */
          qed
        next
          case outsdecckeyv_0_11112111111_case_3
          by contradiction /* from formulas */
        next
          case outsdecckeyv_0_11112111111_case_4
          by contradiction /* from formulas */
        next
          case outsenckeyvkeyv_0_1121111111
          solve( Insert( L_h2, <z, 'wrap'> ) @ #t2 )
            case insertLhkeyvwrap_0_111111211111
            solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2 )
              case eventWrapKeyLhkeyv_0_11111121111
              solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.1 )
                case insertLhkeyvwrap_0_111111211111
                solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.1 )
                  case eventWrapKeyLhkeyv_0_11111121111
                  solve( ((#vr.20 < #vr.40) ∧
                          (∃ #t2.
                            (Unlock_5( '5', ~n.5, L_h1 ) @ #t2)
                           ∧
                            (#vr.20 < #t2) ∧
                            (#t2 < #vr.40) ∧
                            (∀ #t0 pp. (Unlock( pp, ~n.5, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                            (∀ pp lpp #t0.
                              (Lock( pp, lpp, L_h1 ) @ #t0)
                             ⇒
                              ((#t0 < #vr.20) ∨ (#t0 = #vr.20) ∨ (#t2 < #t0))) ∧
                            (∀ pp lpp #t0.
                              (Unlock( pp, lpp, L_h1 ) @ #t0)
                             ⇒
                              ((#t0 < #vr.20) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                         (#vr.40 < #vr.20) )
                    case case_1
                    solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.5 ) ▶₀ #t2.2 )
                      case outsenckeyvkeyv_0_1121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_11111121111111( L_h1, v, ~n.4 ) ▶₀ #t2.2 )
                      case eventWrapHandleLh_0_1111112111111
                      solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        solve( Insert( L_h2, <z, 'init'> ) @ #t2.3 )
                          case insertLhkinit_0_111111111111
                          solve( State_111111111111( L_h2, z, lock ) ▶₀ #t2.3 )
                            case eventNewKeyLhk_0_11111111111
                            solve( (#vr.14, 0) ~~> (#j, 0) )
                              case Var_fresh_4_n
                              solve( ((#vr.28 < #vr.1) ∧
                                      (∃ #t2.
                                        (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                       ∧
                                        (#vr.28 < #t2) ∧
                                        (#t2 < #vr.1) ∧
                                        (∀ #t0 pp. (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                        (∀ pp lpp #t0.
                                          (Lock( pp, lpp, ~n ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.28) ∨ (#t0 = #vr.28) ∨ (#t2 < #t0))) ∧
                                        (∀ pp lpp #t0.
                                          (Unlock( pp, lpp, ~n ) @ #t0)
                                         ⇒
                                          ((#t0 < #vr.28) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                     (#vr.1 < #vr.28) )
                                case case_1
                                solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.4 )
                                  case eventWrapHandleLh_0_1111112111111
                                  by contradiction /* cyclic */
                                qed
                              next
                                case case_2
                                solve( State_11111111111111( ~n, k, ~n.2 ) ▶₀ #t2.4 )
                                  case outLh_0_1111111111111
                                  solve( Insert( L_h1, <z, 'init'> ) @ #t2.5 )
                                    case insertLhkinit_0_111111111111
                                    solve( State_111111111111( L_h1, z, lock ) ▶₀ #t2.5 )
                                      case eventNewKeyLhk_0_11111111111
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              next
                case insertLhmwrap_0_121111111
                solve( State_121111111( L_h, L_h1, k, z.1, v, lock ) ▶₀ #t2.1 )
                  case eventUnwrappedLhm_0_12111111
                  solve( ((∃ h1 #t1. (NewKey( h1, z.1 ) @ #t1) ∧ #t1 < #vr.37) ∧
                          (∃ hp #t0.
                            (WrapKey( hp, z.1 ) @ #t0)
                           ∧
                            (((#t0 = #vr.37) ∨ (#t0 < #vr.37))) ∧
                            (∀ hpp #t1. (Unwrapped( hpp, z.1 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                         (∃ h k2 #t1 #t0.
                           (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                          ∧
                           (#t1 < #vr.37) ∧ (#t0 < #vr.37))  ∥
                         (∃ #t0 #t1 h1 h2 k.
                           (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                          ∧
                           (#t0 < #vr.37) ∧ (#t1 < #vr.37))  ∥
                         (∃ #t0 #t1 h1 h2 k.
                           (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                          ∧
                           (#t0 < #vr.37) ∧ (#t1 < #vr.37)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  next
                    case case_3
                    by contradiction /* from formulas */
                  next
                    case case_4
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          next
            case insertLhmwrap_0_121111111
            solve( State_121111111( L_h, L_h2, k, z, v, lock ) ▶₀ #t2 )
              case eventUnwrappedLhm_0_12111111
              solve( ((∃ h1 #t1. (NewKey( h1, z ) @ #t1) ∧ #t1 < #vr.25) ∧
                      (∃ hp #t0.
                        (WrapKey( hp, z ) @ #t0)
                       ∧
                        (((#t0 = #vr.25) ∨ (#t0 < #vr.25))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, z ) @ #t1) ⇒ #t0 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.
                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #vr.25) ∧ (#t0 < #vr.25))  ∥
                     (∃ #t0 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0 < #vr.25) ∧ (#t1 < #vr.25))  ∥
                     (∃ #t0 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0 < #vr.25) ∧ (#t1 < #vr.25)) )
                case case_1
                solve( State_11111111111( h1, z, lock ) ▶₀ #t1 )
                  case newk_0_1111111111
                  solve( (#vr.14, 0) ~~> (#j, 0) )
                    case Var_fresh_3_n
                    solve( State_11111121111( hp, <~n.1, x>, lock ) ▶₀ #t0 )
                      case ifattvinit_0_1111112111
                      solve( Insert( L_h1, <z, 'wrap'> ) @ #t2.1 )
                        case insertLhkeyvwrap_0_111111211111
                        solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.1 )
                          case eventWrapKeyLhkeyv_0_11111121111
                          solve( ((#vr.20 < #vr.48) ∧
                                  (∃ #t2.
                                    (Unlock_5( '5', ~n.7, L_h1 ) @ #t2)
                                   ∧
                                    (#vr.20 < #t2) ∧
                                    (#t2 < #vr.48) ∧
                                    (∀ #t0 pp. (Unlock( pp, ~n.7, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                                    (∀ pp lpp #t0.
                                      (Lock( pp, lpp, L_h1 ) @ #t0)
                                     ⇒
                                      ((#t0 < #vr.20) ∨ (#t0 = #vr.20) ∨ (#t2 < #t0))) ∧
                                    (∀ pp lpp #t0.
                                      (Unlock( pp, lpp, L_h1 ) @ #t0)
                                     ⇒
                                      ((#t0 < #vr.20) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                 (#vr.48 < #vr.20) )
                            case case_1
                            solve( State_11211111111( L_h1, L_h2, v1, v2, ~n.7 ) ▶₀ #t2.2 )
                              case outsenckeyvkeyv_0_1121111111
                              by contradiction /* cyclic */
                            qed
                          next
                            case case_2
                            solve( State_11111121111111( L_h1, v, ~n.6 ) ▶₀ #t2.2 )
                              case eventWrapHandleLh_0_1111112111111
                              solve( (#t2.5 < #t2.6)  ∥ (#t2.5 = #t2.6) )
                                case case_1
                                by contradiction /* from formulas */
                              next
                                case case_2
                                solve( !KU( senc(~n.1, k) ) @ #vk.8 )
                                  case c_senc
                                  by contradiction /* cyclic */
                                next
                                  case outsdecckeyv_0_11112111111_case_1
                                  by contradiction /* from formulas */
                                next
                                  case outsdecckeyv_0_11112111111_case_2
                                  solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2.3) ∧
                                          (∃ hp #t0.
                                            (WrapKey( hp, k2 ) @ #t0)
                                           ∧
                                            (((#t0 = #t2.3) ∨ (#t0 < #t2.3))) ∧
                                            (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                         (∃ h k2 #t1 #t0.
                                           (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                          ∧
                                           (#t1 < #t2.3) ∧ (#t0 < #t2.3))  ∥
                                         (∃ #t0 #t1 h1 h2 k.
                                           (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                          ∧
                                           (#t0 < #t2.3) ∧ (#t1 < #t2.3))  ∥
                                         (∃ #t0 #t1 h1 h2 k.
                                           (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                          ∧
                                           (#t0 < #t2.3) ∧ (#t1 < #t2.3)) )
                                    case case_1
                                    by contradiction /* from formulas */
                                  next
                                    case case_2
                                    by contradiction /* from formulas */
                                  next
                                    case case_3
                                    by contradiction /* from formulas */
                                  next
                                    case case_4
                                    by contradiction /* from formulas */
                                  qed
                                next
                                  case outsdecckeyv_0_11112111111_case_3
                                  by contradiction /* from formulas */
                                next
                                  case outsdecckeyv_0_11112111111_case_4
                                  by contradiction /* from formulas */
                                next
                                  case outsenckeyvkeyv_0_1121111111_case_1
                                  solve( !KU( ~n.4 ) @ #vk.6 )
                                    case outLh_0_1211111111
                                    solve( (#t2.3 < #t2.8)  ∥ (#t2.3 = #t2.8) )
                                      case case_1
                                      by contradiction /* from formulas */
                                    next
                                      case case_2
                                      solve( Insert( L_h, <k, 'wrap'> ) @ #t2.3 )
                                        case insertLhkeyvwrap_0_111111211111
                                        solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.3 )
                                          case eventWrapKeyLhkeyv_0_11111121111
                                          solve( ((#vr.30 < #vr.73) ∧
                                                  (∃ #t2.
                                                    (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                   ∧
                                                    (#vr.30 < #t2) ∧
                                                    (#t2 < #vr.73) ∧
                                                    (∀ #t0 pp. (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                    (∀ pp lpp #t0.
                                                      (Lock( pp, lpp, L_h ) @ #t0)
                                                     ⇒
                                                      ((#t0 < #vr.30) ∨ (#t0 = #vr.30) ∨ (#t2 < #t0))) ∧
                                                    (∀ pp lpp #t0.
                                                      (Unlock( pp, lpp, L_h ) @ #t0)
                                                     ⇒
                                                      ((#t0 < #vr.30) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                 (#vr.73 < #vr.30) )
                                            case case_1
                                            solve( State_12111111111( L_h, L_h2.1, k.1, m, v, ~n.5
                                                   ) ▶₀ #t2.4 )
                                              case outLh_0_1211111111
                                              by contradiction /* cyclic */
                                            qed
                                          next
                                            case case_2
                                            solve( State_11111121111111( L_h, v, ~n.7 ) ▶₀ #t2.4 )
                                              case eventWrapHandleLh_0_1111112111111
                                              solve( (#t2.9 < #t2.10)  ∥ (#t2.9 = #t2.10) )
                                                case case_1
                                                by contradiction /* from formulas */
                                              next
                                                case case_2
                                                solve( Insert( hp, <~n.1, 'init'> ) @ #t2.5 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.5 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    solve( ((#vr.36 < #vr.1) ∧
                                                            (∃ #t2.
                                                              (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                             ∧
                                                              (#vr.36 < #t2) ∧
                                                              (#t2 < #vr.1) ∧
                                                              (∀ #t0 pp.
                                                                (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                              (∀ pp lpp #t0.
                                                                (Lock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t0 = #vr.36) ∨
                                                                 (#t2 < #t0))) ∧
                                                              (∀ pp lpp #t0.
                                                                (Unlock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t2 < #t0) ∨
                                                                 (#t2 = #t0)))))  ∥
                                                           (#vr.1 < #vr.36) )
                                                      case case_1
                                                      solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.6 )
                                                        case eventWrapHandleLh_0_1111112111111
                                                        by contradiction /* cyclic */
                                                      qed
                                                    next
                                                      case case_2
                                                      solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.6 )
                                                        case outLh_0_1111111111111
                                                        solve( Insert( L_h1, <z, 'init'> ) @ #t2.7 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z, lock
                                                                 ) ▶₀ #t2.7 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case insertLhmwrap_0_121111111
                                        solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.3 )
                                          case eventUnwrappedLhm_0_12111111
                                          solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #vr.70) ∧
                                                  (∃ hp #t0.
                                                    (WrapKey( hp, k ) @ #t0)
                                                   ∧
                                                    (((#t0 = #vr.70) ∨ (#t0 < #vr.70))) ∧
                                                    (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                                 (∃ h k2 #t1 #t0.
                                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                  ∧
                                                   (#t1 < #vr.70) ∧ (#t0 < #vr.70))  ∥
                                                 (∃ #t0 #t1 h1 h2 k.
                                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                  ∧
                                                   (#t0 < #vr.70) ∧ (#t1 < #vr.70))  ∥
                                                 (∃ #t0 #t1 h1 h2 k.
                                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                  ∧
                                                   (#t0 < #vr.70) ∧ (#t1 < #vr.70)) )
                                            case case_1
                                            solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                                              case newk_0_1111111111
                                              solve( State_11111121111( hp.1, <~n.5, x>, lock ) ▶₀ #t0.1 )
                                                case ifattvinit_0_1111112111
                                                solve( Insert( hp, <~n.1, 'init'> ) @ #t2.4 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.4 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    solve( ((#vr.36 < #vr.1) ∧
                                                            (∃ #t2.
                                                              (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                             ∧
                                                              (#vr.36 < #t2) ∧
                                                              (#t2 < #vr.1) ∧
                                                              (∀ #t0 pp.
                                                                (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                              (∀ pp lpp #t0.
                                                                (Lock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t0 = #vr.36) ∨
                                                                 (#t2 < #t0))) ∧
                                                              (∀ pp lpp #t0.
                                                                (Unlock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t2 < #t0) ∨
                                                                 (#t2 = #t0)))))  ∥
                                                           (#vr.1 < #vr.36) )
                                                      case case_1
                                                      solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.5 )
                                                        case eventWrapHandleLh_0_1111112111111
                                                        by contradiction /* cyclic */
                                                      qed
                                                    next
                                                      case case_2
                                                      solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.5 )
                                                        case outLh_0_1111111111111
                                                        solve( Insert( L_h1, <z, 'init'> ) @ #t2.6 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z, lock
                                                                 ) ▶₀ #t2.6 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case case_2
                                            by contradiction /* from formulas */
                                          next
                                            case case_3
                                            by contradiction /* from formulas */
                                          next
                                            case case_4
                                            by contradiction /* from formulas */
                                          qed
                                        qed
                                      qed
                                    qed
                                  next
                                    case outsdecckeyv_0_11112111111_case_1
                                    by contradiction /* from formulas */
                                  next
                                    case outsdecckeyv_0_11112111111_case_2
                                    solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2.3) ∧
                                            (∃ hp #t0.
                                              (WrapKey( hp, k2 ) @ #t0)
                                             ∧
                                              (((#t0 = #t2.3) ∨ (#t0 < #t2.3))) ∧
                                              (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                           (∃ h k2 #t1 #t0.
                                             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                            ∧
                                             (#t1 < #t2.3) ∧ (#t0 < #t2.3))  ∥
                                           (∃ #t0 #t1 h1 h2 k.
                                             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                            ∧
                                             (#t0 < #t2.3) ∧ (#t1 < #t2.3))  ∥
                                           (∃ #t0 #t1 h1 h2 k.
                                             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                            ∧
                                             (#t0 < #t2.3) ∧ (#t1 < #t2.3)) )
                                      case case_1
                                      by contradiction /* from formulas */
                                    next
                                      case case_2
                                      by contradiction /* from formulas */
                                    next
                                      case case_3
                                      by contradiction /* from formulas */
                                    next
                                      case case_4
                                      by contradiction /* from formulas */
                                    qed
                                  next
                                    case outsdecckeyv_0_11112111111_case_3
                                    by contradiction /* from formulas */
                                  next
                                    case outsdecckeyv_0_11112111111_case_4
                                    by contradiction /* from formulas */
                                  next
                                    case outsenckeyvkeyv_0_1121111111
                                    solve( Insert( L_h, <k, 'wrap'> ) @ #t2.3 )
                                      case insertLhkeyvwrap_0_111111211111
                                      solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.3 )
                                        case eventWrapKeyLhkeyv_0_11111121111
                                        solve( ((#vr.30 < #vr.84) ∧
                                                (∃ #t2.
                                                  (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                 ∧
                                                  (#vr.30 < #t2) ∧
                                                  (#t2 < #vr.84) ∧
                                                  (∀ #t0 pp. (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                  (∀ pp lpp #t0.
                                                    (Lock( pp, lpp, L_h ) @ #t0)
                                                   ⇒
                                                    ((#t0 < #vr.30) ∨ (#t0 = #vr.30) ∨ (#t2 < #t0))) ∧
                                                  (∀ pp lpp #t0.
                                                    (Unlock( pp, lpp, L_h ) @ #t0)
                                                   ⇒
                                                    ((#t0 < #vr.30) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                               (#vr.84 < #vr.30) )
                                          case case_1
                                          solve( State_12111111111( L_h, L_h2.2, k.1, m, v, ~n.5 ) ▶₀ #t2.4 )
                                            case outLh_0_1211111111
                                            by contradiction /* cyclic */
                                          qed
                                        next
                                          case case_2
                                          solve( State_11111121111111( L_h, v, ~n.7 ) ▶₀ #t2.4 )
                                            case eventWrapHandleLh_0_1111112111111
                                            solve( (#t2.11 < #t2.12)  ∥ (#t2.11 = #t2.12) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( Insert( hp, <~n.1, 'init'> ) @ #t2.5 )
                                                case insertLhkinit_0_111111111111
                                                solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.5 )
                                                  case eventNewKeyLhk_0_11111111111
                                                  solve( ((#vr.36 < #vr.1) ∧
                                                          (∃ #t2.
                                                            (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                           ∧
                                                            (#vr.36 < #t2) ∧
                                                            (#t2 < #vr.1) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t0 = #vr.36) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.1 < #vr.36) )
                                                    case case_1
                                                    solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.6 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.6 )
                                                      case outLh_0_1111111111111
                                                      solve( Insert( L_h1, <z, 'init'> ) @ #t2.7 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z, lock ) ▶₀ #t2.7 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case insertLhmwrap_0_121111111
                                      solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.3 )
                                        case eventUnwrappedLhm_0_12111111
                                        solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #vr.81) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k ) @ #t0)
                                                 ∧
                                                  (((#t0 = #vr.81) ∨ (#t0 < #vr.81))) ∧
                                                  (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (#t1 < #vr.81) ∧ (#t0 < #vr.81))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (#t0 < #vr.81) ∧ (#t1 < #vr.81))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (#t0 < #vr.81) ∧ (#t1 < #vr.81)) )
                                          case case_1
                                          solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                                            case newk_0_1111111111
                                            solve( State_11111121111( hp.1, <~n.5, x>, lock ) ▶₀ #t0.1 )
                                              case ifattvinit_0_1111112111
                                              solve( Insert( hp, <~n.1, 'init'> ) @ #t2.4 )
                                                case insertLhkinit_0_111111111111
                                                solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.4 )
                                                  case eventNewKeyLhk_0_11111111111
                                                  solve( ((#vr.36 < #vr.1) ∧
                                                          (∃ #t2.
                                                            (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                           ∧
                                                            (#vr.36 < #t2) ∧
                                                            (#t2 < #vr.1) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t0 = #vr.36) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.1 < #vr.36) )
                                                    case case_1
                                                    solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.5 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.5 )
                                                      case outLh_0_1111111111111
                                                      solve( Insert( L_h1, <z, 'init'> ) @ #t2.6 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z, lock ) ▶₀ #t2.6 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      qed
                                    qed
                                  qed
                                next
                                  case outsenckeyvkeyv_0_1121111111_case_2
                                  solve( !KU( ~n.4 ) @ #vk.6 )
                                    case outLh_0_1211111111
                                    solve( (#t2.3 < #t2.8)  ∥ (#t2.3 = #t2.8) )
                                      case case_1
                                      by contradiction /* from formulas */
                                    next
                                      case case_2
                                      solve( Insert( L_h, <k, 'wrap'> ) @ #t2.3 )
                                        case insertLhkeyvwrap_0_111111211111
                                        solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.3 )
                                          case eventWrapKeyLhkeyv_0_11111121111
                                          solve( ((#vr.30 < #vr.74) ∧
                                                  (∃ #t2.
                                                    (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                   ∧
                                                    (#vr.30 < #t2) ∧
                                                    (#t2 < #vr.74) ∧
                                                    (∀ #t0 pp. (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                    (∀ pp lpp #t0.
                                                      (Lock( pp, lpp, L_h ) @ #t0)
                                                     ⇒
                                                      ((#t0 < #vr.30) ∨ (#t0 = #vr.30) ∨ (#t2 < #t0))) ∧
                                                    (∀ pp lpp #t0.
                                                      (Unlock( pp, lpp, L_h ) @ #t0)
                                                     ⇒
                                                      ((#t0 < #vr.30) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                                 (#vr.74 < #vr.30) )
                                            case case_1
                                            solve( State_12111111111( L_h, L_h2.1, k.1, m, v, ~n.5
                                                   ) ▶₀ #t2.4 )
                                              case outLh_0_1211111111
                                              by contradiction /* cyclic */
                                            qed
                                          next
                                            case case_2
                                            solve( State_11111121111111( L_h, v, ~n.7 ) ▶₀ #t2.4 )
                                              case eventWrapHandleLh_0_1111112111111
                                              solve( (#t2.9 < #t2.10)  ∥ (#t2.9 = #t2.10) )
                                                case case_1
                                                by contradiction /* from formulas */
                                              next
                                                case case_2
                                                solve( Insert( hp, <~n.1, 'init'> ) @ #t2.5 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.5 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    solve( ((#vr.36 < #vr.1) ∧
                                                            (∃ #t2.
                                                              (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                             ∧
                                                              (#vr.36 < #t2) ∧
                                                              (#t2 < #vr.1) ∧
                                                              (∀ #t0 pp.
                                                                (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                              (∀ pp lpp #t0.
                                                                (Lock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t0 = #vr.36) ∨
                                                                 (#t2 < #t0))) ∧
                                                              (∀ pp lpp #t0.
                                                                (Unlock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t2 < #t0) ∨
                                                                 (#t2 = #t0)))))  ∥
                                                           (#vr.1 < #vr.36) )
                                                      case case_1
                                                      solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.6 )
                                                        case eventWrapHandleLh_0_1111112111111
                                                        by contradiction /* cyclic */
                                                      qed
                                                    next
                                                      case case_2
                                                      solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.6 )
                                                        case outLh_0_1111111111111
                                                        solve( Insert( L_h1, <z, 'init'> ) @ #t2.7 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z, lock
                                                                 ) ▶₀ #t2.7 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case insertLhmwrap_0_121111111
                                        solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.3 )
                                          case eventUnwrappedLhm_0_12111111
                                          solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #vr.71) ∧
                                                  (∃ hp #t0.
                                                    (WrapKey( hp, k ) @ #t0)
                                                   ∧
                                                    (((#t0 = #vr.71) ∨ (#t0 < #vr.71))) ∧
                                                    (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                                 (∃ h k2 #t1 #t0.
                                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                  ∧
                                                   (#t1 < #vr.71) ∧ (#t0 < #vr.71))  ∥
                                                 (∃ #t0 #t1 h1 h2 k.
                                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                  ∧
                                                   (#t0 < #vr.71) ∧ (#t1 < #vr.71))  ∥
                                                 (∃ #t0 #t1 h1 h2 k.
                                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                  ∧
                                                   (#t0 < #vr.71) ∧ (#t1 < #vr.71)) )
                                            case case_1
                                            solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                                              case newk_0_1111111111
                                              solve( State_11111121111( hp.1, <~n.5, x>, lock ) ▶₀ #t0.1 )
                                                case ifattvinit_0_1111112111
                                                solve( Insert( hp, <~n.1, 'init'> ) @ #t2.4 )
                                                  case insertLhkinit_0_111111111111
                                                  solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.4 )
                                                    case eventNewKeyLhk_0_11111111111
                                                    solve( ((#vr.36 < #vr.1) ∧
                                                            (∃ #t2.
                                                              (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                             ∧
                                                              (#vr.36 < #t2) ∧
                                                              (#t2 < #vr.1) ∧
                                                              (∀ #t0 pp.
                                                                (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                              (∀ pp lpp #t0.
                                                                (Lock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t0 = #vr.36) ∨
                                                                 (#t2 < #t0))) ∧
                                                              (∀ pp lpp #t0.
                                                                (Unlock( pp, lpp, ~n ) @ #t0)
                                                               ⇒
                                                                ((#t0 < #vr.36) ∨
                                                                 (#t2 < #t0) ∨
                                                                 (#t2 = #t0)))))  ∥
                                                           (#vr.1 < #vr.36) )
                                                      case case_1
                                                      solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.5 )
                                                        case eventWrapHandleLh_0_1111112111111
                                                        by contradiction /* cyclic */
                                                      qed
                                                    next
                                                      case case_2
                                                      solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.5 )
                                                        case outLh_0_1111111111111
                                                        solve( Insert( L_h1, <z, 'init'> ) @ #t2.6 )
                                                          case insertLhkinit_0_111111111111
                                                          solve( State_111111111111( L_h1, z, lock
                                                                 ) ▶₀ #t2.6 )
                                                            case eventNewKeyLhk_0_11111111111
                                                            by contradiction /* from formulas */
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case case_2
                                            by contradiction /* from formulas */
                                          next
                                            case case_3
                                            by contradiction /* from formulas */
                                          next
                                            case case_4
                                            by contradiction /* from formulas */
                                          qed
                                        qed
                                      qed
                                    qed
                                  next
                                    case outsdecckeyv_0_11112111111_case_1
                                    by contradiction /* from formulas */
                                  next
                                    case outsdecckeyv_0_11112111111_case_2
                                    solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2.3) ∧
                                            (∃ hp #t0.
                                              (WrapKey( hp, k2 ) @ #t0)
                                             ∧
                                              (((#t0 = #t2.3) ∨ (#t0 < #t2.3))) ∧
                                              (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                           (∃ h k2 #t1 #t0.
                                             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                            ∧
                                             (#t1 < #t2.3) ∧ (#t0 < #t2.3))  ∥
                                           (∃ #t0 #t1 h1 h2 k.
                                             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                            ∧
                                             (#t0 < #t2.3) ∧ (#t1 < #t2.3))  ∥
                                           (∃ #t0 #t1 h1 h2 k.
                                             (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                            ∧
                                             (#t0 < #t2.3) ∧ (#t1 < #t2.3)) )
                                      case case_1
                                      by contradiction /* from formulas */
                                    next
                                      case case_2
                                      by contradiction /* from formulas */
                                    next
                                      case case_3
                                      by contradiction /* from formulas */
                                    next
                                      case case_4
                                      by contradiction /* from formulas */
                                    qed
                                  next
                                    case outsdecckeyv_0_11112111111_case_3
                                    by contradiction /* from formulas */
                                  next
                                    case outsdecckeyv_0_11112111111_case_4
                                    by contradiction /* from formulas */
                                  next
                                    case outsenckeyvkeyv_0_1121111111
                                    solve( Insert( L_h, <k, 'wrap'> ) @ #t2.3 )
                                      case insertLhkeyvwrap_0_111111211111
                                      solve( State_111111211111( L_h, v, lock ) ▶₀ #t2.3 )
                                        case eventWrapKeyLhkeyv_0_11111121111
                                        solve( ((#vr.30 < #vr.85) ∧
                                                (∃ #t2.
                                                  (Unlock_6( '6', ~n.5, L_h ) @ #t2)
                                                 ∧
                                                  (#vr.30 < #t2) ∧
                                                  (#t2 < #vr.85) ∧
                                                  (∀ #t0 pp. (Unlock( pp, ~n.5, L_h ) @ #t0) ⇒ #t0 = #t2) ∧
                                                  (∀ pp lpp #t0.
                                                    (Lock( pp, lpp, L_h ) @ #t0)
                                                   ⇒
                                                    ((#t0 < #vr.30) ∨ (#t0 = #vr.30) ∨ (#t2 < #t0))) ∧
                                                  (∀ pp lpp #t0.
                                                    (Unlock( pp, lpp, L_h ) @ #t0)
                                                   ⇒
                                                    ((#t0 < #vr.30) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                                               (#vr.85 < #vr.30) )
                                          case case_1
                                          solve( State_12111111111( L_h, L_h2.2, k.1, m, v, ~n.5 ) ▶₀ #t2.4 )
                                            case outLh_0_1211111111
                                            by contradiction /* cyclic */
                                          qed
                                        next
                                          case case_2
                                          solve( State_11111121111111( L_h, v, ~n.7 ) ▶₀ #t2.4 )
                                            case eventWrapHandleLh_0_1111112111111
                                            solve( (#t2.11 < #t2.12)  ∥ (#t2.11 = #t2.12) )
                                              case case_1
                                              by contradiction /* from formulas */
                                            next
                                              case case_2
                                              solve( Insert( hp, <~n.1, 'init'> ) @ #t2.5 )
                                                case insertLhkinit_0_111111111111
                                                solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.5 )
                                                  case eventNewKeyLhk_0_11111111111
                                                  solve( ((#vr.36 < #vr.1) ∧
                                                          (∃ #t2.
                                                            (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                           ∧
                                                            (#vr.36 < #t2) ∧
                                                            (#t2 < #vr.1) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t0 = #vr.36) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.1 < #vr.36) )
                                                    case case_1
                                                    solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.6 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.6 )
                                                      case outLh_0_1111111111111
                                                      solve( Insert( L_h1, <z, 'init'> ) @ #t2.7 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z, lock ) ▶₀ #t2.7 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    next
                                      case insertLhmwrap_0_121111111
                                      solve( State_121111111( L_h.1, L_h, k.1, k, v, lock ) ▶₀ #t2.3 )
                                        case eventUnwrappedLhm_0_12111111
                                        solve( ((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #vr.82) ∧
                                                (∃ hp #t0.
                                                  (WrapKey( hp, k ) @ #t0)
                                                 ∧
                                                  (((#t0 = #vr.82) ∨ (#t0 < #vr.82))) ∧
                                                  (∀ hpp #t1. (Unwrapped( hpp, k ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                               (∃ h k2 #t1 #t0.
                                                 (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                                ∧
                                                 (#t1 < #vr.82) ∧ (#t0 < #vr.82))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (#t0 < #vr.82) ∧ (#t1 < #vr.82))  ∥
                                               (∃ #t0 #t1 h1 h2 k.
                                                 (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                                ∧
                                                 (#t0 < #vr.82) ∧ (#t1 < #vr.82)) )
                                          case case_1
                                          solve( State_11111111111( h1, k, lock ) ▶₀ #t1 )
                                            case newk_0_1111111111
                                            solve( State_11111121111( hp.1, <~n.5, x>, lock ) ▶₀ #t0.1 )
                                              case ifattvinit_0_1111112111
                                              solve( Insert( hp, <~n.1, 'init'> ) @ #t2.4 )
                                                case insertLhkinit_0_111111111111
                                                solve( State_111111111111( hp, ~n.1, lock ) ▶₀ #t2.4 )
                                                  case eventNewKeyLhk_0_11111111111
                                                  solve( ((#vr.36 < #vr.1) ∧
                                                          (∃ #t2.
                                                            (Unlock_1( '1', ~n.3, ~n ) @ #t2)
                                                           ∧
                                                            (#vr.36 < #t2) ∧
                                                            (#t2 < #vr.1) ∧
                                                            (∀ #t0 pp.
                                                              (Unlock( pp, ~n.3, ~n ) @ #t0) ⇒ #t0 = #t2) ∧
                                                            (∀ pp lpp #t0.
                                                              (Lock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t0 = #vr.36) ∨
                                                               (#t2 < #t0))) ∧
                                                            (∀ pp lpp #t0.
                                                              (Unlock( pp, lpp, ~n ) @ #t0)
                                                             ⇒
                                                              ((#t0 < #vr.36) ∨
                                                               (#t2 < #t0) ∨
                                                               (#t2 = #t0)))))  ∥
                                                         (#vr.1 < #vr.36) )
                                                    case case_1
                                                    solve( State_11111121111111( ~n, v, ~n.3 ) ▶₀ #t2.5 )
                                                      case eventWrapHandleLh_0_1111112111111
                                                      by contradiction /* cyclic */
                                                    qed
                                                  next
                                                    case case_2
                                                    solve( State_11111111111111( ~n, k.1, ~n.2 ) ▶₀ #t2.5 )
                                                      case outLh_0_1111111111111
                                                      solve( Insert( L_h1, <z, 'init'> ) @ #t2.6 )
                                                        case insertLhkinit_0_111111111111
                                                        solve( State_111111111111( L_h1, z, lock ) ▶₀ #t2.6 )
                                                          case eventNewKeyLhk_0_11111111111
                                                          by contradiction /* from formulas */
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        next
                                          case case_2
                                          by contradiction /* from formulas */
                                        next
                                          case case_3
                                          by contradiction /* from formulas */
                                        next
                                          case case_4
                                          by contradiction /* from formulas */
                                        qed
                                      qed
                                    qed
                                  qed
                                next
                                  case outsencmkeyv_0_111211111
                                  by contradiction /* cyclic */
                                qed
                              qed
                            qed
                          qed
                        qed
                      next
                        case insertLhmwrap_0_121111111
                        solve( State_121111111( L_h.1, L_h1, k.1, z, v, lock ) ▶₀ #t2.1 )
                          case eventUnwrappedLhm_0_12111111
                          solve( ((∃ h1 #t1. (NewKey( h1, z ) @ #t1) ∧ #t1 < #vr.45) ∧
                                  (∃ hp #t0.
                                    (WrapKey( hp, z ) @ #t0)
                                   ∧
                                    (((#t0 = #vr.45) ∨ (#t0 < #vr.45))) ∧
                                    (∀ hpp #t1. (Unwrapped( hpp, z ) @ #t1) ⇒ #t0 < #t1)))  ∥
                                 (∃ h k2 #t1 #t0.
                                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                                  ∧
                                   (#t1 < #vr.45) ∧ (#t0 < #vr.45))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (#t0 < #vr.45) ∧ (#t1 < #vr.45))  ∥
                                 (∃ #t0 #t1 h1 h2 k.
                                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                                  ∧
                                   (#t0 < #vr.45) ∧ (#t1 < #vr.45)) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by contradiction /* from formulas */
                          next
                            case case_3
                            by contradiction /* from formulas */
                          next
                            case case_4
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              next
                case case_4
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_2
      solve( State_11111111111( h, k, lock ) ▶₀ #i )
        case newk_0_1111111111
        solve( !KU( ~n.1 ) @ #j )
          case outsdecckeyv_0_11112111111_case_1
          by contradiction /* from formulas */
        next
          case outsdecckeyv_0_11112111111_case_2
          solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2) ∧
                  (∃ hp #t0.
                    (WrapKey( hp, k2 ) @ #t0)
                   ∧
                    (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.
                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t2) ∧ (#t0 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( ((#t1.1 < #t0) ∧ (#t0.1 < #t0))  ∥
                   ((#t1.1 < #t1) ∧ (#t0.1 < #t1)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_4
            solve( ((∃ h1 #t1. (NewKey( h1, k.2 ) @ #t1) ∧ #t1 < #t0) ∧
                    (∃ hp #t0.1.
                      (WrapKey( hp, k.2 ) @ #t0.1)
                     ∧
                      (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                      (∀ hpp #t1. (Unwrapped( hpp, k.2 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                   (∃ h k2 #t1 #t0.1.
                     (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                    ∧
                     (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                   (∃ #t0.1 #t1 h1 h2 k.
                     (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                   (∃ #t0.1 #t1 h1 h2 k.
                     (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                    ∧
                     (#t0.1 < #t0) ∧ (#t1 < #t0)) )
              case case_1
              solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                     ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                     ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_4
              solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                     ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case outsdecckeyv_0_11112111111_case_3
          solve( ((#t1 < #t2) ∧ (#t0 < #t2))  ∥ ((#t1 < #t3) ∧ (#t0 < #t3)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case outsdecckeyv_0_11112111111_case_4
          solve( ((∃ h1 #t1. (NewKey( h1, k2 ) @ #t1) ∧ #t1 < #t2) ∧
                  (∃ hp #t0.
                    (WrapKey( hp, k2 ) @ #t0)
                   ∧
                    (((#t0 = #t2) ∨ (#t0 < #t2))) ∧
                    (∀ hpp #t1. (Unwrapped( hpp, k2 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                 (∃ h k2 #t1 #t0.
                   (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                  ∧
                   (#t1 < #t2) ∧ (#t0 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2))  ∥
                 (∃ #t0 #t1 h1 h2 k.
                   (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                  ∧
                   (#t0 < #t2) ∧ (#t1 < #t2)) )
            case case_1
            solve( ((#t1.1 < #t2) ∧ (#t0 < #t2))  ∥ ((#t1.1 < #t3) ∧ (#t0 < #t3)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            solve( ((#t1.1 < #t2) ∧ (#t0 < #t2))  ∥ ((#t1.1 < #t3) ∧ (#t0 < #t3)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_4
            solve( ((#t1.1 < #t2) ∧ (#t0 < #t2))  ∥ ((#t1.1 < #t3) ∧ (#t0 < #t3)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case outsenckeyvkeyv_0_1121111111
          solve( Insert( L_h2, <z, 'wrap'> ) @ #t2 )
            case insertLhkeyvwrap_0_111111211111
            solve( State_111111211111( L_h2, v, lock ) ▶₀ #t2 )
              case eventWrapKeyLhkeyv_0_11111121111
              solve( Insert( L_h1, <z.1, 'wrap'> ) @ #t2.1 )
                case insertLhkeyvwrap_0_111111211111
                solve( State_111111211111( L_h1, v, lock ) ▶₀ #t2.1 )
                  case eventWrapKeyLhkeyv_0_11111121111
                  solve( ((#vr.20 < #vr.40) ∧
                          (∃ #t2.
                            (Unlock_5( '5', ~n.5, L_h1 ) @ #t2)
                           ∧
                            (#vr.20 < #t2) ∧
                            (#t2 < #vr.40) ∧
                            (∀ #t0 pp. (Unlock( pp, ~n.5, L_h1 ) @ #t0) ⇒ #t0 = #t2) ∧
                            (∀ pp lpp #t0.
                              (Lock( pp, lpp, L_h1 ) @ #t0)
                             ⇒
                              ((#t0 < #vr.20) ∨ (#t0 = #vr.20) ∨ (#t2 < #t0))) ∧
                            (∀ pp lpp #t0.
                              (Unlock( pp, lpp, L_h1 ) @ #t0)
                             ⇒
                              ((#t0 < #vr.20) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                         (#vr.40 < #vr.20) )
                    case case_1
                    solve( State_11211111111( L_h1, L_h2.1, v1, v2, ~n.5 ) ▶₀ #t2.2 )
                      case outsenckeyvkeyv_0_1121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_11111121111111( L_h1, v, ~n.4 ) ▶₀ #t2.2 )
                      case eventWrapHandleLh_0_1111112111111
                      solve( (#t2.4 < #t2.5)  ∥ (#t2.4 = #t2.5) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        solve( Insert( L_h2, <z, 'init'> ) @ #t2.3 )
                          case insertLhkinit_0_111111111111
                          solve( State_111111111111( L_h2, z, lock ) ▶₀ #t2.3 )
                            case eventNewKeyLhk_0_11111111111
                            solve( (#vr.14, 0) ~~> (#j, 0) )
                              case Var_fresh_4_n
                              by contradiction /* from formulas */
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              next
                case insertLhmwrap_0_121111111
                solve( State_121111111( L_h, L_h1, k, z.1, v, lock ) ▶₀ #t2.1 )
                  case eventUnwrappedLhm_0_12111111
                  solve( ((∃ h1 #t1. (NewKey( h1, z.1 ) @ #t1) ∧ #t1 < #vr.37) ∧
                          (∃ hp #t0.
                            (WrapKey( hp, z.1 ) @ #t0)
                           ∧
                            (((#t0 = #vr.37) ∨ (#t0 < #vr.37))) ∧
                            (∀ hpp #t1. (Unwrapped( hpp, z.1 ) @ #t1) ⇒ #t0 < #t1)))  ∥
                         (∃ h k2 #t1 #t0.
                           (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                          ∧
                           (#t1 < #vr.37) ∧ (#t0 < #vr.37))  ∥
                         (∃ #t0 #t1 h1 h2 k.
                           (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                          ∧
                           (#t0 < #vr.37) ∧ (#t1 < #vr.37))  ∥
                         (∃ #t0 #t1 h1 h2 k.
                           (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                          ∧
                           (#t0 < #vr.37) ∧ (#t1 < #vr.37)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  next
                    case case_3
                    solve( ((#t1.1 < #t0) ∧ (#t0.1 < #t0))  ∥
                           ((#t1.1 < #t1) ∧ (#t0.1 < #t1)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case case_4
                    solve( ((∃ h1 #t1. (NewKey( h1, k.2 ) @ #t1) ∧ #t1 < #t0) ∧
                            (∃ hp #t0.1.
                              (WrapKey( hp, k.2 ) @ #t0.1)
                             ∧
                              (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                              (∀ hpp #t1. (Unwrapped( hpp, k.2 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                           (∃ h k2 #t1 #t0.1.
                             (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                            ∧
                             (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                           (∃ #t0.1 #t1 h1 h2 k.
                             (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                            ∧
                             (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                           (∃ #t0.1 #t1 h1 h2 k.
                             (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                            ∧
                             (#t0.1 < #t0) ∧ (#t1 < #t0)) )
                      case case_1
                      solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                             ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    next
                      case case_3
                      solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                             ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    next
                      case case_4
                      solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                             ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  qed
                qed
              qed
            qed
          next
            case insertLhmwrap_0_121111111
            solve( State_121111111( L_h, L_h2, k, z, v, lock ) ▶₀ #t2 )
              case eventUnwrappedLhm_0_12111111
              solve( ((∃ h1 #t1. (NewKey( h1, z ) @ #t1) ∧ #t1 < #vr.25) ∧
                      (∃ hp #t0.
                        (WrapKey( hp, z ) @ #t0)
                       ∧
                        (((#t0 = #vr.25) ∨ (#t0 < #vr.25))) ∧
                        (∀ hpp #t1. (Unwrapped( hpp, z ) @ #t1) ⇒ #t0 < #t1)))  ∥
                     (∃ h k2 #t1 #t0.
                       (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
                      ∧
                       (#t1 < #vr.25) ∧ (#t0 < #vr.25))  ∥
                     (∃ #t0 #t1 h1 h2 k.
                       (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0 < #vr.25) ∧ (#t1 < #vr.25))  ∥
                     (∃ #t0 #t1 h1 h2 k.
                       (Unwrapped( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
                      ∧
                       (#t0 < #vr.25) ∧ (#t1 < #vr.25)) )
                case case_1
                solve( State_11111111111( h1, z, lock ) ▶₀ #t1 )
                  case newk_0_1111111111
                  solve( (#vr.14, 0) ~~> (#j, 0) )
                    case Var_fresh_3_n
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                solve( ((#t1.1 < #t0) ∧ (#t0.1 < #t0))  ∥
                       ((#t1.1 < #t1) ∧ (#t0.1 < #t1)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_4
                solve( ((∃ h1 #t1. (NewKey( h1, k.2 ) @ #t1) ∧ #t1 < #t0) ∧
                        (∃ hp #t0.1.
                          (WrapKey( hp, k.2 ) @ #t0.1)
                         ∧
                          (((#t0.1 = #t0) ∨ (#t0.1 < #t0))) ∧
                          (∀ hpp #t1. (Unwrapped( hpp, k.2 ) @ #t1) ⇒ #t0.1 < #t1)))  ∥
                       (∃ h k2 #t1 #t0.1.
                         (NewKey( h, k2 ) @ #t0.1) ∧ (!KU( k2 ) @ #t1)
                        ∧
                         (#t1 < #t0) ∧ (#t0.1 < #t0))  ∥
                       (∃ #t0.1 #t1 h1 h2 k.
                         (WrapKey( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (#t0.1 < #t0) ∧ (#t1 < #t0))  ∥
                       (∃ #t0.1 #t1 h1 h2 k.
                         (Unwrapped( h2, k ) @ #t0.1) ∧ (DecKey( h1, k ) @ #t1)
                        ∧
                         (#t0.1 < #t0) ∧ (#t1 < #t0)) )
                  case case_1
                  solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                         ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                         ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_4
                  solve( ((#t1.2 < #t0) ∧ (#t0.1 < #t0))  ∥
                         ((#t1.2 < #t1) ∧ (#t0.1 < #t1)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_3
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_4
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_5
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_3( '3', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_4( '4', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_8
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_5( '5', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_9
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_6( '6', ~n, x ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma cannot_obtain_key:
  all-traces "¬(∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (K( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (K( k ) @ #j)"
*/
simplify
by contradiction /* from formulas */

rule (modulo E) Init[color=#ffffff, process="!"]:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_[color=#ffffff, process="!"]:
   [ State_( ) ] --> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_[color=#ffffff, process="!"]:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1[color=#ffffff, process="|"]:
   [ State_1( ) ] --> [ State_11( ), State_12( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11[color=#ffffff, process="|"]:
   [ State_11( ) ] --> [ State_111( ), State_112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111[color=#ffffff, process="|"]:
   [ State_111( ) ] --> [ State_1111( ), State_1112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111[color=#ffffff, process="|"]:
   [ State_1111( ) ] --> [ State_11111( ), State_11112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11111[color=#ffffff, process="|"]:
   [ State_11111( ) ] --> [ State_111111( ), State_111112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111111[color=#ffffff, process="|"]:
   [ State_111111( ) ] --> [ State_1111111( ), State_1111112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) increate_0_1111111[color=#ffffff,
                                   process="in('create');"]:
   [ State_1111111( ), In( 'create' ) ] --> [ State_11111111( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newLh_0_11111111[color=#ffffff, process="new L_h;"]:
   [ State_11111111( ), Fr( L_h ) ] --> [ State_111111111( L_h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_111111111[color=#ffffff, process="lock L_h;"]:
   [ State_111111111( L_h ), Fr( lock ) ]
  --[ Lock_0( '0', lock, L_h ), Lock( '0', lock, L_h ) ]->
   [ State_1111111111( L_h, lock ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newk_0_1111111111[color=#ffffff, process="new k;"]:
   [ State_1111111111( L_h, lock ), Fr( k ) ]
  -->
   [ State_11111111111( L_h, k, lock ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventNewKeyLhk_0_11111111111[color=#ffffff,
                                             process="event NewKey( L_h, k );"]:
   [ State_11111111111( L_h, k, lock ) ]
  --[ NewKey( L_h, k ) ]->
   [ State_111111111111( L_h, k, lock ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insertLhkinit_0_111111111111[color=#ffffff,
                                             process="insert L_h,<k, 'init'>;"]:
   [ State_111111111111( L_h, k, lock ) ]
  --[ Insert( L_h, <k, 'init'> ) ]->
   [ State_1111111111111( L_h, k, lock ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) outLh_0_1111111111111[color=#ffffff,
                                      process="out(L_h);"]:
   [ State_1111111111111( L_h, k, lock ) ]
  -->
   [ State_11111111111111( L_h, k, lock ), Out( L_h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlockLh_0_11111111111111[color=#ffffff,
                                          process="unlock L_h;"]:
   [ State_11111111111111( L_h, k, lock ) ]
  --[ Unlock_0( '0', lock, L_h ), Unlock( '0', lock, L_h ) ]->
   [ State_111111111111111( L_h, k, lock ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111111111111111[color=#ffffff, process="0"]:
   [ State_111111111111111( L_h, k, lock ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) insetwrapLh_0_1111112[color=#ffffff,
                                      process="in(<'set_wrap', L_h>);"]:
   [ State_1111112( ), In( <'set_wrap', L_h> ) ]
  -->
   [ State_11111121( L_h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_11111121[color=#ffffff, process="lock L_h;"]:
   [ State_11111121( L_h ), Fr( lock.1 ) ]
  --[ Lock_1( '1', lock.1, L_h ), Lock( '1', lock.1, L_h ) ]->
   [ State_111111211( L_h, lock.1 ) ]

  /*
  rule (modulo AC) lockLh_0_11111121[color=#ffffff, process="lock L_h;"]:
     [ State_11111121( L_h ), Fr( lock ) ]
    --[ Lock_1( '1', lock, L_h ), Lock( '1', lock, L_h ) ]->
     [ State_111111211( L_h, lock ) ]
  */

rule (modulo E) lookupLhasv_0_111111211[color=#ffffff,
                                        process="lookup L_h as v"]:
   [ State_111111211( L_h, lock.1 ) ]
  --[ IsIn( L_h, v ) ]->
   [ State_1111112111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_111111211[color=#ffffff,
                                           process="lookup L_h as v"]:
     [ State_111111211( L_h, lock ) ]
    --[ IsIn( L_h, v ) ]->
     [ State_1111112111( L_h, v, lock ) ]
  */

rule (modulo E) lookupLhasv_1_111111211[color=#ffffff,
                                        process="lookup L_h as v"]:
   [ State_111111211( L_h, lock.1 ) ]
  --[ IsNotSet( L_h ) ]->
   [ State_1111112112( L_h, lock.1 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_111111211[color=#ffffff,
                                           process="lookup L_h as v"]:
     [ State_111111211( L_h, lock ) ]
    --[ IsNotSet( L_h ) ]->
     [ State_1111112112( L_h, lock ) ]
  */

rule (modulo E) ifattvinit_0_1111112111[color=#ffffff,
                                        process="if att(v)='init'"]:
   [ State_1111112111( L_h, v, lock.1 ) ]
  --[ Pred_Eq( att(v), 'init' ) ]->
   [ State_11111121111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) ifattvinit_0_1111112111[color=#ffffff,
                                           process="if att(v)='init'"]:
     [ State_1111112111( L_h, v, lock ) ]
    --[ Pred_Eq( z, 'init' ) ]->
     [ State_11111121111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = att(v.7)
    
    2. v     = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) ifattvinit_1_1111112111[color=#ffffff,
                                        process="if att(v)='init'"]:
   [ State_1111112111( L_h, v, lock.1 ) ]
  --[ Pred_Not_Eq( att(v), 'init' ) ]->
   [ State_11111121112( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) ifattvinit_1_1111112111[color=#ffffff,
                                           process="if att(v)='init'"]:
     [ State_1111112111( L_h, v, lock ) ]
    --[ Pred_Not_Eq( z, 'init' ) ]->
     [ State_11111121112( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = att(v.7)
    
    2. v     = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) eventWrapKeyLhkeyv_0_11111121111[color=#ffffff,
                                                 process="event WrapKey( L_h, key(v) );"]:
   [ State_11111121111( L_h, v, lock.1 ) ]
  --[ WrapKey( L_h, key(v) ) ]->
   [ State_111111211111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) eventWrapKeyLhkeyv_0_11111121111[color=#ffffff,
                                                    process="event WrapKey( L_h, key(v) );"]:
     [ State_11111121111( L_h, v, lock ) ]
    --[ WrapKey( L_h, z ) ]->
     [ State_111111211111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = key(v.6)
    
    2. v     = <x.6, x.7>
       z     = x.6
  */

rule (modulo E) insertLhkeyvwrap_0_111111211111[color=#ffffff,
                                                process="insert L_h,<key(v), 'wrap'>;"]:
   [ State_111111211111( L_h, v, lock.1 ) ]
  --[ Insert( L_h, <key(v), 'wrap'> ) ]->
   [ State_1111112111111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) insertLhkeyvwrap_0_111111211111[color=#ffffff,
                                                   process="insert L_h,<key(v), 'wrap'>;"]:
     [ State_111111211111( L_h, v, lock ) ]
    --[ Insert( L_h, <z, 'wrap'> ) ]->
     [ State_1111112111111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <z.8, x.10>
       z     = z.8
  */

rule (modulo E) eventWrapHandleLh_0_1111112111111[color=#ffffff,
                                                  process="event WrapHandle( L_h );"]:
   [ State_1111112111111( L_h, v, lock.1 ) ]
  --[ WrapHandle( L_h ) ]->
   [ State_11111121111111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) eventWrapHandleLh_0_1111112111111[color=#ffffff,
                                                     process="event WrapHandle( L_h );"]:
     [ State_1111112111111( L_h, v, lock ) ]
    --[ WrapHandle( L_h ) ]->
     [ State_11111121111111( L_h, v, lock ) ]
  */

rule (modulo E) unlockLh_0_11111121111111[color=#ffffff,
                                          process="unlock L_h;"]:
   [ State_11111121111111( L_h, v, lock.1 ) ]
  --[ Unlock_1( '1', lock.1, L_h ), Unlock( '1', lock.1, L_h ) ]->
   [ State_111111211111111( L_h, v, lock.1 ) ]

  /*
  rule (modulo AC) unlockLh_0_11111121111111[color=#ffffff,
                                             process="unlock L_h;"]:
     [ State_11111121111111( L_h, v, lock ) ]
    --[ Unlock_1( '1', lock, L_h ), Unlock( '1', lock, L_h ) ]->
     [ State_111111211111111( L_h, v, lock ) ]
  */

rule (modulo E) p_0_111111211111111[color=#ffffff, process="0"]:
   [ State_111111211111111( L_h, v, lock.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111111211111111[color=#ffffff, process="0"]:
     [ State_111111211111111( L_h, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_11111121112[color=#ffffff, process="0"]:
   [ State_11111121112( L_h, v, lock.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11111121112[color=#ffffff, process="0"]:
     [ State_11111121112( L_h, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1111112112[color=#ffffff, process="0"]:
   [ State_1111112112( L_h, lock.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111112112[color=#ffffff, process="0"]:
     [ State_1111112112( L_h, lock ) ] --> [ ]
  */

rule (modulo E) insetdecLh_0_111112[color=#ffffff,
                                    process="in(<'set_dec', L_h>);"]:
   [ State_111112( ), In( <'set_dec', L_h> ) ] --> [ State_1111121( L_h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_1111121[color=#ffffff, process="lock L_h;"]:
   [ State_1111121( L_h ), Fr( lock.2 ) ]
  --[ Lock_2( '2', lock.2, L_h ), Lock( '2', lock.2, L_h ) ]->
   [ State_11111211( L_h, lock.2 ) ]

  /*
  rule (modulo AC) lockLh_0_1111121[color=#ffffff, process="lock L_h;"]:
     [ State_1111121( L_h ), Fr( lock ) ]
    --[ Lock_2( '2', lock, L_h ), Lock( '2', lock, L_h ) ]->
     [ State_11111211( L_h, lock ) ]
  */

rule (modulo E) lookupLhasv_0_11111211[color=#ffffff,
                                       process="lookup L_h as v"]:
   [ State_11111211( L_h, lock.2 ) ]
  --[ IsIn( L_h, v ) ]->
   [ State_111112111( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_11111211[color=#ffffff,
                                          process="lookup L_h as v"]:
     [ State_11111211( L_h, lock ) ]
    --[ IsIn( L_h, v ) ]->
     [ State_111112111( L_h, v, lock ) ]
  */

rule (modulo E) lookupLhasv_1_11111211[color=#ffffff,
                                       process="lookup L_h as v"]:
   [ State_11111211( L_h, lock.2 ) ]
  --[ IsNotSet( L_h ) ]->
   [ State_111112112( L_h, lock.2 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_11111211[color=#ffffff,
                                          process="lookup L_h as v"]:
     [ State_11111211( L_h, lock ) ]
    --[ IsNotSet( L_h ) ]->
     [ State_111112112( L_h, lock ) ]
  */

rule (modulo E) ifattvinit_0_111112111[color=#ffffff,
                                       process="if att(v)='init'"]:
   [ State_111112111( L_h, v, lock.2 ) ]
  --[ Pred_Eq( att(v), 'init' ) ]->
   [ State_1111121111( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) ifattvinit_0_111112111[color=#ffffff,
                                          process="if att(v)='init'"]:
     [ State_111112111( L_h, v, lock ) ]
    --[ Pred_Eq( z, 'init' ) ]->
     [ State_1111121111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) ifattvinit_1_111112111[color=#ffffff,
                                       process="if att(v)='init'"]:
   [ State_111112111( L_h, v, lock.2 ) ]
  --[ Pred_Not_Eq( att(v), 'init' ) ]->
   [ State_1111121112( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) ifattvinit_1_111112111[color=#ffffff,
                                          process="if att(v)='init'"]:
     [ State_111112111( L_h, v, lock ) ]
    --[ Pred_Not_Eq( z, 'init' ) ]->
     [ State_1111121112( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) eventDecKeyLhkeyv_0_1111121111[color=#ffffff,
                                               process="event DecKey( L_h, key(v) );"]:
   [ State_1111121111( L_h, v, lock.2 ) ]
  --[ DecKey( L_h, key(v) ) ]->
   [ State_11111211111( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) eventDecKeyLhkeyv_0_1111121111[color=#ffffff,
                                                  process="event DecKey( L_h, key(v) );"]:
     [ State_1111121111( L_h, v, lock ) ]
    --[ DecKey( L_h, z ) ]->
     [ State_11111211111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <x.7, x.8>
       z     = x.7
  */

rule (modulo E) insertLhkeyvdec_0_11111211111[color=#ffffff,
                                              process="insert L_h,<key(v), 'dec'>;"]:
   [ State_11111211111( L_h, v, lock.2 ) ]
  --[ Insert( L_h, <key(v), 'dec'> ) ]->
   [ State_111112111111( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) insertLhkeyvdec_0_11111211111[color=#ffffff,
                                                 process="insert L_h,<key(v), 'dec'>;"]:
     [ State_11111211111( L_h, v, lock ) ]
    --[ Insert( L_h, <z, 'dec'> ) ]->
     [ State_111112111111( L_h, v, lock ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = key(v.8)
    
    2. v     = <z.9, x.11>
       z     = z.9
  */

rule (modulo E) unlockLh_0_111112111111[color=#ffffff,
                                        process="unlock L_h;"]:
   [ State_111112111111( L_h, v, lock.2 ) ]
  --[ Unlock_2( '2', lock.2, L_h ), Unlock( '2', lock.2, L_h ) ]->
   [ State_1111121111111( L_h, v, lock.2 ) ]

  /*
  rule (modulo AC) unlockLh_0_111112111111[color=#ffffff,
                                           process="unlock L_h;"]:
     [ State_111112111111( L_h, v, lock ) ]
    --[ Unlock_2( '2', lock, L_h ), Unlock( '2', lock, L_h ) ]->
     [ State_1111121111111( L_h, v, lock ) ]
  */

rule (modulo E) p_0_1111121111111[color=#ffffff, process="0"]:
   [ State_1111121111111( L_h, v, lock.2 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111121111111[color=#ffffff, process="0"]:
     [ State_1111121111111( L_h, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1111121112[color=#ffffff, process="0"]:
   [ State_1111121112( L_h, v, lock.2 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111121112[color=#ffffff, process="0"]:
     [ State_1111121112( L_h, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_111112112[color=#ffffff, process="0"]:
   [ State_111112112( L_h, lock.2 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111112112[color=#ffffff, process="0"]:
     [ State_111112112( L_h, lock ) ] --> [ ]
  */

rule (modulo E) inLhc_0_11112[color=#ffffff, process="in(<L_h, c>);"]:
   [ State_11112( ), In( <L_h, c> ) ] --> [ State_111121( L_h, c ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_111121[color=#ffffff, process="lock L_h;"]:
   [ State_111121( L_h, c ), Fr( lock.3 ) ]
  --[ Lock_3( '3', lock.3, L_h ), Lock( '3', lock.3, L_h ) ]->
   [ State_1111211( L_h, c, lock.3 ) ]

  /*
  rule (modulo AC) lockLh_0_111121[color=#ffffff, process="lock L_h;"]:
     [ State_111121( L_h, c ), Fr( lock ) ]
    --[ Lock_3( '3', lock, L_h ), Lock( '3', lock, L_h ) ]->
     [ State_1111211( L_h, c, lock ) ]
  */

rule (modulo E) lookupLhasv_0_1111211[color=#ffffff,
                                      process="lookup L_h as v"]:
   [ State_1111211( L_h, c, lock.3 ) ]
  --[ IsIn( L_h, v ) ]->
   [ State_11112111( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_1111211[color=#ffffff,
                                         process="lookup L_h as v"]:
     [ State_1111211( L_h, c, lock ) ]
    --[ IsIn( L_h, v ) ]->
     [ State_11112111( L_h, c, v, lock ) ]
  */

rule (modulo E) lookupLhasv_1_1111211[color=#ffffff,
                                      process="lookup L_h as v"]:
   [ State_1111211( L_h, c, lock.3 ) ]
  --[ IsNotSet( L_h ) ]->
   [ State_11112112( L_h, c, lock.3 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_1111211[color=#ffffff,
                                         process="lookup L_h as v"]:
     [ State_1111211( L_h, c, lock ) ]
    --[ IsNotSet( L_h ) ]->
     [ State_11112112( L_h, c, lock ) ]
  */

rule (modulo E) ifattvdec_0_11112111[color=#ffffff,
                                     process="if att(v)='dec'"]:
   [ State_11112111( L_h, c, v, lock.3 ) ]
  --[ Pred_Eq( att(v), 'dec' ) ]->
   [ State_111121111( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) ifattvdec_0_11112111[color=#ffffff,
                                        process="if att(v)='dec'"]:
     [ State_11112111( L_h, c, v, lock ) ]
    --[ Pred_Eq( z, 'dec' ) ]->
     [ State_111121111( L_h, c, v, lock ) ]
    variants (modulo AC)
    1. v     = v.10
       z     = att(v.10)
    
    2. v     = <x.12, z.11>
       z     = z.11
  */

rule (modulo E) ifattvdec_1_11112111[color=#ffffff,
                                     process="if att(v)='dec'"]:
   [ State_11112111( L_h, c, v, lock.3 ) ]
  --[ Pred_Not_Eq( att(v), 'dec' ) ]->
   [ State_111121112( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) ifattvdec_1_11112111[color=#ffffff,
                                        process="if att(v)='dec'"]:
     [ State_11112111( L_h, c, v, lock ) ]
    --[ Pred_Not_Eq( z, 'dec' ) ]->
     [ State_111121112( L_h, c, v, lock ) ]
    variants (modulo AC)
    1. v     = v.10
       z     = att(v.10)
    
    2. v     = <x.12, z.11>
       z     = z.11
  */

rule (modulo E) ifsencSuccckeyvtrue_0_111121111[color=#ffffff,
                                                process="if sencSucc(c, key(v))=true"]:
   [ State_111121111( L_h, c, v, lock.3 ) ]
  --[ Pred_Eq( sencSucc(c, key(v)), true ) ]->
   [ State_1111211111( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) ifsencSuccckeyvtrue_0_111121111[color=#ffffff,
                                                   process="if sencSucc(c, key(v))=true"]:
     [ State_111121111( L_h, c, v, lock ) ]
    --[ Pred_Eq( z, true ) ]->
     [ State_1111211111( L_h, c, v, lock ) ]
    variants (modulo AC)
    1. c     = c.9
       v     = v.9
       z     = sencSucc(c.9, key(v.9))
    
    2. c     = c.11
       v     = <x.9, x.10>
       z     = sencSucc(c.11, x.9)
    
    3. c     = senc(x.9, x.10)
       v     = <x.10, x.11>
       z     = true
    
    4. c     = senc(x.9, key(x.10))
       v     = x.10
       z     = true
  */

rule (modulo E) ifsencSuccckeyvtrue_1_111121111[color=#ffffff,
                                                process="if sencSucc(c, key(v))=true"]:
   [ State_111121111( L_h, c, v, lock.3 ) ]
  --[ Pred_Not_Eq( sencSucc(c, key(v)), true ) ]->
   [ State_1111211112( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) ifsencSuccckeyvtrue_1_111121111[color=#ffffff,
                                                   process="if sencSucc(c, key(v))=true"]:
     [ State_111121111( L_h, c, v, lock ) ]
    --[ Pred_Not_Eq( z, true ) ]->
     [ State_1111211112( L_h, c, v, lock ) ]
    variants (modulo AC)
    1. c     = c.9
       v     = v.9
       z     = sencSucc(c.9, key(v.9))
    
    2. c     = c.11
       v     = <x.9, x.10>
       z     = sencSucc(c.11, x.9)
    
    3. c     = senc(x.9, x.10)
       v     = <x.10, x.11>
       z     = true
    
    4. c     = senc(x.9, key(x.10))
       v     = x.10
       z     = true
  */

rule (modulo E) eventDecUsingkeyvsdecckeyv_0_1111211111[color=#ffffff,
                                                        process="event DecUsing( key(v), sdec(c, key(v)) );"]:
   [ State_1111211111( L_h, c, v, lock.3 ) ]
  --[ DecUsing( key(v), sdec(c, key(v)) ) ]->
   [ State_11112111111( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) eventDecUsingkeyvsdecckeyv_0_1111211111[color=#ffffff,
                                                           process="event DecUsing( key(v), sdec(c, key(v)) );"]:
     [ State_1111211111( L_h, c, v, lock ) ]
    --[ DecUsing( z, z.1 ) ]->
     [ State_11112111111( L_h, c, v, lock ) ]
    variants (modulo AC)
    1. c     = c.10
       v     = v.10
       z     = key(v.10)
       z.1   = sdec(c.10, key(v.10))
    
    2. c     = c.12
       v     = <x.10, x.11>
       z     = x.10
       z.1   = sdec(c.12, x.10)
    
    3. c     = senc(x.10, x.11)
       v     = <x.11, x.12>
       z     = x.11
       z.1   = x.10
    
    4. c     = senc(x.10, key(x.11))
       v     = x.11
       z     = key(x.11)
       z.1   = x.10
  */

rule (modulo E) outsdecckeyv_0_11112111111[color=#ffffff,
                                           process="out(sdec(c, key(v)));"]:
   [ State_11112111111( L_h, c, v, lock.3 ) ]
  -->
   [ State_111121111111( L_h, c, v, lock.3 ), Out( sdec(c, key(v)) ) ]

  /*
  rule (modulo AC) outsdecckeyv_0_11112111111[color=#ffffff,
                                              process="out(sdec(c, key(v)));"]:
     [ State_11112111111( L_h, c, v, lock ) ]
    -->
     [ State_111121111111( L_h, c, v, lock ), Out( z ) ]
    variants (modulo AC)
    1. c     = c.9
       v     = v.9
       z     = sdec(c.9, key(v.9))
    
    2. c     = c.11
       v     = <x.9, x.10>
       z     = sdec(c.11, x.9)
    
    3. c     = senc(x.9, x.10)
       v     = <x.10, x.11>
       z     = x.9
    
    4. c     = senc(x.9, key(x.10))
       v     = x.10
       z     = x.9
  */

rule (modulo E) unlockLh_0_111121111111[color=#ffffff,
                                        process="unlock L_h;"]:
   [ State_111121111111( L_h, c, v, lock.3 ) ]
  --[ Unlock_3( '3', lock.3, L_h ), Unlock( '3', lock.3, L_h ) ]->
   [ State_1111211111111( L_h, c, v, lock.3 ) ]

  /*
  rule (modulo AC) unlockLh_0_111121111111[color=#ffffff,
                                           process="unlock L_h;"]:
     [ State_111121111111( L_h, c, v, lock ) ]
    --[ Unlock_3( '3', lock, L_h ), Unlock( '3', lock, L_h ) ]->
     [ State_1111211111111( L_h, c, v, lock ) ]
  */

rule (modulo E) p_0_1111211111111[color=#ffffff, process="0"]:
   [ State_1111211111111( L_h, c, v, lock.3 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111211111111[color=#ffffff, process="0"]:
     [ State_1111211111111( L_h, c, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1111211112[color=#ffffff, process="0"]:
   [ State_1111211112( L_h, c, v, lock.3 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1111211112[color=#ffffff, process="0"]:
     [ State_1111211112( L_h, c, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_111121112[color=#ffffff, process="0"]:
   [ State_111121112( L_h, c, v, lock.3 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_111121112[color=#ffffff, process="0"]:
     [ State_111121112( L_h, c, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_11112112[color=#ffffff, process="0"]:
   [ State_11112112( L_h, c, lock.3 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11112112[color=#ffffff, process="0"]:
     [ State_11112112( L_h, c, lock ) ] --> [ ]
  */

rule (modulo E) inLhm_0_1112[color=#ffffff, process="in(<L_h, m>);"]:
   [ State_1112( ), In( <L_h, m> ) ] --> [ State_11121( L_h, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_11121[color=#ffffff, process="lock L_h;"]:
   [ State_11121( L_h, m ), Fr( lock.4 ) ]
  --[ Lock_4( '4', lock.4, L_h ), Lock( '4', lock.4, L_h ) ]->
   [ State_111211( L_h, m, lock.4 ) ]

  /*
  rule (modulo AC) lockLh_0_11121[color=#ffffff, process="lock L_h;"]:
     [ State_11121( L_h, m ), Fr( lock ) ]
    --[ Lock_4( '4', lock, L_h ), Lock( '4', lock, L_h ) ]->
     [ State_111211( L_h, m, lock ) ]
  */

rule (modulo E) lookupLhasv_0_111211[color=#ffffff,
                                     process="lookup L_h as v"]:
   [ State_111211( L_h, m, lock.4 ) ]
  --[ IsIn( L_h, v ) ]->
   [ State_1112111( L_h, m, v, lock.4 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_111211[color=#ffffff,
                                        process="lookup L_h as v"]:
     [ State_111211( L_h, m, lock ) ]
    --[ IsIn( L_h, v ) ]->
     [ State_1112111( L_h, m, v, lock ) ]
  */

rule (modulo E) lookupLhasv_1_111211[color=#ffffff,
                                     process="lookup L_h as v"]:
   [ State_111211( L_h, m, lock.4 ) ]
  --[ IsNotSet( L_h ) ]->
   [ State_1112112( L_h, m, lock.4 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_111211[color=#ffffff,
                                        process="lookup L_h as v"]:
     [ State_111211( L_h, m, lock ) ]
    --[ IsNotSet( L_h ) ]->
     [ State_1112112( L_h, m, lock ) ]
  */

rule (modulo E) ifattvdec_0_1112111[color=#ffffff,
                                    process="if att(v)='dec'"]:
   [ State_1112111( L_h, m, v, lock.4 ) ]
  --[ Pred_Eq( att(v), 'dec' ) ]->
   [ State_11121111( L_h, m, v, lock.4 ) ]

  /*
  rule (modulo AC) ifattvdec_0_1112111[color=#ffffff,
                                       process="if att(v)='dec'"]:
     [ State_1112111( L_h, m, v, lock ) ]
    --[ Pred_Eq( z, 'dec' ) ]->
     [ State_11121111( L_h, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.11
       z     = att(v.11)
    
    2. v     = <x.13, z.12>
       z     = z.12
  */

rule (modulo E) ifattvdec_1_1112111[color=#ffffff,
                                    process="if att(v)='dec'"]:
   [ State_1112111( L_h, m, v, lock.4 ) ]
  --[ Pred_Not_Eq( att(v), 'dec' ) ]->
   [ State_11121112( L_h, m, v, lock.4 ) ]

  /*
  rule (modulo AC) ifattvdec_1_1112111[color=#ffffff,
                                       process="if att(v)='dec'"]:
     [ State_1112111( L_h, m, v, lock ) ]
    --[ Pred_Not_Eq( z, 'dec' ) ]->
     [ State_11121112( L_h, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.11
       z     = att(v.11)
    
    2. v     = <x.13, z.12>
       z     = z.12
  */

rule (modulo E) eventEncUsingkeyvm_0_11121111[color=#ffffff,
                                              process="event EncUsing( key(v), m );"]:
   [ State_11121111( L_h, m, v, lock.4 ) ]
  --[ EncUsing( key(v), m ) ]->
   [ State_111211111( L_h, m, v, lock.4 ) ]

  /*
  rule (modulo AC) eventEncUsingkeyvm_0_11121111[color=#ffffff,
                                                 process="event EncUsing( key(v), m );"]:
     [ State_11121111( L_h, m, v, lock ) ]
    --[ EncUsing( z, m ) ]->
     [ State_111211111( L_h, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.10
       z     = key(v.10)
    
    2. v     = <x.10, x.11>
       z     = x.10
  */

rule (modulo E) outsencmkeyv_0_111211111[color=#ffffff,
                                         process="out(senc(m, key(v)));"]:
   [ State_111211111( L_h, m, v, lock.4 ) ]
  -->
   [ State_1112111111( L_h, m, v, lock.4 ), Out( senc(m, key(v)) ) ]

  /*
  rule (modulo AC) outsencmkeyv_0_111211111[color=#ffffff,
                                            process="out(senc(m, key(v)));"]:
     [ State_111211111( L_h, m, v, lock ) ]
    -->
     [ State_1112111111( L_h, m, v, lock ), Out( senc(m, z) ) ]
    variants (modulo AC)
    1. v     = v.10
       z     = key(v.10)
    
    2. v     = <x.10, x.11>
       z     = x.10
  */

rule (modulo E) unlockLh_0_1112111111[color=#ffffff,
                                      process="unlock L_h;"]:
   [ State_1112111111( L_h, m, v, lock.4 ) ]
  --[ Unlock_4( '4', lock.4, L_h ), Unlock( '4', lock.4, L_h ) ]->
   [ State_11121111111( L_h, m, v, lock.4 ) ]

  /*
  rule (modulo AC) unlockLh_0_1112111111[color=#ffffff,
                                         process="unlock L_h;"]:
     [ State_1112111111( L_h, m, v, lock ) ]
    --[ Unlock_4( '4', lock, L_h ), Unlock( '4', lock, L_h ) ]->
     [ State_11121111111( L_h, m, v, lock ) ]
  */

rule (modulo E) p_0_11121111111[color=#ffffff, process="0"]:
   [ State_11121111111( L_h, m, v, lock.4 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11121111111[color=#ffffff, process="0"]:
     [ State_11121111111( L_h, m, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_11121112[color=#ffffff, process="0"]:
   [ State_11121112( L_h, m, v, lock.4 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11121112[color=#ffffff, process="0"]:
     [ State_11121112( L_h, m, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1112112[color=#ffffff, process="0"]:
   [ State_1112112( L_h, m, lock.4 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1112112[color=#ffffff, process="0"]:
     [ State_1112112( L_h, m, lock ) ] --> [ ]
  */

rule (modulo E) inLhLh_0_112[color=#ffffff, process="in(<L_h1, L_h2>);"]:
   [ State_112( ), In( <L_h1, L_h2> ) ] --> [ State_1121( L_h1, L_h2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_1121[color=#ffffff, process="lock L_h1;"]:
   [ State_1121( L_h1, L_h2 ), Fr( lock.5 ) ]
  --[ Lock_5( '5', lock.5, L_h1 ), Lock( '5', lock.5, L_h1 ) ]->
   [ State_11211( L_h1, L_h2, lock.5 ) ]

  /*
  rule (modulo AC) lockLh_0_1121[color=#ffffff, process="lock L_h1;"]:
     [ State_1121( L_h1, L_h2 ), Fr( lock ) ]
    --[ Lock_5( '5', lock, L_h1 ), Lock( '5', lock, L_h1 ) ]->
     [ State_11211( L_h1, L_h2, lock ) ]
  */

rule (modulo E) lookupLhasv_0_11211[color=#ffffff,
                                    process="lookup L_h1 as v1"]:
   [ State_11211( L_h1, L_h2, lock.5 ) ]
  --[ IsIn( L_h1, v1 ) ]->
   [ State_112111( L_h1, L_h2, v1, lock.5 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_11211[color=#ffffff,
                                       process="lookup L_h1 as v1"]:
     [ State_11211( L_h1, L_h2, lock ) ]
    --[ IsIn( L_h1, v1 ) ]->
     [ State_112111( L_h1, L_h2, v1, lock ) ]
  */

rule (modulo E) lookupLhasv_1_11211[color=#ffffff,
                                    process="lookup L_h1 as v1"]:
   [ State_11211( L_h1, L_h2, lock.5 ) ]
  --[ IsNotSet( L_h1 ) ]->
   [ State_112112( L_h1, L_h2, lock.5 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_11211[color=#ffffff,
                                       process="lookup L_h1 as v1"]:
     [ State_11211( L_h1, L_h2, lock ) ]
    --[ IsNotSet( L_h1 ) ]->
     [ State_112112( L_h1, L_h2, lock ) ]
  */

rule (modulo E) ifattvwrap_0_112111[color=#ffffff,
                                    process="if att(v1)='wrap'"]:
   [ State_112111( L_h1, L_h2, v1, lock.5 ) ]
  --[ Pred_Eq( att(v1), 'wrap' ) ]->
   [ State_1121111( L_h1, L_h2, v1, lock.5 ) ]

  /*
  rule (modulo AC) ifattvwrap_0_112111[color=#ffffff,
                                       process="if att(v1)='wrap'"]:
     [ State_112111( L_h1, L_h2, v1, lock ) ]
    --[ Pred_Eq( z, 'wrap' ) ]->
     [ State_1121111( L_h1, L_h2, v1, lock ) ]
    variants (modulo AC)
    1. v1    = v1.12
       z     = att(v1.12)
    
    2. v1    = <x.14, z.13>
       z     = z.13
  */

rule (modulo E) ifattvwrap_1_112111[color=#ffffff,
                                    process="if att(v1)='wrap'"]:
   [ State_112111( L_h1, L_h2, v1, lock.5 ) ]
  --[ Pred_Not_Eq( att(v1), 'wrap' ) ]->
   [ State_1121112( L_h1, L_h2, v1, lock.5 ) ]

  /*
  rule (modulo AC) ifattvwrap_1_112111[color=#ffffff,
                                       process="if att(v1)='wrap'"]:
     [ State_112111( L_h1, L_h2, v1, lock ) ]
    --[ Pred_Not_Eq( z, 'wrap' ) ]->
     [ State_1121112( L_h1, L_h2, v1, lock ) ]
    variants (modulo AC)
    1. v1    = v1.12
       z     = att(v1.12)
    
    2. v1    = <x.14, z.13>
       z     = z.13
  */

rule (modulo E) lookupLhasv_0_1121111[color=#ffffff,
                                      process="lookup L_h2 as v2"]:
   [ State_1121111( L_h1, L_h2, v1, lock.5 ) ]
  --[ IsIn( L_h2, v2 ) ]->
   [ State_11211111( L_h1, L_h2, v1, v2, lock.5 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_1121111[color=#ffffff,
                                         process="lookup L_h2 as v2"]:
     [ State_1121111( L_h1, L_h2, v1, lock ) ]
    --[ IsIn( L_h2, v2 ) ]->
     [ State_11211111( L_h1, L_h2, v1, v2, lock ) ]
  */

rule (modulo E) lookupLhasv_1_1121111[color=#ffffff,
                                      process="lookup L_h2 as v2"]:
   [ State_1121111( L_h1, L_h2, v1, lock.5 ) ]
  --[ IsNotSet( L_h2 ) ]->
   [ State_11211112( L_h1, L_h2, v1, lock.5 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_1121111[color=#ffffff,
                                         process="lookup L_h2 as v2"]:
     [ State_1121111( L_h1, L_h2, v1, lock ) ]
    --[ IsNotSet( L_h2 ) ]->
     [ State_11211112( L_h1, L_h2, v1, lock ) ]
  */

rule (modulo E) ifattvwrap_0_11211111[color=#ffffff,
                                      process="if att(v2)='wrap'"]:
   [ State_11211111( L_h1, L_h2, v1, v2, lock.5 ) ]
  --[ Pred_Eq( att(v2), 'wrap' ) ]->
   [ State_112111111( L_h1, L_h2, v1, v2, lock.5 ) ]

  /*
  rule (modulo AC) ifattvwrap_0_11211111[color=#ffffff,
                                         process="if att(v2)='wrap'"]:
     [ State_11211111( L_h1, L_h2, v1, v2, lock ) ]
    --[ Pred_Eq( z, 'wrap' ) ]->
     [ State_112111111( L_h1, L_h2, v1, v2, lock ) ]
    variants (modulo AC)
    1. v2    = v2.13
       z     = att(v2.13)
    
    2. v2    = <x.15, z.14>
       z     = z.14
  */

rule (modulo E) ifattvwrap_1_11211111[color=#ffffff,
                                      process="if att(v2)='wrap'"]:
   [ State_11211111( L_h1, L_h2, v1, v2, lock.5 ) ]
  --[ Pred_Not_Eq( att(v2), 'wrap' ) ]->
   [ State_112111112( L_h1, L_h2, v1, v2, lock.5 ) ]

  /*
  rule (modulo AC) ifattvwrap_1_11211111[color=#ffffff,
                                         process="if att(v2)='wrap'"]:
     [ State_11211111( L_h1, L_h2, v1, v2, lock ) ]
    --[ Pred_Not_Eq( z, 'wrap' ) ]->
     [ State_112111112( L_h1, L_h2, v1, v2, lock ) ]
    variants (modulo AC)
    1. v2    = v2.13
       z     = att(v2.13)
    
    2. v2    = <x.15, z.14>
       z     = z.14
  */

rule (modulo E) eventWrapkeyvkeyv_0_112111111[color=#ffffff,
                                              process="event Wrap( key(v1), key(v2) );"]:
   [ State_112111111( L_h1, L_h2, v1, v2, lock.5 ) ]
  --[ Wrap( key(v1), key(v2) ) ]->
   [ State_1121111111( L_h1, L_h2, v1, v2, lock.5 ) ]

  /*
  rule (modulo AC) eventWrapkeyvkeyv_0_112111111[color=#ffffff,
                                                 process="event Wrap( key(v1), key(v2) );"]:
     [ State_112111111( L_h1, L_h2, v1, v2, lock ) ]
    --[ Wrap( z, z.1 ) ]->
     [ State_1121111111( L_h1, L_h2, v1, v2, lock ) ]
    variants (modulo AC)
    1. v1    = v1.13
       v2    = v2.13
       z     = key(v1.13)
       z.1   = key(v2.13)
    
    2. v1    = v1.15
       v2    = <x.13, x.14>
       z     = key(v1.15)
       z.1   = x.13
    
    3. v1    = <x.13, x.14>
       v2    = v2.15
       z     = x.13
       z.1   = key(v2.15)
    
    4. v1    = <x.13, x.14>
       v2    = <x.15, x.16>
       z     = x.13
       z.1   = x.15
  */

rule (modulo E) outsenckeyvkeyv_0_1121111111[color=#ffffff,
                                             process="out(senc(key(v2), key(v1)));"]:
   [ State_1121111111( L_h1, L_h2, v1, v2, lock.5 ) ]
  -->
   [
   State_11211111111( L_h1, L_h2, v1, v2, lock.5 ),
   Out( senc(key(v2), key(v1)) )
   ]

  /*
  rule (modulo AC) outsenckeyvkeyv_0_1121111111[color=#ffffff,
                                                process="out(senc(key(v2), key(v1)));"]:
     [ State_1121111111( L_h1, L_h2, v1, v2, lock ) ]
    -->
     [ State_11211111111( L_h1, L_h2, v1, v2, lock ), Out( senc(z, z.1) ) ]
    variants (modulo AC)
    1. v1    = v1.13
       v2    = v2.13
       z     = key(v2.13)
       z.1   = key(v1.13)
    
    2. v1    = v1.15
       v2    = <x.13, x.14>
       z     = x.13
       z.1   = key(v1.15)
    
    3. v1    = <x.13, x.14>
       v2    = v2.15
       z     = key(v2.15)
       z.1   = x.13
    
    4. v1    = <x.13, x.14>
       v2    = <x.15, x.16>
       z     = x.15
       z.1   = x.13
  */

rule (modulo E) unlockLh_0_11211111111[color=#ffffff,
                                       process="unlock L_h1;"]:
   [ State_11211111111( L_h1, L_h2, v1, v2, lock.5 ) ]
  --[ Unlock_5( '5', lock.5, L_h1 ), Unlock( '5', lock.5, L_h1 ) ]->
   [ State_112111111111( L_h1, L_h2, v1, v2, lock.5 ) ]

  /*
  rule (modulo AC) unlockLh_0_11211111111[color=#ffffff,
                                          process="unlock L_h1;"]:
     [ State_11211111111( L_h1, L_h2, v1, v2, lock ) ]
    --[ Unlock_5( '5', lock, L_h1 ), Unlock( '5', lock, L_h1 ) ]->
     [ State_112111111111( L_h1, L_h2, v1, v2, lock ) ]
  */

rule (modulo E) p_0_112111111111[color=#ffffff, process="0"]:
   [ State_112111111111( L_h1, L_h2, v1, v2, lock.5 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_112111111111[color=#ffffff, process="0"]:
     [ State_112111111111( L_h1, L_h2, v1, v2, lock ) ] --> [ ]
  */

rule (modulo E) p_0_112111112[color=#ffffff, process="0"]:
   [ State_112111112( L_h1, L_h2, v1, v2, lock.5 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_112111112[color=#ffffff, process="0"]:
     [ State_112111112( L_h1, L_h2, v1, v2, lock ) ] --> [ ]
  */

rule (modulo E) p_0_11211112[color=#ffffff, process="0"]:
   [ State_11211112( L_h1, L_h2, v1, lock.5 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_11211112[color=#ffffff, process="0"]:
     [ State_11211112( L_h1, L_h2, v1, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1121112[color=#ffffff, process="0"]:
   [ State_1121112( L_h1, L_h2, v1, lock.5 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1121112[color=#ffffff, process="0"]:
     [ State_1121112( L_h1, L_h2, v1, lock ) ] --> [ ]
  */

rule (modulo E) p_0_112112[color=#ffffff, process="0"]:
   [ State_112112( L_h1, L_h2, lock.5 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_112112[color=#ffffff, process="0"]:
     [ State_112112( L_h1, L_h2, lock ) ] --> [ ]
  */

rule (modulo E) inLhsencmk_0_12[color=#ffffff,
                                process="in(<L_h, senc(m, k)>);"]:
   [ State_12( ), In( <L_h, senc(m, k)> ) ] --> [ State_121( L_h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockLh_0_121[color=#ffffff, process="lock L_h;"]:
   [ State_121( L_h, k, m ), Fr( lock.6 ) ]
  --[ Lock_6( '6', lock.6, L_h ), Lock( '6', lock.6, L_h ) ]->
   [ State_1211( L_h, k, m, lock.6 ) ]

  /*
  rule (modulo AC) lockLh_0_121[color=#ffffff, process="lock L_h;"]:
     [ State_121( L_h, k, m ), Fr( lock ) ]
    --[ Lock_6( '6', lock, L_h ), Lock( '6', lock, L_h ) ]->
     [ State_1211( L_h, k, m, lock ) ]
  */

rule (modulo E) lookupLhasv_0_1211[color=#ffffff,
                                   process="lookup L_h as v"]:
   [ State_1211( L_h, k, m, lock.6 ) ]
  --[ IsIn( L_h, v ) ]->
   [ State_12111( L_h, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) lookupLhasv_0_1211[color=#ffffff,
                                      process="lookup L_h as v"]:
     [ State_1211( L_h, k, m, lock ) ]
    --[ IsIn( L_h, v ) ]->
     [ State_12111( L_h, k, m, v, lock ) ]
  */

rule (modulo E) lookupLhasv_1_1211[color=#ffffff,
                                   process="lookup L_h as v"]:
   [ State_1211( L_h, k, m, lock.6 ) ]
  --[ IsNotSet( L_h ) ]->
   [ State_12112( L_h, k, m, lock.6 ) ]

  /*
  rule (modulo AC) lookupLhasv_1_1211[color=#ffffff,
                                      process="lookup L_h as v"]:
     [ State_1211( L_h, k, m, lock ) ]
    --[ IsNotSet( L_h ) ]->
     [ State_12112( L_h, k, m, lock ) ]
  */

rule (modulo E) ifattvwrap_0_12111[color=#ffffff,
                                   process="if att(v)='wrap'"]:
   [ State_12111( L_h, k, m, v, lock.6 ) ]
  --[ Pred_Eq( att(v), 'wrap' ) ]->
   [ State_121111( L_h, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) ifattvwrap_0_12111[color=#ffffff,
                                      process="if att(v)='wrap'"]:
     [ State_12111( L_h, k, m, v, lock ) ]
    --[ Pred_Eq( z, 'wrap' ) ]->
     [ State_121111( L_h, k, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.14
       z     = att(v.14)
    
    2. v     = <x.16, z.15>
       z     = z.15
  */

rule (modulo E) ifattvwrap_1_12111[color=#ffffff,
                                   process="if att(v)='wrap'"]:
   [ State_12111( L_h, k, m, v, lock.6 ) ]
  --[ Pred_Not_Eq( att(v), 'wrap' ) ]->
   [ State_121112( L_h, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) ifattvwrap_1_12111[color=#ffffff,
                                      process="if att(v)='wrap'"]:
     [ State_12111( L_h, k, m, v, lock ) ]
    --[ Pred_Not_Eq( z, 'wrap' ) ]->
     [ State_121112( L_h, k, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.14
       z     = att(v.14)
    
    2. v     = <x.16, z.15>
       z     = z.15
  */

rule (modulo E) ifkeyvk_0_121111[color=#ffffff, process="if key(v)=k"]:
   [ State_121111( L_h, k, m, v, lock.6 ) ]
  --[ Pred_Eq( key(v), k ) ]->
   [ State_1211111( L_h, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) ifkeyvk_0_121111[color=#ffffff, process="if key(v)=k"]:
     [ State_121111( L_h, k, m, v, lock ) ]
    --[ Pred_Eq( z, k ) ]->
     [ State_1211111( L_h, k, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.13
       z     = key(v.13)
    
    2. v     = <x.13, x.14>
       z     = x.13
  */

rule (modulo E) ifkeyvk_1_121111[color=#ffffff, process="if key(v)=k"]:
   [ State_121111( L_h, k, m, v, lock.6 ) ]
  --[ Pred_Not_Eq( key(v), k ) ]->
   [ State_1211112( L_h, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) ifkeyvk_1_121111[color=#ffffff, process="if key(v)=k"]:
     [ State_121111( L_h, k, m, v, lock ) ]
    --[ Pred_Not_Eq( z, k ) ]->
     [ State_1211112( L_h, k, m, v, lock ) ]
    variants (modulo AC)
    1. v     = v.13
       z     = key(v.13)
    
    2. v     = <x.13, x.14>
       z     = x.13
  */

rule (modulo E) newLh_0_1211111[color=#ffffff, process="new L_h2;"]:
   [ State_1211111( L_h, k, m, v, lock.6 ), Fr( L_h2 ) ]
  -->
   [ State_12111111( L_h, L_h2, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) newLh_0_1211111[color=#ffffff, process="new L_h2;"]:
     [ State_1211111( L_h, k, m, v, lock ), Fr( L_h2 ) ]
    -->
     [ State_12111111( L_h, L_h2, k, m, v, lock ) ]
  */

rule (modulo E) eventUnwrappedLhm_0_12111111[color=#ffffff,
                                             process="event Unwrapped( L_h2, m );"]:
   [ State_12111111( L_h, L_h2, k, m, v, lock.6 ) ]
  --[ Unwrapped( L_h2, m ) ]->
   [ State_121111111( L_h, L_h2, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) eventUnwrappedLhm_0_12111111[color=#ffffff,
                                                process="event Unwrapped( L_h2, m );"]:
     [ State_12111111( L_h, L_h2, k, m, v, lock ) ]
    --[ Unwrapped( L_h2, m ) ]->
     [ State_121111111( L_h, L_h2, k, m, v, lock ) ]
  */

rule (modulo E) insertLhmwrap_0_121111111[color=#ffffff,
                                          process="insert L_h2,<m, 'wrap'>;"]:
   [ State_121111111( L_h, L_h2, k, m, v, lock.6 ) ]
  --[ Insert( L_h2, <m, 'wrap'> ) ]->
   [ State_1211111111( L_h, L_h2, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) insertLhmwrap_0_121111111[color=#ffffff,
                                             process="insert L_h2,<m, 'wrap'>;"]:
     [ State_121111111( L_h, L_h2, k, m, v, lock ) ]
    --[ Insert( L_h2, <m, 'wrap'> ) ]->
     [ State_1211111111( L_h, L_h2, k, m, v, lock ) ]
  */

rule (modulo E) outLh_0_1211111111[color=#ffffff, process="out(L_h2);"]:
   [ State_1211111111( L_h, L_h2, k, m, v, lock.6 ) ]
  -->
   [ State_12111111111( L_h, L_h2, k, m, v, lock.6 ), Out( L_h2 ) ]

  /*
  rule (modulo AC) outLh_0_1211111111[color=#ffffff, process="out(L_h2);"]:
     [ State_1211111111( L_h, L_h2, k, m, v, lock ) ]
    -->
     [ State_12111111111( L_h, L_h2, k, m, v, lock ), Out( L_h2 ) ]
  */

rule (modulo E) unlockLh_0_12111111111[color=#ffffff,
                                       process="unlock L_h;"]:
   [ State_12111111111( L_h, L_h2, k, m, v, lock.6 ) ]
  --[ Unlock_6( '6', lock.6, L_h ), Unlock( '6', lock.6, L_h ) ]->
   [ State_121111111111( L_h, L_h2, k, m, v, lock.6 ) ]

  /*
  rule (modulo AC) unlockLh_0_12111111111[color=#ffffff,
                                          process="unlock L_h;"]:
     [ State_12111111111( L_h, L_h2, k, m, v, lock ) ]
    --[ Unlock_6( '6', lock, L_h ), Unlock( '6', lock, L_h ) ]->
     [ State_121111111111( L_h, L_h2, k, m, v, lock ) ]
  */

rule (modulo E) p_0_121111111111[color=#ffffff, process="0"]:
   [ State_121111111111( L_h, L_h2, k, m, v, lock.6 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_121111111111[color=#ffffff, process="0"]:
     [ State_121111111111( L_h, L_h2, k, m, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_1211112[color=#ffffff, process="0"]:
   [ State_1211112( L_h, k, m, v, lock.6 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_1211112[color=#ffffff, process="0"]:
     [ State_1211112( L_h, k, m, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_121112[color=#ffffff, process="0"]:
   [ State_121112( L_h, k, m, v, lock.6 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_121112[color=#ffffff, process="0"]:
     [ State_121112( L_h, k, m, v, lock ) ] --> [ ]
  */

rule (modulo E) p_0_12112[color=#ffffff, process="0"]:
   [ State_12112( L_h, k, m, lock.6 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_12112[color=#ffffff, process="0"]:
     [ State_12112( L_h, k, m, lock ) ] --> [ ]
  */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒ (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_Not_Eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction locking_0:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_0( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_1:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_1( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_2:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_2( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_3:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_3( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_3( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_4:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_4( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_4( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_5:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_5( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_5( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_6:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_6( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_6( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: examples/sapic/slow/encWrapDecUnwrap/encwrapdecunwrap.spthy

------------------------------------------------------------------------------
analyzed: examples/sapic/slow/encWrapDecUnwrap/encwrapdecunwrap.spthy

  output:          examples/sapic/slow/encWrapDecUnwrap/encwrapdecunwrap.spthy.tmp
  processing time: 141.916559885s
  dec_limits (all-traces): verified (290 steps)
  wrap_key_origins (all-traces): verified (1236 steps)
  no_key_is_wrap_and_dec_ind (all-traces): verified (152 steps)
  no_key_is_wrap_and_dec_ind2 (all-traces): verified (540 steps)
  cannot_obtain_key_ind (all-traces): verified (422 steps)
  cannot_obtain_key (all-traces): verified (2 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: examples/sapic/slow/encWrapDecUnwrap/encwrapdecunwrap.spthy

  output:          examples/sapic/slow/encWrapDecUnwrap/encwrapdecunwrap.spthy.tmp
  processing time: 141.916559885s
  dec_limits (all-traces): verified (290 steps)
  wrap_key_origins (all-traces): verified (1236 steps)
  no_key_is_wrap_and_dec_ind (all-traces): verified (152 steps)
  no_key_is_wrap_and_dec_ind2 (all-traces): verified (540 steps)
  cannot_obtain_key_ind (all-traces): verified (422 steps)
  cannot_obtain_key (all-traces): verified (2 steps)

==============================================================================
*/
