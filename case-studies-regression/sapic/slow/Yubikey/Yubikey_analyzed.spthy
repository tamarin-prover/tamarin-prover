theory Yubikey begin

// Function signature and definition of the equational theory E

builtins: multiset
functions: fst/1, pair/2, sdec/2, senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2

heuristic: p

section{* The Yubikey-Protocol *}

predicate: Smaller( a, b )<=>∃ z. (a+z) = b

lemma init_server [sources]:
  all-traces
  "∀ pid sid k tuple otc tc #i.
    (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i) ⇒
    ((tuple = <sid, k, otc>) ∧
     (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (#j < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ pid sid k tuple otc tc #i.
  (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i)
 ∧
  ((¬(tuple = <sid, k, otc>)) ∨
   (∀ #j. (YubiInit( pid, sid, k ) @ #j) ⇒ ¬(#j < #i)))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (¬(tuple = <sid, k, otc>))  ∥
         (∀ #j. (YubiInit( pid, sid, k ) @ #j) ⇒ ¬(#j < #i)) )
    case case_1
    solve( (∀ pid sid k tuple otc tc #i.
             (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i)
            ⇒
             ((last(#i)) ∨
              ((tuple = <sid, k, otc>) ∧
               (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)))))  ∥
           (∃ pid k tc1 tc2 #t1 #t2.
             (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
            ∧
             (¬(last(#t2))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t2) ∨ (#t2 < #t1) ∨ (∀ z. ((tc1+z) = tc2) ⇒ ⊥))) ∧
             (((#t2 = #t1) ∨ (#t1 < #t2))) ∧
             (¬(#t1 = #t2)))  ∥
           (∃ x #NOW x.1.
             (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW)
            ∧
             (¬(last(#NOW))) ∧ (∀ z. ((x+z) = x.1) ⇒ ⊥))  ∥
           (∃ x y #t3.
             (IsIn( x, y ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (∀ #t2.
               (Insert( x, y ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t1 yp.
                  (Insert( x, yp ) @ #t1)
                 ∧
                  (¬(last(#t1))) ∧
                  (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                  (¬(#t1 = #t2)) ∧
                  (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_0( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_1( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_2( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3))) )
      case case_1
      solve( (last(#i))  ∥
             ((tuple = <sid, k, otc>) ∧
              (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))) )
        case case_1
        solve( State_1111111111( pid, k, lock, nonce, npr, otc, sid, tc, tuple
               ) ▶₀ #i )
          case ifSmallerotctc_0_111111111
          solve( splitEqs(1) )
            case split_case_1
            solve( splitEqs(2) )
              case split_case_1
              by contradiction /* from formulas */
            next
              case split_case_2
              solve( Insert( <'Server', pid>, <sid, x> ) @ #t2 )
                case insertServerLpidsecretidktc_0_111111111111
                by contradiction /* non-normal terms */
              next
                case insertServerLpidsecretidkzero_0_21111
                by contradiction /* non-normal terms */
              qed
            qed
          next
            case split_case_2
            solve( Insert( <'Server', pid>, tuple ) @ #t2 )
              case insertServerLpidsecretidktc_0_111111111111
              by contradiction /* non-normal terms */
            next
              case insertServerLpidsecretidkzero_0_21111
              by contradiction /* non-normal terms */
            qed
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (#t1 = #t2)  ∥ (#t2 < #t1)  ∥ (∀ z. ((tc1+z) = tc2) ⇒ ⊥) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t2 = #t1)  ∥ (#t1 < #t2) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_3
      by contradiction /* from formulas */
    next
      case case_4
      solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_5
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, <'Server', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_6
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, <'Yubikey', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_7
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, <'Yubikey', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( (∀ pid sid k tuple otc tc #i.
             (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i)
            ⇒
             ((last(#i)) ∨
              ((tuple = <sid, k, otc>) ∧
               (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)))))  ∥
           (∃ pid k tc1 tc2 #t1 #t2.
             (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
            ∧
             (¬(last(#t2))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t2) ∨ (#t2 < #t1) ∨ (∀ z. ((tc1+z) = tc2) ⇒ ⊥))) ∧
             (((#t2 = #t1) ∨ (#t1 < #t2))) ∧
             (¬(#t1 = #t2)))  ∥
           (∃ x #NOW x.1.
             (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW)
            ∧
             (¬(last(#NOW))) ∧ (∀ z. ((x+z) = x.1) ⇒ ⊥))  ∥
           (∃ x y #t3.
             (IsIn( x, y ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (∀ #t2.
               (Insert( x, y ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t1 yp.
                  (Insert( x, yp ) @ #t1)
                 ∧
                  (¬(last(#t1))) ∧
                  (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                  (¬(#t1 = #t2)) ∧
                  (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_0( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_1( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3)))  ∥
           (∃ p pp l x lp #t1 #t3.
             (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
            ∧
             (¬(last(#t3))) ∧
             (¬(last(#t1))) ∧
             (((#t1 = #t3) ∨
               (#t3 < #t1) ∨
               (∀ #t2.
                 (Unlock_2( p, l, x ) @ #t2)
                ⇒
                 ((last(#t2)) ∨
                  (#t1 = #t2) ∨
                  (#t2 < #t1) ∨
                  (#t2 = #t3) ∨
                  (#t3 < #t2) ∨
                  (∃ #t0 pp.1.
                    (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                  (∃ pp.1 lpp #t0.
                    (Lock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (¬(#t0 = #t1)) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                  (∃ pp.1 lpp #t0.
                    (Unlock( pp.1, lpp, x ) @ #t0)
                   ∧
                    (¬(last(#t0))) ∧
                    (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                    (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                    (¬(#t2 = #t0))))))) ∧
             (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
             (¬(#t1 = #t3))) )
      case case_1
      solve( (last(#i))  ∥
             ((tuple = <sid, k, otc>) ∧
              (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))) )
        case case_1
        solve( State_1111111111( pid, k, lock, nonce, npr, otc, sid, tc, tuple
               ) ▶₀ #i )
          case ifSmallerotctc_0_111111111
          solve( splitEqs(1) )
            case split_case_1
            solve( splitEqs(2) )
              case split_case_1
              solve( Insert( <'Server', pid>, <sid, k, otc> ) @ #t2 )
                case insertServerLpidsecretidktc_0_111111111111
                solve( State_111111111111( pid, k, lock, nonce.1, npr.1, otc.1, sid, otc,
                                           tuple
                       ) ▶₀ #t2 )
                  case eventLoginLpidktc_0_11111111111
                  by contradiction /* from formulas */
                qed
              next
                case insertServerLpidsecretidkzero_0_21111
                solve( State_21111( pid, k, sid ) ▶₀ #t2 )
                  case newsecretid_0_2111
                  solve( !KU( senc(<~n.3, ('zero'+z), npr>, ~n.1) ) @ #vk.5 )
                    case c_senc
                    solve( !KU( ~n ) @ #vk.4 )
                      case outLpid_0_21111111
                      by contradiction /* from formulas */
                    next
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* from formulas */
                    qed
                  next
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            next
              case split_case_2
              solve( Insert( <'Server', pid>, <sid, x> ) @ #t2 )
                case insertServerLpidsecretidktc_0_111111111111
                by contradiction /* non-normal terms */
              next
                case insertServerLpidsecretidkzero_0_21111
                by contradiction /* non-normal terms */
              qed
            qed
          next
            case split_case_2
            solve( Insert( <'Server', pid>, tuple ) @ #t2 )
              case insertServerLpidsecretidktc_0_111111111111
              by contradiction /* non-normal terms */
            next
              case insertServerLpidsecretidkzero_0_21111
              by contradiction /* non-normal terms */
            qed
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (#t1 = #t2)  ∥ (#t2 < #t1)  ∥ (∀ z. ((tc1+z) = tc2) ⇒ ⊥) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t2 = #t1)  ∥ (#t1 < #t2) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_3
      by contradiction /* from formulas */
    next
      case case_4
      solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_5
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_0( '0', ~n, <'Server', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_6
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_1( '1', ~n, <'Yubikey', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    next
      case case_7
      solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
             (∀ #t2.
               (Unlock_2( '2', ~n, <'Yubikey', L_pid> ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.
                  (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp lpp #t0.
                  (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp lpp #t0.
                  (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      next
        case case_3
        solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (∃ #t0 pp.
                   (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
                 (∃ pp lpp #t0.
                   (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (¬(#t0 = #t1)) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
                 (∃ pp lpp #t0.
                   (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                  ∧
                   (¬(last(#t0))) ∧
                   (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                   (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                   (¬(#t2 = #t0))) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_3
            solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma init_server_secrecy [use_induction, reuse]:
  all-traces
  "∀ pid sid k tuple otc tc #i.
    (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i) ⇒
    (¬(∃ #j. !KU( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ pid sid k tuple otc tc #i.
  (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i) ∧ ∃ #j. (!KU( k ) @ #j)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ pid sid k tuple otc tc #i.
           (InitStuff( pid, sid, k, tuple, otc, tc ) @ #i)
          ⇒
           ((last(#i)) ∨ (∀ #j. (!KU( k ) @ #j) ⇒ last(#j))))  ∥
         (∃ pid k tc1 tc2 #t1 #t2.
           (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
          ∧
           (¬(last(#t2))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t2) ∨ (#t2 < #t1) ∨ (∀ z. ((tc1+z) = tc2) ⇒ ⊥))) ∧
           (((#t2 = #t1) ∨ (#t1 < #t2))) ∧
           (¬(#t1 = #t2)))  ∥
         (∃ x #NOW x.1.
           (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW)
          ∧
           (¬(last(#NOW))) ∧ (∀ z. ((x+z) = x.1) ⇒ ⊥))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#i))  ∥ (∀ #j. (!KU( k ) @ #j) ⇒ last(#j)) )
      case case_1
      solve( State_1111111111( pid, k, lock, nonce, npr, otc, sid, tc, tuple
             ) ▶₀ #i )
        case ifSmallerotctc_0_111111111
        solve( splitEqs(1) )
          case split_case_1
          solve( splitEqs(2) )
            case split_case_1
            solve( !KU( senc(<sid, (otc+z), npr>, k) ) @ #vk.5 )
              case c_senc
              solve( Insert( <'Server', pid>, <sid, k, otc> ) @ #t2 )
                case insertServerLpidsecretidktc_0_111111111111
                solve( State_111111111111( pid, k, lock, nonce.1, npr.1, otc.1, sid, otc,
                                           tuple
                       ) ▶₀ #t2 )
                  case eventLoginLpidktc_0_11111111111
                  by contradiction /* cyclic */
                qed
              next
                case insertServerLpidsecretidkzero_0_21111
                solve( State_21111( pid, k, sid ) ▶₀ #t2 )
                  case newsecretid_0_2111
                  by solve( !KU( ~n.1 ) @ #j )
                qed
              qed
            next
              case outLpidnoncesencsecretidtcnprk_0_211111111121111111
              solve( (#vr.27 < #t2.1)  ∥ (#vr.27 = #t2.1) )
                case case_1
                solve( Insert( <'Server', pid>, <~n.3, ~n, otc> ) @ #t2 )
                  case insertServerLpidsecretidktc_0_111111111111
                  solve( State_111111111111( pid, ~n, lock, nonce.1, npr, otc.1, ~n.3, otc,
                                             tuple
                         ) ▶₀ #t2 )
                    case eventLoginLpidktc_0_11111111111
                    solve( ((#vr.6 < #vr.42) ∧
                            (∃ #t2.
                              (Unlock_0( '0', ~n.2, <'Server', ~n> ) @ #t2)
                             ∧
                              (#vr.6 < #t2) ∧
                              (#t2 < #vr.42) ∧
                              (∀ #t0 pp. (Unlock( pp, ~n.2, <'Server', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                              (∀ pp lpp #t0.
                                (Lock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t0 = #vr.6) ∨ (#t2 < #t0))) ∧
                              (∀ pp lpp #t0.
                                (Unlock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                           (#vr.42 < #vr.6) )
                      case case_1
                      solve( (#vr.28 < #t2.3)  ∥ (#vr.28 = #t2.3) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case case_2
                      solve( (#vr.28 < #t2.3)  ∥ (#vr.28 = #t2.3)  ∥ (#vr.41 < #vr.28) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      next
                        case case_3
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case insertServerLpidsecretidkzero_0_21111
                  solve( State_21111( pid, ~n, ~n.3 ) ▶₀ #t2 )
                    case newsecretid_0_2111
                    by solve( !KU( ~n.1 ) @ #j )
                  qed
                qed
              next
                case case_2
                solve( Insert( <'Server', pid>, <~n.3, ~n, otc> ) @ #t2.1 )
                  case insertServerLpidsecretidktc_0_111111111111
                  solve( State_111111111111( pid, ~n, lock, nonce.1, npr, otc.1, ~n.3, otc,
                                             tuple
                         ) ▶₀ #t2.1 )
                    case eventLoginLpidktc_0_11111111111
                    solve( ((#vr.6 < #vr.41) ∧
                            (∃ #t2.
                              (Unlock_0( '0', ~n.2, <'Server', ~n> ) @ #t2)
                             ∧
                              (#vr.6 < #t2) ∧
                              (#t2 < #vr.41) ∧
                              (∀ #t0 pp. (Unlock( pp, ~n.2, <'Server', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                              (∀ pp lpp #t0.
                                (Lock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t0 = #vr.6) ∨ (#t2 < #t0))) ∧
                              (∀ pp lpp #t0.
                                (Unlock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                           (#vr.41 < #vr.6) )
                      case case_1
                      solve( (#vr.27 < #t2.3)  ∥ (#vr.27 = #t2.3) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case case_2
                      solve( (#vr.27 < #t2.3)  ∥ (#vr.27 = #t2.3)  ∥ (#vr.40 < #vr.27) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      next
                        case case_3
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #i )
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case insertServerLpidsecretidkzero_0_21111
                  solve( State_21111( pid, ~n, ~n.3 ) ▶₀ #t2.1 )
                    case newsecretid_0_2111
                    by solve( !KU( ~n.1 ) @ #j )
                  qed
                qed
              qed
            qed
          next
            case split_case_2
            solve( !KU( fst(x) ) @ #j )
              case c_fst
              solve( !KU( snd(x) ) @ #vk )
                case c_snd
                solve( !KU( senc(<sid, (z+snd(x)), npr>, fst(x)) ) @ #vk.5 )
                  case c_senc
                  solve( Insert( <'Server', pid>, <sid, x> ) @ #t2 )
                    case insertServerLpidsecretidktc_0_111111111111
                    by contradiction /* non-normal terms */
                  next
                    case insertServerLpidsecretidkzero_0_21111
                    by contradiction /* non-normal terms */
                  qed
                qed
              qed
            qed
          qed
        next
          case split_case_2
          solve( !KU( fst(snd(tuple)) ) @ #j )
            case c_fst
            solve( !KU( snd(snd(tuple)) ) @ #vk )
              case c_snd
              solve( !KU( snd(tuple) ) @ #vk.6 )
                case c_snd
                solve( !KU( senc(<fst(tuple), (z+snd(snd(tuple))), npr>, fst(snd(tuple)))
                       ) @ #vk.6 )
                  case c_senc
                  solve( !KU( fst(tuple) ) @ #vk.10 )
                    case c_fst
                    solve( Insert( <'Server', pid>, tuple ) @ #t2 )
                      case insertServerLpidsecretidktc_0_111111111111
                      by contradiction /* non-normal terms */
                    next
                      case insertServerLpidsecretidkzero_0_21111
                      by contradiction /* non-normal terms */
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case case_2
      solve( State_1111111111( pid, k, lock, nonce, npr, otc, sid, tc, tuple
             ) ▶₀ #i )
        case ifSmallerotctc_0_111111111
        solve( splitEqs(1) )
          case split_case_1
          solve( splitEqs(2) )
            case split_case_1
            solve( !KU( senc(<sid, (otc+z), npr>, k) ) @ #vk.5 )
              case c_senc
              by contradiction /* node #i after last node #j */
            next
              case outLpidnoncesencsecretidtcnprk_0_211111111121111111
              solve( (#vr.27 < #t2.1)  ∥ (#vr.27 = #t2.1) )
                case case_1
                solve( Insert( <'Server', pid>, <~n.3, ~n, otc> ) @ #t2 )
                  case insertServerLpidsecretidktc_0_111111111111
                  solve( State_111111111111( pid, ~n, lock, nonce.1, npr, otc.1, ~n.3, otc,
                                             tuple
                         ) ▶₀ #t2 )
                    case eventLoginLpidktc_0_11111111111
                    solve( ((#vr.6 < #vr.42) ∧
                            (∃ #t2.
                              (Unlock_0( '0', ~n.2, <'Server', ~n> ) @ #t2)
                             ∧
                              (#vr.6 < #t2) ∧
                              (#t2 < #vr.42) ∧
                              (∀ #t0 pp. (Unlock( pp, ~n.2, <'Server', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                              (∀ pp lpp #t0.
                                (Lock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t0 = #vr.6) ∨ (#t2 < #t0))) ∧
                              (∀ pp lpp #t0.
                                (Unlock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                           (#vr.42 < #vr.6) )
                      case case_1
                      solve( (#vr.28 < #t2.3)  ∥ (#vr.28 = #t2.3) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case case_2
                      solve( (#vr.28 < #t2.3)  ∥ (#vr.28 = #t2.3)  ∥ (#vr.41 < #vr.28) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      next
                        case case_3
                        solve( State_1111111111111( ~n, k, ~n.5, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.1 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case insertServerLpidsecretidkzero_0_21111
                  solve( State_21111( pid, ~n, ~n.3 ) ▶₀ #t2 )
                    case newsecretid_0_2111
                    by solve( !KU( ~n.1 ) @ #j )
                  qed
                qed
              next
                case case_2
                solve( Insert( <'Server', pid>, <~n.3, ~n, otc> ) @ #t2.1 )
                  case insertServerLpidsecretidktc_0_111111111111
                  solve( State_111111111111( pid, ~n, lock, nonce.1, npr, otc.1, ~n.3, otc,
                                             tuple
                         ) ▶₀ #t2.1 )
                    case eventLoginLpidktc_0_11111111111
                    solve( ((#vr.6 < #vr.41) ∧
                            (∃ #t2.
                              (Unlock_0( '0', ~n.2, <'Server', ~n> ) @ #t2)
                             ∧
                              (#vr.6 < #t2) ∧
                              (#t2 < #vr.41) ∧
                              (∀ #t0 pp. (Unlock( pp, ~n.2, <'Server', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                              (∀ pp lpp #t0.
                                (Lock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t0 = #vr.6) ∨ (#t2 < #t0))) ∧
                              (∀ pp lpp #t0.
                                (Unlock( pp, lpp, <'Server', ~n> ) @ #t0)
                               ⇒
                                ((#t0 < #vr.6) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                           (#vr.41 < #vr.6) )
                      case case_1
                      solve( (#vr.27 < #t2.3)  ∥ (#vr.27 = #t2.3) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.2, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case case_2
                      solve( (#vr.27 < #t2.3)  ∥ (#vr.27 = #t2.3)  ∥ (#vr.40 < #vr.27) )
                        case case_1
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      next
                        case case_2
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      next
                        case case_3
                        solve( State_1111111111111( ~n, k, ~n.6, nonce.2, npr.1, otc.1, secretid,
                                                    tc, tuple
                               ) ▶₀ #t2.2 )
                          case insertServerLpidsecretidktc_0_111111111111
                          solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            by solve( !KU( ~n.1 ) @ #j )
                          qed
                        qed
                      qed
                    qed
                  qed
                next
                  case insertServerLpidsecretidkzero_0_21111
                  solve( State_21111( pid, ~n, ~n.3 ) ▶₀ #t2.1 )
                    case newsecretid_0_2111
                    by solve( !KU( ~n.1 ) @ #j )
                  qed
                qed
              qed
            qed
          next
            case split_case_2
            solve( !KU( fst(x) ) @ #j )
              case c_fst
              solve( !KU( snd(x) ) @ #vk )
                case c_snd
                solve( !KU( senc(<sid, (z+snd(x)), npr>, fst(x)) ) @ #vk.5 )
                  case c_senc
                  by contradiction /* node #i after last node #j */
                qed
              qed
            qed
          qed
        next
          case split_case_2
          solve( !KU( fst(snd(tuple)) ) @ #j )
            case c_fst
            solve( !KU( snd(snd(tuple)) ) @ #vk )
              case c_snd
              solve( !KU( snd(tuple) ) @ #vk.6 )
                case c_snd
                solve( !KU( senc(<fst(tuple), (z+snd(snd(tuple))), npr>, fst(snd(tuple)))
                       ) @ #vk.6 )
                  case c_senc
                  by contradiction /* node #i after last node #j */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( (#t1 = #t2)  ∥ (#t2 < #t1)  ∥ (∀ z. ((tc1+z) = tc2) ⇒ ⊥) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t2 = #t1)  ∥ (#t1 < #t2) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    by contradiction /* from formulas */
  next
    case case_4
    solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_5
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, <'Server', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma init_yubikey [sources]:
  all-traces
  "∀ pid sid k tc #i.
    (YubiPress( pid, sid, k, tc ) @ #i) ⇒
    (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ pid sid k tc #i.
  (YubiPress( pid, sid, k, tc ) @ #i)
 ∧
  ∀ #j. (YubiInit( pid, sid, k ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ pid sid k tc #i.
           (YubiPress( pid, sid, k, tc ) @ #i)
          ⇒
           ((last(#i)) ∨
            (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))))  ∥
         (∃ pid k tc1 tc2 #t1 #t2.
           (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
          ∧
           (¬(last(#t2))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t2) ∨ (#t2 < #t1) ∨ (∀ z. ((tc1+z) = tc2) ⇒ ⊥))) ∧
           (((#t2 = #t1) ∨ (#t1 < #t2))) ∧
           (¬(#t1 = #t2)))  ∥
         (∃ x #NOW x.1.
           (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW)
          ∧
           (¬(last(#NOW))) ∧ (∀ z. ((x+z) = x.1) ⇒ ⊥))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#i))  ∥
           (∃ #j. (YubiInit( pid, sid, k ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
      case case_1
      solve( State_21111111112111111( pid, k, nonce, npr, sid, tc, lock
             ) ▶₀ #i )
        case newnpr_0_2111111111211111
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (#t1 = #t2)  ∥ (#t2 < #t1)  ∥ (∀ z. ((tc1+z) = tc2) ⇒ ⊥) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t2 = #t1)  ∥ (#t1 < #t2) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    by contradiction /* from formulas */
  next
    case case_4
    solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_5
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, <'Server', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

restriction slightly_weaker_invariant:
  "∀ pid k tc1 tc2 #t1 #t2.
    ((Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)) ⇒
    ((((#t1 < #t2) ∧ (∃ z. (tc1+z) = tc2)) ∨ (#t2 < #t1)) ∨ (#t1 = #t2))"

lemma one_count_foreach_login [reuse, use_induction]:
  all-traces
  "∀ pid k x #t2.
    (Login( pid, k, x ) @ #t2) ⇒
    (∃ #t1 sid. (YubiPress( pid, sid, k, x ) @ #t1) ∧ (#t1 < #t2))"
/*
guarded formula characterizing all counter-examples:
"∃ pid k x #t2.
  (Login( pid, k, x ) @ #t2)
 ∧
  ∀ #t1 sid. (YubiPress( pid, sid, k, x ) @ #t1) ⇒ ¬(#t1 < #t2)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ pid k x #t2.
           (Login( pid, k, x ) @ #t2)
          ⇒
           ((last(#t2)) ∨
            (∃ #t1 sid.
              (YubiPress( pid, sid, k, x ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2))))  ∥
         (∃ pid k tc1 tc2 #t1 #t2.
           (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
          ∧
           (¬(last(#t2))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t2) ∨ (#t2 < #t1) ∨ (∀ z. ((tc1+z) = tc2) ⇒ ⊥))) ∧
           (((#t2 = #t1) ∨ (#t1 < #t2))) ∧
           (¬(#t1 = #t2)))  ∥
         (∃ x #NOW x.1.
           (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW)
          ∧
           (¬(last(#NOW))) ∧ (∀ z. ((x+z) = x.1) ⇒ ⊥))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t1 yp.
                (Insert( x, yp ) @ #t1)
               ∧
                (¬(last(#t1))) ∧
                (((#t1 = #t2) ∨ (#t2 < #t1))) ∧
                (¬(#t1 = #t2)) ∧
                (((#t3 = #t1) ∨ (#t1 < #t3)))))))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_0( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_1( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ p pp l x lp #t1 #t3.
           (Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           (((#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∀ #t2.
               (Unlock_2( p, l, x ) @ #t2)
              ⇒
               ((last(#t2)) ∨
                (#t1 = #t2) ∨
                (#t2 < #t1) ∨
                (#t2 = #t3) ∨
                (#t3 < #t2) ∨
                (∃ #t0 pp.1.
                  (Unlock( pp.1, l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
                (∃ pp.1 lpp #t0.
                  (Lock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (¬(#t0 = #t1)) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
                (∃ pp.1 lpp #t0.
                  (Unlock( pp.1, lpp, x ) @ #t0)
                 ∧
                  (¬(last(#t0))) ∧
                  (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                  (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                  (¬(#t2 = #t0))))))) ∧
           (((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (¬(#t1 = #t3))) )
    case case_1
    solve( (last(#t2))  ∥
           (∃ #t1 sid.
             (YubiPress( pid, sid, k, x ) @ #t1) ∧ (¬(last(#t1))) ∧ (#t1 < #t2)) )
      case case_1
      solve( State_11111111111( pid, k, lock, nonce, npr, otc, secretid, x,
                                tuple
             ) ▶₀ #t2 )
        case eventInitStuffLpidsecretidktupleotctc_0_1111111111
        solve( (#vr.14 < #t2.1)  ∥ (#vr.14 = #t2.1)  ∥ (#vr.6 < #vr.14) )
          case case_1
          solve( !KU( ~n ) @ #vk.2 )
            case outLpid_0_21111111
            solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
              case c_senc
              by contradiction /* from formulas */
            next
              case outLpidnoncesencsecretidtcnprk_0_211111111121111111
              by contradiction /* from formulas */
            qed
          next
            case outLpidnoncesencsecretidtcnprk_0_211111111121111111
            solve( (#vr.13 < #t2.2)  ∥ (#vr.13 = #t2.2) )
              case case_1
              solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
                case c_senc
                by contradiction /* from formulas */
              next
                case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                by contradiction /* from formulas */
              qed
            next
              case case_2
              solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
                case c_senc
                by contradiction /* from formulas */
              next
                case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_2
          solve( !KU( ~n ) @ #vk.2 )
            case outLpid_0_21111111
            solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
              case c_senc
              by contradiction /* from formulas */
            next
              case outLpidnoncesencsecretidtcnprk_0_211111111121111111
              by contradiction /* from formulas */
            qed
          next
            case outLpidnoncesencsecretidtcnprk_0_211111111121111111
            solve( (#vr.13 < #t2.2)  ∥ (#vr.13 = #t2.2) )
              case case_1
              solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
                case c_senc
                by contradiction /* from formulas */
              next
                case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                by contradiction /* from formulas */
              qed
            next
              case case_2
              solve( !KU( senc(<~n.2, (otc+z), npr>, ~n.1) ) @ #vk.5 )
                case c_senc
                by contradiction /* from formulas */
              next
                case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_3
          solve( !KU( ~n ) @ #vk.2 )
            case outLpid_0_21111111
            by contradiction /* cyclic */
          next
            case outLpidnoncesencsecretidtcnprk_0_211111111121111111
            by contradiction /* cyclic */
          qed
        qed
      qed
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (#t1 = #t2.1)  ∥ (#t2.1 < #t1)  ∥ (∀ z. ((tc1+z) = tc2) ⇒ ⊥) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t2.1 = #t1)  ∥ (#t1 < #t2.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    by contradiction /* from formulas */
  next
    case case_4
    solve( (#t1 = #t2.1)  ∥ (#t2.1 < #t1) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_5
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_0( '0', ~n, <'Server', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Server', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_6
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_1( '1', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_7
    solve( (#t1 = #t3)  ∥ (#t3 < #t1)  ∥
           (∀ #t2.
             (Unlock_2( '2', ~n, <'Yubikey', L_pid> ) @ #t2)
            ⇒
             ((last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0 pp.
                (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ pp lpp #t0.
                (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (¬(#t0 = #t1)) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2)))) ∨
              (∃ pp lpp #t0.
                (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                (((#t2 = #t0) ∨ (#t0 < #t2))) ∧
                (¬(#t2 = #t0))))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1)  ∥ (#t1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0 pp.
                 (Unlock( pp, ~n, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧ (¬(#t0 = #t2.1)))  ∥
               (∃ pp lpp #t0.
                 (Lock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (¬(#t0 = #t1)) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))))  ∥
               (∃ pp lpp #t0.
                 (Unlock( pp, lpp, <'Yubikey', L_pid> ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 (((#t0 = #t1) ∨ (#t1 < #t0))) ∧
                 (((#t2.1 = #t0) ∨ (#t0 < #t2.1))) ∧
                 (¬(#t2.1 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1)  ∥ (#t1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2.1 = #t0)  ∥ (#t0 < #t2.1) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma no_replay [reuse]:
  all-traces
  "¬(∃ #i #j pid k x.
      ((Login( pid, k, x ) @ #i) ∧ (Login( pid, k, x ) @ #j)) ∧ (¬(#i = #j)))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j pid k x.
  (Login( pid, k, x ) @ #i) ∧ (Login( pid, k, x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
by solve( (#i < #j)  ∥ (#j < #i) )

lemma injective_correspondance [reuse, use_induction]:
  all-traces
  "∀ pid k x #t2.
    (Login( pid, k, x ) @ #t2) ⇒
    ((∃ #t1 sid. (YubiPress( pid, sid, k, x ) @ #t1) ∧ (#t1 < #t2)) ∧
     (∀ #t3. (Login( pid, k, x ) @ #t3) ⇒ (#t3 = #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ pid k x #t2.
  (Login( pid, k, x ) @ #t2)
 ∧
  ((∀ #t1 sid. (YubiPress( pid, sid, k, x ) @ #t1) ⇒ ¬(#t1 < #t2)) ∨
   (∃ #t3. (Login( pid, k, x ) @ #t3) ∧ ¬(#t3 = #t2)))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #t1 sid. (YubiPress( pid, sid, k, x ) @ #t1) ⇒ ¬(#t1 < #t2))  ∥
         (∃ #t3. (Login( pid, k, x ) @ #t3) ∧ ¬(#t3 = #t2)) )
    case case_1
    by contradiction /* from formulas */
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma Login_invalidates_smaller_counters:
  all-traces
  "∀ pid k tc1 tc2 #t1 #t2.
    (((Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)) ∧
     (∃ z. (tc1+z) = tc2)) ⇒
    (#t1 < #t2)"
/*
guarded formula characterizing all counter-examples:
"∃ pid k tc1 tc2 #t1 #t2.
  (Login( pid, k, tc1 ) @ #t1) ∧ (Login( pid, k, tc2 ) @ #t2)
 ∧
  (∃ z. ((tc1+z) = tc2)) ∧ (¬(#t1 < #t2))"
*/
simplify
solve( (#t1 = #t2)  ∥ (#t2 < #t1) )
  case case_1
  solve( State_11111111111( pid, k, lock, nonce, npr, otc, secretid, tc1,
                            tuple
         ) ▶₀ #t1 )
    case eventInitStuffLpidsecretidktupleotctc_0_1111111111
    solve( (#vr.14 < #t2)  ∥ (#vr.14 = #t2)  ∥ (#vr.6 < #vr.14) )
      case case_1
      solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                      lock
             ) ▶₀ #t1.1 )
        case newnpr_0_2111111111211111
        solve( (#vr.13 < #t2.1)  ∥ (#vr.13 = #t2.1) )
          case case_1
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.25 < #vr.35) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.25 < #t2) ∧
                      (#t2 < #vr.35) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.25) ∨ (#t0 = #vr.25) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.25) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.35 < #vr.25)  ∥ (#vr.25 = #vr.35) )
              case case_1
              solve( (#vr.32 < #t2.2)  ∥ (#vr.32 = #t2.2)  ∥ (#vr.24 < #vr.32) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.24 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.22 < #t2.3)  ∥ (#vr.22 = #t2.3)  ∥ (#vr.34 < #vr.22) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_2
              solve( (#vr.32 < #t2.2)  ∥ (#vr.32 = #t2.2)  ∥ (#vr.24 < #vr.32) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.1 < #t2.4)  ∥ (#t2.1 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.24 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.22 < #t2.3)  ∥ (#vr.22 = #t2.3)  ∥ (#vr.34 < #vr.22) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_3
              solve( (#vr.13 < #t2.2)  ∥ (#vr.13 = #t2.2) )
                case case_1
                solve( (#t2.1 < #t2.2)  ∥ (#t2.1 = #t2.2) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_2
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.24 < #vr.34) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.24 < #t2) ∧
                      (#t2 < #vr.34) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t0 = #vr.24) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.34 < #vr.24)  ∥ (#vr.24 = #vr.34) )
              case case_1
              solve( (#t2.3 < #t2)  ∥ (#t2.3 = #t2)  ∥ (#vr.23 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.6
                       ) ▶₀ #t2.1 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2 < #t2.4)  ∥ (#t2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2 < #t2.4)  ∥ (#t2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_2
              solve( (#t2.3 < #t2)  ∥ (#t2.3 = #t2)  ∥ (#vr.23 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.7
                       ) ▶₀ #t2.1 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_3
              solve( (#t2 < #t2.2)  ∥ (#t2 = #t2.2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
              qed
            qed
          qed
        qed
      qed
    next
      case case_2
      solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                      lock
             ) ▶₀ #t1.1 )
        case newnpr_0_2111111111211111
        solve( (#vr.13 < #t2.1)  ∥ (#vr.13 = #t2.1) )
          case case_1
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.24 < #vr.34) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.24 < #t2) ∧
                      (#t2 < #vr.34) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t0 = #vr.24) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.34 < #vr.24)  ∥ (#vr.24 = #vr.34) )
              case case_1
              solve( (#vr.31 < #t2.2)  ∥ (#vr.31 = #t2.2)  ∥ (#vr.23 < #vr.31) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.23 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.6
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.6
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.6
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.6
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.6
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_2
              solve( (#vr.31 < #t2.2)  ∥ (#vr.31 = #t2.2)  ∥ (#vr.23 < #vr.31) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.23 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.7
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.7
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.7
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.7
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.7
                           ) ▶₀ #t2.1 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_3
              solve( (#vr.13 < #t2.2)  ∥ (#vr.13 = #t2.2) )
                case case_1
                solve( (#t2.1 < #t2.2)  ∥ (#t2.1 = #t2.2) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_2
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.23 < #vr.33) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.23 < #t2) ∧
                      (#t2 < #vr.33) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.23) ∨ (#t0 = #vr.23) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.23) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.33 < #vr.23)  ∥ (#vr.23 = #vr.33) )
              case case_1
              solve( (#t2.3 < #t2.1)  ∥ (#t2.3 = #t2.1)  ∥ (#vr.22 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.6
                       ) ▶₀ #t2.2 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.20 < #t2.3)  ∥ (#vr.20 = #t2.3)  ∥ (#vr.32 < #vr.20) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.1 < #t2.4)  ∥ (#t2.1 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.1 < #t2.4)  ∥ (#t2.1 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_2
              solve( (#t2.3 < #t2.1)  ∥ (#t2.3 = #t2.1)  ∥ (#vr.22 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.9
                       ) ▶₀ #t2.2 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.20 < #t2.3)  ∥ (#vr.20 = #t2.3)  ∥ (#vr.32 < #vr.20) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.9
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.9
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.9
                         ) ▶₀ #t2.2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_3
              solve( (#t2.1 < #t2.2)  ∥ (#t2.1 = #t2.2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
              qed
            qed
          qed
        qed
      qed
    next
      case case_3
      solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                      lock
             ) ▶₀ #t1.1 )
        case newnpr_0_2111111111211111
        solve( (#vr.13 < #t2.1)  ∥ (#vr.13 = #t2.1) )
          case case_1
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.25 < #vr.35) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.25 < #t2) ∧
                      (#t2 < #vr.35) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.25) ∨ (#t0 = #vr.25) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.25) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.35 < #vr.25)  ∥ (#vr.25 = #vr.35) )
              case case_1
              solve( (#vr.32 < #t2.2)  ∥ (#vr.32 = #t2.2)  ∥ (#vr.24 < #vr.32) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.24 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.22 < #t2.3)  ∥ (#vr.22 = #t2.3)  ∥ (#vr.34 < #vr.22) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                        case case_1
                        solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                          case case_1
                          by contradiction /* from formulas */
                        next
                          case case_2
                          by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_2
              solve( (#vr.32 < #t2.2)  ∥ (#vr.32 = #t2.2)  ∥ (#vr.24 < #vr.32) )
                case case_1
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.1 < #t2.4)  ∥ (#t2.1 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_2
                solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#vr.13 < #t2.4)  ∥ (#vr.13 = #t2.4) )
                      case case_1
                      solve( (#t2.3 < #t2.4)  ∥ (#t2.3 = #t2.4) )
                        case case_1
                        by contradiction /* from formulas */
                      next
                        case case_2
                        by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2.2 < #t2.4)  ∥ (#t2.2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                qed
              next
                case case_3
                solve( (#t2.3 < #t2.2)  ∥ (#t2.3 = #t2.2)  ∥ (#vr.24 < #t2.3) )
                  case case_1
                  solve( (#vr.13 < #t2.3)  ∥ (#vr.13 = #t2.3) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.4
                         ) ▶₀ #t2 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( (#vr.22 < #t2.3)  ∥ (#vr.22 = #t2.3)  ∥ (#vr.34 < #vr.22) )
                    case case_1
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_3
                    solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                      ~n.4
                           ) ▶₀ #t2 )
                      case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                      by contradiction /* cyclic */
                    qed
                  qed
                qed
              qed
            next
              case case_3
              solve( (#vr.13 < #t2.2)  ∥ (#vr.13 = #t2.2) )
                case case_1
                solve( (#t2.1 < #t2.2)  ∥ (#t2.1 = #t2.2) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_2
          solve( State_21111111112111111( ~n, ~n.1, nonce.1, npr.1, sid, (otc+z),
                                          lock
                 ) ▶₀ #t1.2 )
            case newnpr_0_2111111111211111
            solve( ((#vr.24 < #vr.34) ∧
                    (∃ #t2.
                      (Unlock_2( '2', ~n.6, <'Yubikey', ~n> ) @ #t2)
                     ∧
                      (#vr.24 < #t2) ∧
                      (#t2 < #vr.34) ∧
                      (∀ #t0 pp. (Unlock( pp, ~n.6, <'Yubikey', ~n> ) @ #t0) ⇒ #t0 = #t2) ∧
                      (∀ pp lpp #t0.
                        (Lock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t0 = #vr.24) ∨ (#t2 < #t0))) ∧
                      (∀ pp lpp #t0.
                        (Unlock( pp, lpp, <'Yubikey', ~n> ) @ #t0)
                       ⇒
                        ((#t0 < #vr.24) ∨ (#t2 < #t0) ∨ (#t2 = #t0)))))  ∥
                   (#vr.34 < #vr.24)  ∥ (#vr.24 = #vr.34) )
              case case_1
              solve( (#t2.3 < #t2)  ∥ (#t2.3 = #t2)  ∥ (#vr.23 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.6
                       ) ▶₀ #t2.1 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2 < #t2.4)  ∥ (#t2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    solve( (#t2 < #t2.4)  ∥ (#t2 = #t2.4) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
                    qed
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.6
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_2
              solve( (#t2.3 < #t2)  ∥ (#t2.3 = #t2)  ∥ (#vr.23 < #t2.3) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                  ~n.7
                       ) ▶₀ #t2.1 )
                  case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                  by contradiction /* cyclic */
                qed
              next
                case case_3
                solve( (#vr.21 < #t2.3)  ∥ (#vr.21 = #t2.3)  ∥ (#vr.33 < #vr.21) )
                  case case_1
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                next
                  case case_3
                  solve( State_2111111111211111111( ~n, k, nonce.1, npr.1, secretid, tc,
                                                    ~n.7
                         ) ▶₀ #t2.1 )
                    case outLpidnoncesencsecretidtcnprk_0_211111111121111111
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            next
              case case_3
              solve( (#t2 < #t2.2)  ∥ (#t2 = #t2.2) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by solve( Login( ~n, ~n.1, (otc+z+z.1) ) @ #t1 )
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

rule (modulo E) Init[color=#ffffff, process="|"]:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_[color=#ffffff, process="|"]:
   [ State_( ) ] --> [ State_1( ), State_2( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1[color=#806040, process="!"]:
   [ State_1( ) ] --> [ !Semistate_11( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_1[color=#806040, process="!"]:
   [ !Semistate_11( ) ] --> [ State_11( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) inLpidnoncesencsecretidtcnprk_0_11[color=#806040,
                                                   process="in(<L_pid, nonce, senc(<secretid, tc, npr>, k)>);"]:
   [ State_11( ), In( <L_pid, nonce, senc(<secretid, tc, npr>, k)> ) ]
  -->
   [ State_111( L_pid, k, nonce, npr, secretid, tc ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockServerLpid_0_111[color=#806040,
                                     process="lock <'Server', L_pid>;"]:
   [ State_111( L_pid, k, nonce, npr, secretid, tc ), Fr( lock ) ]
  --[
  Lock_0( '0', lock, <'Server', L_pid> ),
  Lock( '0', lock, <'Server', L_pid> )
  ]->
   [ State_1111( L_pid, k, lock, nonce, npr, secretid, tc ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookupServerLpidastuple_0_1111[color=#806040,
                                               process="lookup <'Server', L_pid> as tuple"]:
   [ State_1111( L_pid, k, lock, nonce, npr, secretid, tc ) ]
  --[ IsIn( <'Server', L_pid>, tuple ) ]->
   [ State_11111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookupServerLpidastuple_1_1111[color=#806040,
                                               process="lookup <'Server', L_pid> as tuple"]:
   [ State_1111( L_pid, k, lock, nonce, npr, secretid, tc ) ]
  --[ IsNotSet( <'Server', L_pid> ) ]->
   [ State_11112( L_pid, k, lock, nonce, npr, secretid, tc ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) iffsttuplesecretid_0_11111[color=#806040,
                                           process="if fst(tuple)=secretid"]:
   [ State_11111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  --[ Pred_Eq( fst(tuple), secretid ) ]->
   [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]

  /*
  rule (modulo AC) iffsttuplesecretid_0_11111[color=#806040,
                                              process="if fst(tuple)=secretid"]:
     [ State_11111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    --[ Pred_Eq( z, secretid ) ]->
     [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    variants (modulo AC)
    1. tuple = tuple.10
       z     = fst(tuple.10)
    
    2. tuple = <x.10, x.11>
       z     = x.10
  */

rule (modulo E) iffsttuplesecretid_1_11111[color=#806040,
                                           process="if fst(tuple)=secretid"]:
   [ State_11111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  --[ Pred_Not_Eq( fst(tuple), secretid ) ]->
   [ State_111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]

  /*
  rule (modulo AC) iffsttuplesecretid_1_11111[color=#806040,
                                              process="if fst(tuple)=secretid"]:
     [ State_11111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    --[ Pred_Not_Eq( z, secretid ) ]->
     [ State_111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    variants (modulo AC)
    1. tuple = tuple.10
       z     = fst(tuple.10)
    
    2. tuple = <x.10, x.11>
       z     = x.10
  */

rule (modulo E) iffstsndtuplek_0_111111[color=#806040,
                                        process="if fst(snd(tuple))=k"]:
   [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  --[ Pred_Eq( fst(snd(tuple)), k ) ]->
   [ State_1111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]

  /*
  rule (modulo AC) iffstsndtuplek_0_111111[color=#806040,
                                           process="if fst(snd(tuple))=k"]:
     [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    --[ Pred_Eq( z, k ) ]->
     [ State_1111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    variants (modulo AC)
    1. tuple = tuple.10
       z     = fst(snd(tuple.10))
    
    2. tuple = <x.10, x.11>
       z     = fst(x.11)
    
    3. tuple = <x.10, x.11, x.12>
       z     = x.11
  */

rule (modulo E) iffstsndtuplek_1_111111[color=#806040,
                                        process="if fst(snd(tuple))=k"]:
   [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  --[ Pred_Not_Eq( fst(snd(tuple)), k ) ]->
   [ State_1111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]

  /*
  rule (modulo AC) iffstsndtuplek_1_111111[color=#806040,
                                           process="if fst(snd(tuple))=k"]:
     [ State_111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    --[ Pred_Not_Eq( z, k ) ]->
     [ State_1111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
    variants (modulo AC)
    1. tuple = tuple.10
       z     = fst(snd(tuple.10))
    
    2. tuple = <x.10, x.11>
       z     = fst(x.11)
    
    3. tuple = <x.10, x.11, x.12>
       z     = x.11
  */

rule (modulo E) inotc_0_1111111[color=#806040, process="in(otc);"]:
   [
   State_1111111( L_pid, k, lock, nonce, npr, secretid, tc, tuple ),
   In( otc )
   ]
  -->
   [ State_11111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ifsndsndtupleotc_0_11111111[color=#806040,
                                            process="if snd(snd(tuple))=otc"]:
   [ State_11111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ Pred_Eq( snd(snd(tuple)), otc ) ]->
   [ State_111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /*
  rule (modulo AC) ifsndsndtupleotc_0_11111111[color=#806040,
                                               process="if snd(snd(tuple))=otc"]:
     [ State_11111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
     ]
    --[ Pred_Eq( z, otc ) ]->
     [ State_111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
     ]
    variants (modulo AC)
    1. tuple = tuple.11
       z     = snd(snd(tuple.11))
    
    2. tuple = <x.11, x.12>
       z     = snd(x.12)
    
    3. tuple = <x.11, x.12, x.13>
       z     = x.13
  */

rule (modulo E) ifsndsndtupleotc_1_11111111[color=#806040,
                                            process="if snd(snd(tuple))=otc"]:
   [ State_11111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ Pred_Not_Eq( snd(snd(tuple)), otc ) ]->
   [ State_111111112( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /*
  rule (modulo AC) ifsndsndtupleotc_1_11111111[color=#806040,
                                               process="if snd(snd(tuple))=otc"]:
     [ State_11111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
     ]
    --[ Pred_Not_Eq( z, otc ) ]->
     [ State_111111112( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
     ]
    variants (modulo AC)
    1. tuple = tuple.11
       z     = snd(snd(tuple.11))
    
    2. tuple = <x.11, x.12>
       z     = snd(x.12)
    
    3. tuple = <x.11, x.12, x.13>
       z     = x.13
  */

restriction Restr_ifSmallerotctc_0_111111111_1:
  "∀ x #NOW x.1.
    (Restr_ifSmallerotctc_0_111111111_1( x, x.1 ) @ #NOW) ⇒
    (∃ z. (x+z) = x.1)"

rule (modulo E) ifSmallerotctc_0_111111111[color=#806040,
                                           process="if Smaller( otc, tc )"]:
   [ State_111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ Restr_ifSmallerotctc_0_111111111_1( otc, tc ) ]->
   [
   State_1111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /* has exactly the trivial AC variant */

restriction Restr_ifSmallerotctc_1_111111111_1:
  "∀ x #NOW x.1.
    (Restr_ifSmallerotctc_1_111111111_1( x, x.1 ) @ #NOW) ⇒
    (¬(∃ z. (x+z) = x.1))"
  // safety formula

rule (modulo E) ifSmallerotctc_1_111111111[color=#806040,
                                           process="if Smaller( otc, tc )"]:
   [ State_111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ Restr_ifSmallerotctc_1_111111111_1( otc, tc ) ]->
   [
   State_1111111112( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventInitStuffLpidsecretidktupleotctc_0_1111111111[color=#806040,
                                                                   process="event InitStuff( L_pid, secretid, k, tuple, otc, tc );"]:
   [
   State_1111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ InitStuff( L_pid, secretid, k, tuple, otc, tc ) ]->
   [
   State_11111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventLoginLpidktc_0_11111111111[color=#806040,
                                                process="event Login( L_pid, k, tc );"]:
   [
   State_11111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  --[ Login( L_pid, k, tc ) ]->
   [
   State_111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) insertServerLpidsecretidktc_0_111111111111[color=#806040,
                                                           process="insert <'Server', L_pid>,<secretid, k, tc>;"]:
   [
   State_111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple
   )
   ]
  --[ Insert( <'Server', L_pid>, <secretid, k, tc> ) ]->
   [
   State_1111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlockServerLpid_0_1111111111111[color=#806040,
                                                 process="unlock <'Server', L_pid>;"]:
   [
   State_1111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple
   )
   ]
  --[
  Unlock_0( '0', lock, <'Server', L_pid> ),
  Unlock( '0', lock, <'Server', L_pid> )
  ]->
   [
   State_11111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc,
                         tuple
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11111111111111[color=#806040, process="0"]:
   [
   State_11111111111111( L_pid, k, lock, nonce, npr, otc, secretid, tc,
                         tuple
   )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111111112[color=#806040, process="0"]:
   [
   State_1111111112( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111111112[color=#806040, process="0"]:
   [ State_111111112( L_pid, k, lock, nonce, npr, otc, secretid, tc, tuple )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_1111112[color=#806040, process="0"]:
   [ State_1111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_111112[color=#806040, process="0"]:
   [ State_111112( L_pid, k, lock, nonce, npr, secretid, tc, tuple ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_11112[color=#806040, process="0"]:
   [ State_11112( L_pid, k, lock, nonce, npr, secretid, tc ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_2[color=#ffffff, process="!"]:
   [ State_2( ) ] --> [ !Semistate_21( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_2[color=#ffffff, process="!"]:
   [ !Semistate_21( ) ] --> [ State_21( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newk_0_21[color=#805140, process="new k;"]:
   [ State_21( ), Fr( k ) ] --> [ State_211( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newLpid_0_211[color=#805140, process="new L_pid;"]:
   [ State_211( k ), Fr( L_pid ) ] --> [ State_2111( L_pid, k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) newsecretid_0_2111[color=#805140,
                                   process="new secretid;"]:
   [ State_2111( L_pid, k ), Fr( secretid ) ]
  -->
   [ State_21111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insertServerLpidsecretidkzero_0_21111[color=#805140,
                                                      process="insert <'Server', L_pid>,<secretid, k, 'zero'>;"]:
   [ State_21111( L_pid, k, secretid ) ]
  --[ Insert( <'Server', L_pid>, <secretid, k, 'zero'> ) ]->
   [ State_211111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insertLYubikeyLpidonezero_0_211111[color=#805140,
                                                   process="insert <'L_Yubikey', L_pid>,('one'+'zero');"]:
   [ State_211111( L_pid, k, secretid ) ]
  --[ Insert( <'L_Yubikey', L_pid>, ('one'+'zero') ) ]->
   [ State_2111111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) eventYubiInitLpidsecretidk_0_2111111[color=#805140,
                                                     process="event YubiInit( L_pid, secretid, k );"]:
   [ State_2111111( L_pid, k, secretid ) ]
  --[ YubiInit( L_pid, secretid, k ) ]->
   [ State_21111111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) outLpid_0_21111111[color=#805140, process="out(L_pid);"]:
   [ State_21111111( L_pid, k, secretid ) ]
  -->
   [ State_211111111( L_pid, k, secretid ), Out( L_pid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_211111111[color=#805140, process="!"]:
   [ State_211111111( L_pid, k, secretid ) ]
  -->
   [ !Semistate_2111111111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_1_211111111[color=#805140, process="!"]:
   [ !Semistate_2111111111( L_pid, k, secretid ) ]
  -->
   [ State_2111111111( L_pid, k, secretid ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) p_0_2111111111[color=#805140, process="|"]:
   [ State_2111111111( L_pid, k, secretid ) ]
  -->
   [
   State_21111111111( L_pid, k, secretid ),
   State_21111111112( L_pid, k, secretid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) lockYubikeyLpid_0_21111111111[color=#805140,
                                              process="lock <'Yubikey', L_pid>;"]:
   [ State_21111111111( L_pid, k, secretid ), Fr( lock.1 ) ]
  --[
  Lock_1( '1', lock.1, <'Yubikey', L_pid> ),
  Lock( '1', lock.1, <'Yubikey', L_pid> )
  ]->
   [ State_211111111111( L_pid, k, secretid, lock.1 ) ]

  /*
  rule (modulo AC) lockYubikeyLpid_0_21111111111[color=#805140,
                                                 process="lock <'Yubikey', L_pid>;"]:
     [ State_21111111111( L_pid, k, secretid ), Fr( lock ) ]
    --[
    Lock_1( '1', lock, <'Yubikey', L_pid> ),
    Lock( '1', lock, <'Yubikey', L_pid> )
    ]->
     [ State_211111111111( L_pid, k, secretid, lock ) ]
  */

rule (modulo E) lookupLYubikeyLpidassc_0_211111111111[color=#805140,
                                                      process="lookup <'L_Yubikey', L_pid> as sc"]:
   [ State_211111111111( L_pid, k, secretid, lock.1 ) ]
  --[ IsIn( <'L_Yubikey', L_pid>, sc ) ]->
   [ State_2111111111111( L_pid, k, sc, secretid, lock.1 ) ]

  /*
  rule (modulo AC) lookupLYubikeyLpidassc_0_211111111111[color=#805140,
                                                         process="lookup <'L_Yubikey', L_pid> as sc"]:
     [ State_211111111111( L_pid, k, secretid, lock ) ]
    --[ IsIn( <'L_Yubikey', L_pid>, sc ) ]->
     [ State_2111111111111( L_pid, k, sc, secretid, lock ) ]
  */

rule (modulo E) lookupLYubikeyLpidassc_1_211111111111[color=#805140,
                                                      process="lookup <'L_Yubikey', L_pid> as sc"]:
   [ State_211111111111( L_pid, k, secretid, lock.1 ) ]
  --[ IsNotSet( <'L_Yubikey', L_pid> ) ]->
   [ State_2111111111112( L_pid, k, secretid, lock.1 ) ]

  /*
  rule (modulo AC) lookupLYubikeyLpidassc_1_211111111111[color=#805140,
                                                         process="lookup <'L_Yubikey', L_pid> as sc"]:
     [ State_211111111111( L_pid, k, secretid, lock ) ]
    --[ IsNotSet( <'L_Yubikey', L_pid> ) ]->
     [ State_2111111111112( L_pid, k, secretid, lock ) ]
  */

rule (modulo E) insc_0_2111111111111[color=#805140, process="in(sc);"]:
   [ State_2111111111111( L_pid, k, sc, secretid, lock.1 ), In( sc ) ]
  -->
   [ State_21111111111111( L_pid, k, sc, secretid, lock.1 ) ]

  /*
  rule (modulo AC) insc_0_2111111111111[color=#805140, process="in(sc);"]:
     [ State_2111111111111( L_pid, k, sc, secretid, lock ), In( sc ) ]
    -->
     [ State_21111111111111( L_pid, k, sc, secretid, lock ) ]
  */

rule (modulo E) insertLYubikeyLpidonesc_0_21111111111111[color=#805140,
                                                         process="insert <'L_Yubikey', L_pid>,('one'+sc);"]:
   [ State_21111111111111( L_pid, k, sc, secretid, lock.1 ) ]
  --[ Insert( <'L_Yubikey', L_pid>, ('one'+sc) ) ]->
   [ State_211111111111111( L_pid, k, sc, secretid, lock.1 ) ]

  /*
  rule (modulo AC) insertLYubikeyLpidonesc_0_21111111111111[color=#805140,
                                                            process="insert <'L_Yubikey', L_pid>,('one'+sc);"]:
     [ State_21111111111111( L_pid, k, sc, secretid, lock ) ]
    --[ Insert( <'L_Yubikey', L_pid>, ('one'+sc) ) ]->
     [ State_211111111111111( L_pid, k, sc, secretid, lock ) ]
  */

rule (modulo E) unlockYubikeyLpid_0_211111111111111[color=#805140,
                                                    process="unlock <'Yubikey', L_pid>;"]:
   [ State_211111111111111( L_pid, k, sc, secretid, lock.1 ) ]
  --[
  Unlock_1( '1', lock.1, <'Yubikey', L_pid> ),
  Unlock( '1', lock.1, <'Yubikey', L_pid> )
  ]->
   [ State_2111111111111111( L_pid, k, sc, secretid, lock.1 ) ]

  /*
  rule (modulo AC) unlockYubikeyLpid_0_211111111111111[color=#805140,
                                                       process="unlock <'Yubikey', L_pid>;"]:
     [ State_211111111111111( L_pid, k, sc, secretid, lock ) ]
    --[
    Unlock_1( '1', lock, <'Yubikey', L_pid> ),
    Unlock( '1', lock, <'Yubikey', L_pid> )
    ]->
     [ State_2111111111111111( L_pid, k, sc, secretid, lock ) ]
  */

rule (modulo E) p_0_2111111111111111[color=#805140, process="0"]:
   [ State_2111111111111111( L_pid, k, sc, secretid, lock.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_2111111111111111[color=#805140, process="0"]:
     [ State_2111111111111111( L_pid, k, sc, secretid, lock ) ] --> [ ]
  */

rule (modulo E) p_0_2111111111112[color=#805140, process="0"]:
   [ State_2111111111112( L_pid, k, secretid, lock.1 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_2111111111112[color=#805140, process="0"]:
     [ State_2111111111112( L_pid, k, secretid, lock ) ] --> [ ]
  */

rule (modulo E) lockYubikeyLpid_0_21111111112[color=#805140,
                                              process="lock <'Yubikey', L_pid>;"]:
   [ State_21111111112( L_pid, k, secretid ), Fr( lock.2 ) ]
  --[
  Lock_2( '2', lock.2, <'Yubikey', L_pid> ),
  Lock( '2', lock.2, <'Yubikey', L_pid> )
  ]->
   [ State_211111111121( L_pid, k, secretid, lock.2 ) ]

  /*
  rule (modulo AC) lockYubikeyLpid_0_21111111112[color=#805140,
                                                 process="lock <'Yubikey', L_pid>;"]:
     [ State_21111111112( L_pid, k, secretid ), Fr( lock ) ]
    --[
    Lock_2( '2', lock, <'Yubikey', L_pid> ),
    Lock( '2', lock, <'Yubikey', L_pid> )
    ]->
     [ State_211111111121( L_pid, k, secretid, lock ) ]
  */

rule (modulo E) lookupLYubikeyLpidastc_0_211111111121[color=#805140,
                                                      process="lookup <'L_Yubikey', L_pid> as tc"]:
   [ State_211111111121( L_pid, k, secretid, lock.2 ) ]
  --[ IsIn( <'L_Yubikey', L_pid>, tc ) ]->
   [ State_2111111111211( L_pid, k, secretid, tc, lock.2 ) ]

  /*
  rule (modulo AC) lookupLYubikeyLpidastc_0_211111111121[color=#805140,
                                                         process="lookup <'L_Yubikey', L_pid> as tc"]:
     [ State_211111111121( L_pid, k, secretid, lock ) ]
    --[ IsIn( <'L_Yubikey', L_pid>, tc ) ]->
     [ State_2111111111211( L_pid, k, secretid, tc, lock ) ]
  */

rule (modulo E) lookupLYubikeyLpidastc_1_211111111121[color=#805140,
                                                      process="lookup <'L_Yubikey', L_pid> as tc"]:
   [ State_211111111121( L_pid, k, secretid, lock.2 ) ]
  --[ IsNotSet( <'L_Yubikey', L_pid> ) ]->
   [ State_2111111111212( L_pid, k, secretid, lock.2 ) ]

  /*
  rule (modulo AC) lookupLYubikeyLpidastc_1_211111111121[color=#805140,
                                                         process="lookup <'L_Yubikey', L_pid> as tc"]:
     [ State_211111111121( L_pid, k, secretid, lock ) ]
    --[ IsNotSet( <'L_Yubikey', L_pid> ) ]->
     [ State_2111111111212( L_pid, k, secretid, lock ) ]
  */

rule (modulo E) intc_0_2111111111211[color=#805140, process="in(tc);"]:
   [ State_2111111111211( L_pid, k, secretid, tc, lock.2 ), In( tc ) ]
  -->
   [ State_21111111112111( L_pid, k, secretid, tc, lock.2 ) ]

  /*
  rule (modulo AC) intc_0_2111111111211[color=#805140, process="in(tc);"]:
     [ State_2111111111211( L_pid, k, secretid, tc, lock ), In( tc ) ]
    -->
     [ State_21111111112111( L_pid, k, secretid, tc, lock ) ]
  */

rule (modulo E) insertLYubikeyLpidonetc_0_21111111112111[color=#805140,
                                                         process="insert <'L_Yubikey', L_pid>,('one'+tc);"]:
   [ State_21111111112111( L_pid, k, secretid, tc, lock.2 ) ]
  --[ Insert( <'L_Yubikey', L_pid>, ('one'+tc) ) ]->
   [ State_211111111121111( L_pid, k, secretid, tc, lock.2 ) ]

  /*
  rule (modulo AC) insertLYubikeyLpidonetc_0_21111111112111[color=#805140,
                                                            process="insert <'L_Yubikey', L_pid>,('one'+tc);"]:
     [ State_21111111112111( L_pid, k, secretid, tc, lock ) ]
    --[ Insert( <'L_Yubikey', L_pid>, ('one'+tc) ) ]->
     [ State_211111111121111( L_pid, k, secretid, tc, lock ) ]
  */

rule (modulo E) newnonce_0_211111111121111[color=#805140,
                                           process="new nonce;"]:
   [ State_211111111121111( L_pid, k, secretid, tc, lock.2 ), Fr( nonce ) ]
  -->
   [ State_2111111111211111( L_pid, k, nonce, secretid, tc, lock.2 ) ]

  /*
  rule (modulo AC) newnonce_0_211111111121111[color=#805140,
                                              process="new nonce;"]:
     [ State_211111111121111( L_pid, k, secretid, tc, lock ), Fr( nonce ) ]
    -->
     [ State_2111111111211111( L_pid, k, nonce, secretid, tc, lock ) ]
  */

rule (modulo E) newnpr_0_2111111111211111[color=#805140,
                                          process="new npr;"]:
   [
   State_2111111111211111( L_pid, k, nonce, secretid, tc, lock.2 ),
   Fr( npr )
   ]
  -->
   [ State_21111111112111111( L_pid, k, nonce, npr, secretid, tc, lock.2 ) ]

  /*
  rule (modulo AC) newnpr_0_2111111111211111[color=#805140,
                                             process="new npr;"]:
     [
     State_2111111111211111( L_pid, k, nonce, secretid, tc, lock ), Fr( npr )
     ]
    -->
     [ State_21111111112111111( L_pid, k, nonce, npr, secretid, tc, lock ) ]
  */

rule (modulo E) eventYubiPressLpidsecretidktc_0_21111111112111111[color=#805140,
                                                                  process="event YubiPress( L_pid, secretid, k, tc );"]:
   [ State_21111111112111111( L_pid, k, nonce, npr, secretid, tc, lock.2 ) ]
  --[ YubiPress( L_pid, secretid, k, tc ) ]->
   [ State_211111111121111111( L_pid, k, nonce, npr, secretid, tc, lock.2 )
   ]

  /*
  rule (modulo AC) eventYubiPressLpidsecretidktc_0_21111111112111111[color=#805140,
                                                                     process="event YubiPress( L_pid, secretid, k, tc );"]:
     [ State_21111111112111111( L_pid, k, nonce, npr, secretid, tc, lock ) ]
    --[ YubiPress( L_pid, secretid, k, tc ) ]->
     [ State_211111111121111111( L_pid, k, nonce, npr, secretid, tc, lock ) ]
  */

rule (modulo E) outLpidnoncesencsecretidtcnprk_0_211111111121111111[color=#805140,
                                                                    process="out(<L_pid, nonce, senc(<secretid, tc, npr>, k)>);"]:
   [ State_211111111121111111( L_pid, k, nonce, npr, secretid, tc, lock.2 )
   ]
  -->
   [
   State_2111111111211111111( L_pid, k, nonce, npr, secretid, tc, lock.2 ),
   Out( <L_pid, nonce, senc(<secretid, tc, npr>, k)> )
   ]

  /*
  rule (modulo AC) outLpidnoncesencsecretidtcnprk_0_211111111121111111[color=#805140,
                                                                       process="out(<L_pid, nonce, senc(<secretid, tc, npr>, k)>);"]:
     [ State_211111111121111111( L_pid, k, nonce, npr, secretid, tc, lock ) ]
    -->
     [
     State_2111111111211111111( L_pid, k, nonce, npr, secretid, tc, lock ),
     Out( <L_pid, nonce, senc(<secretid, tc, npr>, k)> )
     ]
  */

rule (modulo E) unlockYubikeyLpid_0_2111111111211111111[color=#805140,
                                                        process="unlock <'Yubikey', L_pid>;"]:
   [ State_2111111111211111111( L_pid, k, nonce, npr, secretid, tc, lock.2 )
   ]
  --[
  Unlock_2( '2', lock.2, <'Yubikey', L_pid> ),
  Unlock( '2', lock.2, <'Yubikey', L_pid> )
  ]->
   [
   State_21111111112111111111( L_pid, k, nonce, npr, secretid, tc, lock.2 )
   ]

  /*
  rule (modulo AC) unlockYubikeyLpid_0_2111111111211111111[color=#805140,
                                                           process="unlock <'Yubikey', L_pid>;"]:
     [ State_2111111111211111111( L_pid, k, nonce, npr, secretid, tc, lock ) ]
    --[
    Unlock_2( '2', lock, <'Yubikey', L_pid> ),
    Unlock( '2', lock, <'Yubikey', L_pid> )
    ]->
     [ State_21111111112111111111( L_pid, k, nonce, npr, secretid, tc, lock )
     ]
  */

rule (modulo E) p_0_21111111112111111111[color=#805140, process="0"]:
   [
   State_21111111112111111111( L_pid, k, nonce, npr, secretid, tc, lock.2 )
   ]
  -->
   [ ]

  /*
  rule (modulo AC) p_0_21111111112111111111[color=#805140, process="0"]:
     [ State_21111111112111111111( L_pid, k, nonce, npr, secretid, tc, lock )
     ]
    -->
     [ ]
  */

rule (modulo E) p_0_2111111111212[color=#805140, process="0"]:
   [ State_2111111111212( L_pid, k, secretid, lock.2 ) ] --> [ ]

  /*
  rule (modulo AC) p_0_2111111111212[color=#805140, process="0"]:
     [ State_2111111111212( L_pid, k, secretid, lock ) ] --> [ ]
  */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒ (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_Not_Eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction locking_0:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_0( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_0( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_1:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_1( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_1( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction locking_2:
  "∀ p pp l x lp #t1 #t3.
    ((Lock_2( p, l, x ) @ #t1) ∧ (Lock( pp, lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock_2( p, l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0 pp.1. (Unlock( pp.1, l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ pp.1 lpp #t0.
            (Lock( pp.1, lpp, x ) @ #t0) ⇒
            (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ pp.1 lpp #t0.
           (Unlock( pp.1, lpp, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: examples/sapic/slow/Yubikey/Yubikey.spthy

------------------------------------------------------------------------------
analyzed: examples/sapic/slow/Yubikey/Yubikey.spthy

  output:          examples/sapic/slow/Yubikey/Yubikey.spthy.tmp
  processing time: 37.739510996s
  init_server (all-traces): verified (148 steps)
  init_server_secrecy (all-traces): verified (191 steps)
  init_yubikey (all-traces): verified (63 steps)
  one_count_foreach_login (all-traces): verified (88 steps)
  no_replay (all-traces): verified (2 steps)
  injective_correspondance (all-traces): verified (6 steps)
  Login_invalidates_smaller_counters (all-traces): verified (340 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: examples/sapic/slow/Yubikey/Yubikey.spthy

  output:          examples/sapic/slow/Yubikey/Yubikey.spthy.tmp
  processing time: 37.739510996s
  init_server (all-traces): verified (148 steps)
  init_server_secrecy (all-traces): verified (191 steps)
  init_yubikey (all-traces): verified (63 steps)
  one_count_foreach_login (all-traces): verified (88 steps)
  no_replay (all-traces): verified (2 steps)
  injective_correspondance (all-traces): verified (6 steps)
  Login_invalidates_smaller_counters (all-traces): verified (340 steps)

==============================================================================
*/
