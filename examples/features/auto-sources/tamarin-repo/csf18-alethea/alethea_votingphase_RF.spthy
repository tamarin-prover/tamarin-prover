theory alethea_votingphase_RF
begin

/*
============
INTRODUCTION
============
Protocol: Alethea's voting phase
Modeler: Lara Schmid
Described in:[1] Alethea: A Provably Secure Random Sample Voting Protocol, David Basin, Sasa Radomirovic, and Lara Schmid,CSF18.
Date: 30th April 2018


The file contains: 
- a short explanation of the modeled version, 
- the model in Alice & Bob notation, where we denote by ->, *->, ->*, and *->* insecure, authentic, confidential, and secure channels, respectively (see [1]),
- a list of the results (with references to the lemmas in [1]),
- the Tamarin protocol specification, the restrictions, and the lemmas.


========
Version:
========
This file models Alethea's voting phase with an honest server and a changed human role to consider receipt-freeness (see [1], Definition 12).
We model that a voter sends all his secrets to the adversary as follows: Whenever the voter learns a new term (including his initial knowledge), he also sends this term to the adversary by an "Out()" fact. 
Note that in the rules H_2 and H_3, everything that is newly learned by the voter is already known to the adversary or anyways sent to the adversary. Therefore we need not include any additional "Out()" facts.

As S is honest, we can optimize the efficiency of the model by leaving away or merging rules. We make the following simplifications:
- BB and S are modeled in the same role "S". (With an honest S, the BB's content always agrees with the knowledge of S)
- we do not model the auditors and not test the universal verifiability properties. (An honest S always behaves as expected)
- we merge the rule H_1 (the first rule of the voter) into the setup rule. (The transition from the setup rule to the rule H_1 only forwards the knowledge of the voter. As the adversary in our model cannot see/change the internal storage of the voter, there is no difference in including these facts in the same or in two differnet rules.)

Note that the following (crucial) things are modeled as with a malicious server:
- whatever the auditors would read on BB is still on BB (now modeled in same role as S). This allows the adversary to read and use this information.
- the platform P is malicious.



==========================
Alice & Bob specification: 
==========================
0. S		: knows(skS,H,D,x,ind)  //BB=S
0. H		: knows(D,S,vote,y)     //BB=S
0. D		: knows(S,H,pkS,~x,ind) //BB=S
0. BB		: ySG

1. H *->* D	: vote
2. D *->* H	: H, <cp(<vote,h(x,ind)>,pk(S)),cp(<h(H,x),h(x)>,pk(skS))>,ind
		  / H, code, ind
3. H -> P	: code, ind
4. P -> S	: code, ind /
		  < cp(<vote,h(x,ind)>,pk(S)) , cp(<h(H,x),h(x)>,pk(skS))>,ind
5. S *->  	: < cp(<vote,h(x,ind)>,pk(S)) , cp(<h(H,x),h(x)>,pk(skS))>'s,
			votes, pVs, pYs, yPrime, proofV, proofY

6. (S)*->  H	: codes



========================================
RESULTS: (aut) = automatically proven
this model was analyzed with the oracle 
"oracle_alethea_votingphase_RF"
========================================

- lemma functional: 			  LHS = verified; RHS = verified (aut)
- lemma secret_skS [sources]:  		  LHS = verified; RHS = verified (aut)
- INDIVIDUAL VERIFIABILITY  ([1] Lemma 7)
	- lemma indivVerif: 		  LHS = verified; RHS = verified (aut)
- OBSERVATIONAL EQUIVALENCE ([1] Lemma 12)
	- lemma Observational_equivalence: verified (aut)

Additional Lemmas:
==================
- SECRECY CLAIMS
	- lemma secret_x: 		  LHS = verified; RHS = verified (aut)
- AGREEMENTS
	- lemma agreementHwrtS: 	  LHS = verified; RHS = verified (aut)
	- lemma agreementSwrtH_vote: 	  LHS = verified; RHS = verified (aut)
	- lemma agreementSwrtH_code:  	  LHS = verified; RHS = verified (aut)


*/

/*============
SPECIFICATION:
============== */

/*=======
built-ins 
========= */
builtins: signing, asymmetric-encryption, hashing, symmetric-encryption, multiset
functions: cp/2,  PeqPVote/3, PeqPY/3, dcp/2

equations: 
dcp(cp(x,pk(sk)),sk)=x     //we abstract away the randomness r as we do not need it 

/* ==========
Channel rules
============= */

rule ChanOut_S: [Out_S($A,$B,x)]--[ChanOut_S($A,$B,x)]->[!Sec($A,$B,x)]
rule ChanIn_S: [!Sec($A,$B,x)]--[ChanIn_S($A,$B,x)]->[In_S($A,$B,x)]
/*
rule ChanOut_C:	[Out_C($A,$B,x)]--[ChanOut_C($A,$B,x)]->[!Conf($B,x)]
rule ChanIn_C:	[!Conf($B,x), In($A)]--[ChanIn_C($A,$B,x)]->[In_C($A,$B,x)]
rule ChanIn_CAdv: [In(<$A,$B,x>)]--[]->[In_C($A,$B,x)]
*/
rule ChanOut_A: [Out_A($A,x)]--[ChanOut_A($A,x)]->[!Auth($A,x), Out(<$A,x>)]
rule ChanIn_A:	[!Auth($A,x)]--[ChanIn_A($A,x)]->[In_A($A,x)]


rule publickeyinfrastructure:
  [ Fr(~skX) ]--[ LongtermKey($X,~skX) ]-> [ !Ltk($X,~skX), !Pk($X,pk(~skX)), Out(pk(~skX)) ]

/* =====
Protocol
======== */
rule Setup: 
  	[ !Ltk('S',~skS), Fr(~x1), Fr(~x2)  ] 
  	--[ 	Setup()
		, SKS(~skS)
		, HV('1',h(<~x1,$ind1>)), HV('2',h(<~x2,$ind2>)), HY('1',h(~x1)), HY('2',h(~x2))
		, V('1',diff($vote1,$vote2)), V('2',diff($vote2,$vote1))
	
		//voters' votes
		, Vote('H1',diff($vote1,$vote2))
		, Vote('H2',diff($vote2,$vote1))
	]-> 
  	[ 
	  AgSt_S0('S',< ~skS,'H1','H2','D1','D2',~x1,~x2, $ind1, $ind2 >) 
	
	, AgSt_D0('D1',< 'S', 'H1',pk(~skS),~x1,$ind1 >)
	, AgSt_D0('D2',< 'S', 'H2',pk(~skS),~x2,$ind2 >)

	, Out_A('S',<'ySG',h('H1',~x1)+h('H2',~x2) >)  

	// former rule H_1:
	, AgSt_H1('H1',< 'D1','S',diff($vote1,$vote2), h('H1',~x1)>)
	, AgSt_H1('H2',< 'D2','S',diff($vote2,$vote1), h('H2',~x2)>)
	, Out_S('H1','D1',<diff($vote1,$vote2)>)
	, Out_S('H2','D2',<diff($vote2,$vote1)>)

	// for receipt-freeness: H1 communicates everything he know to the adversary, except that he always sends the same vote ($vote1)
	, Out(<'D1','S',$vote1, h('H1',~x1)>)
	]

rule D_1:
	[ AgSt_D0($D,<$S,$H,pkS,~x,$ind >), In_S($H,$D,vote) ]
	--[ 	Secret_x(~x)  ]->
	[ Out_S($D,$H,<$H,< cp(<vote,h(~x,$ind)>,pkS),
			    cp(<h($H,~x),h(~x)>,pkS)>,
		  	$ind
			>)
	]

rule H_2:
	[ AgSt_H1($H,<$D,$S,vote,y>), In_S($D,$H,<$H,code,ind>) ]
	--[	MyCode($H,code),
		Comm_H_C($H,$S,code),
	   	Comm_H_V($H,$S,vote) 
	]->
	[ AgSt_H2($H,<$D,$S,vote,y,ind,code>), 	  
          Out(<code, ind>)
	// everything that H newly learns is already sent to the adversary, no extra "Out()" needed
	]
rule S:   
	[ AgSt_S0($S,< ~skS,$H1,$H2,$D1,$D2,~x1,~x2, $ind1, $ind2 >) ,
          In(<<	cp(<$vote1,h(~x1,$ind1)>,pk(~skS)), cp(<h($H1,~x1),h(~x1)>,pk(~skS))>, $ind1>), 
	  In(<<	cp(<$vote2,h(~x2,$ind2)>,pk(~skS)), cp(<h($H2,~x2),h(~x2)>,pk(~skS))>, $ind2>)
	]
 	--[	Learn_S_C($S,$H1,<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),
			   	  cp(<h($H1,~x1),h(~x1)>,pk(~skS))>), 
		Learn_S_C($S,$H2,<cp(<$vote2,h(~x2,$ind2)>,pk(~skS)),
		 		  cp(<h($H2,~x2),h(~x2)>,pk(~skS))>), 
		Learn_S_V($S,$H1,$vote1),
		Learn_S_V($S,$H2,$vote2), 
	
		Comm_S_C($S,<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),cp(<h($H1,~x1),h(~x1)>,pk(~skS))>),
		Comm_S_C($S,<cp(<$vote2,h(~x2,$ind2)>,pk(~skS)),cp(<h($H2,~x2),h(~x2)>,pk(~skS))>),
		
		// use the constant 'BB' s.t. facts are of the same form as with a malicious server
		// as S and BB are honest, S posts all these terms to BB and they are received and posted on BB	
		BB_V('1','BB',$vote1),
		BB_V('2','BB',$vote2),
		BB_pV('1','BB',<$vote1,h(~x1,$ind1)>),
		BB_pV('2','BB',<$vote2,h(~x2,$ind2)>),
		BB_pY('1','BB',<h($H1,~x1),h(~x1)>),
		BB_pY('2','BB',<h($H2,~x2),h(~x2)>),
		BB_C('1','BB',<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),cp(<h($H1,~x1),h(~x1)>,pk(~skS))>),
		BB_C('2','BB',<cp(<$vote2,h(~x2,$ind2)>,pk(~skS)),cp(<h($H2,~x2),h(~x2)>,pk(~skS))>),
		BB_Cs('BB',<'codes',<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),cp(<h($H1,~x1),h(~x1)>,pk(~skS))>
			  	   +<cp(<$vote2,h(~x2,$ind2)>,pk(~skS)),cp(<h($H2,~x2),h(~x2)>,pk(~skS))>>),
		BB_proofV('BB',PeqPVote(<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),
		      	   		   cp(<$vote2,h(~x2,$ind2)>,pk(~skS))>,
					     <<$vote1,h(~x1,$ind1)>,<$vote2,h(~x2,$ind2)>>,~skS)),
		BB_proofY('BB',PeqPY(<cp(<h($H1,~x1),h(~x1)>,pk(~skS)),
			        	cp(<h($H2,~x2),h(~x2)>,pk(~skS))>,
					  <<h($H1,~x1),h(~x1)>,<h($H2,~x2),h(~x2)>>,~skS))
	]->  
	[ Out_A($S,<'votes',$vote1+$vote2>)
	, Out_A($S,<'pVs',<$vote1,h(~x1,$ind1)>+<$vote2,h(~x2,$ind2)>>)
	, Out_A($S,<'pYs',<h($H1,~x1),h(~x1)>+<h($H2,~x2),h(~x2)> >)
	, Out_A($S,<'yPrime', h($H1,~x1)+h($H2,~x2)>)
	, Out_A($S,<'codes',
		<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),cp(<h($H1,~x1),h(~x1)>,pk(~skS))>
		+<cp(<$vote2,h(~x2,$ind2)>,pk(~skS)),cp(<h($H2,~x2),h(~x2)>,pk(~skS))> 
		>)
	, Out_A($S,<'proofV',
		 PeqPVote(<cp(<$vote1,h(~x1,$ind1)>,pk(~skS)),
		      	   cp(<$vote2,h(~x2,$ind2)>,pk(~skS))>,
			<<$vote1,h(~x1,$ind1)>,<$vote2,h(~x2,$ind2)>>,~skS)>)
        , Out_A($S,<'proofY',
		 PeqPY(<cp(<h($H1,~x1),h(~x1)>,pk(~skS)),
			cp(<h($H2,~x2),h(~x2)>,pk(~skS))>,
			<<h($H1,~x1),h(~x1)>,<h($H2,~x2),h(~x2)>>,~skS)>)
	]

rule H_3: 
	[ AgSt_H2($H,<$D,$S,vote,y,ind,code>)
	, In_A($S,<'codes',mycodeBB+codeBBOther >) 
	]
	--[	 Learn_H_C($H,$S,mycodeBB)
	]->
	[ // everything that H newly learns is already known to the adversary who can read it on BB, no extra "Out()" needed
	]


/* ====
RESTRICTIONS
====== */
// there is only one setup
restriction OneSetup: 
	"All #i #j. Setup() @i & Setup() @j ==> #i = #j "

/* ==========
SOURCES LEMMAS 
============= */
 
// the adversary does not learn S's secret key
lemma secret_skS [sources]:
	"All skS #i.  SKS(skS) @i ==> 
		not(Ex #j. K(skS) @j)	"


/* ====
LEMMAS 
======= */
/* =================
functionality lemmas
==================== */

lemma functional: exists-trace
	" Ex #i #j #k H1 H2 S vote1 vote2 fstcode1 sndcode1 fstcode2 sndcode2 skS
				hV1 hV2 y1 y2 hY1 hY2 #l #m #s 
				
		.
		not (H1 = H2) & not (vote1 = vote2)
		& Comm_H_C(H1,S,<fstcode1,sndcode1>) @i
		& Comm_H_V(H1,S,vote1) @i
		& Comm_H_C(H2,S,<fstcode2,sndcode2>) @j
		& Comm_H_V(H2,S,vote2) @j
		
		& HV('1',hV1) @s 
		& V('1',vote1) @s
		& HV('2',hV2) @s 
		& V('2',vote2) @s
		& HY('1',hY1) @s 
		& HY('2',hY2) @s

		& BB_C('1','BB',<fstcode1,sndcode1>) @k
		& BB_C('2','BB',<fstcode2,sndcode2>) @k
		& BB_V('1','BB',vote1) @k	
		& BB_V('2','BB',vote2) @k
		& BB_pV('1','BB',<vote1,hV1>) @k
		& BB_pV('2','BB',<vote2,hV2>) @k
		& BB_proofV('BB',PeqPVote(<fstcode1,fstcode2>,<<vote1,hV1>,<vote2,hV2>>,skS) ) @k
		& BB_pY('1','BB',<y1,hY1>) @k
		& BB_pY('2','BB',<y2,hY2>) @k
		& BB_proofY('BB',PeqPY(<sndcode1,sndcode2>,<<y1,hY1>,<y2,hY2>>,skS) ) @k	
 	    	
		& Learn_H_C(H1,S,<fstcode1,sndcode1>) @l
		& Learn_H_C(H2,S,<fstcode2,sndcode2>) @m
		"

/* =====================
individual verifiability
======================== */

lemma indivVerif: //If voter finds his code on BB => his code (representing his vote) is on BB, that is the vote is registered
	"All H S vote fstcode sndcode #i2 #i #j .
		Vote(H,vote) @i2 					// this is voter's vote
		//verify(H,<fstcode,sndcode> in [code], true)
		& MyCode(H,<fstcode,sndcode>) @i  			// this is voter's code, as learned by the device
		& Learn_H_C(H,S,<fstcode,sndcode>) @j			// voter reads his code in list [code] from BB
	==> Ex BB #k hV pkS codeOther . 
		BB_Cs(BB,<'codes', <fstcode,sndcode>+codeOther>) @k 	// code contained in list on BB
		& fstcode = cp(<vote,hV>,pkS) "      			// code correctly represents H's vote

/* =============
ADDITONAL LEMMAS 
================ */
/* ===========
secrecy claims
============== */
//(not in [1]) with an honest S, the voter secret is not learned by the adversary
lemma secret_x:
	"All x #i.  Secret_x(x) @i ==>  not(Ex #j. K(x) @j)	"

/* =======
agreements
========== */
//(not in [1]) with an honest S, there is some agreement beween H and S

//agreement from H wrt S (all that read from BB is authentically from S)
lemma agreementHwrtS:
" (All H S x #i. Learn_H_C(H,S,x) @i 	==> Ex #j. Comm_S_C(S,x) @j & j<i)" 


// agreement from S wrt H
lemma agreementSwrtH_vote:
" All H S x #i. Learn_S_V(S,H,x) @i	==> Ex #j. Comm_H_V(H,S,x) @j & j<i "

lemma agreementSwrtH_code: 
"All H S x #i. Learn_S_C(S,H,x) @i 	==> Ex #j. Comm_H_C(H,S,x) @j & j<i"


end






















