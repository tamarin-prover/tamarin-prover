/*
  Example for the Tamarin Prover
  ==============================

  Authors:        Jannik Dreier
  Date:           April 2020
  Time:             ??

  Description from SPORE:
  (http://www.lsv.fr/Software/spore/otwayRees.html)

  Otway Rees

  Summary: Distribution of a shared symmetric key by a trusted server. Symmetric key cryptography with server.

  Protocol specification (in common syntax)
  A, B, S :  	principal
  M, Na, Nb :  	nonce
  Kas, Kbs, Kab :  	key

  1.  	A	->	B	:  	M, A, B, {Na, M, A, B}Kas
  2.  	B	->	S	:  	M, A, B, {Na, M, A, B}Kas , {Nb, M, A, B}Kbs
  3.  	S	->	B	:  	M, {Na, Kab}Kas, {Nb, Kab}Kbs
  4.  	B	->	A	:  	M, {Na, Kab}Kas

  Description of the protocol rules
  The nonce M identifies the session number.

  Kas and Kbs are symmetric keys whose values are initially known only by A and S, respectively B and S.

  Kab is a fresh symmetric key generated by S in message 3 and distributed to B, directly in message 3, and to A, indirectly, when B forwards blindly {Na, Kab}Kas to A in message 4.

  Requirements
  The protocol must guaranty the secrecy of Kab: in every session, the value of Kab must be known only by the participants playing the roles of A, B and S.

  When A, resp. B, receives the key Kab in message 3, resp. 2, this key must have been issued in the same session by the server S with whom B has started to communicate in message 2.

  Claimed attacks
  Type flaw in [CJ97], where A will accept in last message 4 the triple (M, A, B) as a fresh key Kab.
  1.  	A	->	I(B)	:  	M, A, B, {Na, M, A, B}Kas
  2.  	B	->	S	:  	M, A, B, {Na, M, A, B}Kas , {Nb, M, A, B}Kbs
  3.  	S	->	B	:  	M, {Na, Kab}Kas, {Nb, Kab}Kbs
  4.  	I(B)	->	A	:  	M, {Na, M, A, B}Kas

  We consider here the tagged version of this protocol.
*/

theory Otway_Rees
begin

builtins: symmetric-encryption

// ====================
// == General rules ===
// ====================

// A and B already share a long-term symmetric key with S

rule Init:
  [ Fr(~kxs)]
  --[KeyGen($X)]->
  [ !LongtermKey(~kxs,$X) ]

rule Reveal_Longterm_Key:
    [ !LongtermKey(~sk,$A)]
  --[ Reveal($A)]->
    [ Out(~sk) ]

// ====================
// == Protocol rules ==
// ====================

// 1.  	A	->	B	:  	M, A, B, {Na, M, A, B}Kas
rule A_1:
  let msg = <~m, $A, $B, senc(<'1', ~na, ~m, $A, $B>,~kas)> in
  [ Fr(~m)
  , Fr(~na)
  , !LongtermKey(~kas,$A)
  ] --[ Running_A($A,$B, <~m,~na>) ]->
  [ Out(msg)
  , StateA($A, $B, ~m, ~na, ~kas)
  ]

// 2.  	B	->	S	:  	M, A, B, {Na, M, A, B}Kas , {Nb, M, A, B}Kbs
rule B_1:
  let msg  = <m, a, $B, c>
      msg2 = <m, a, $B, c, senc(<'2', ~nb, m, a, $B>,~kbs)> in
  [ In(msg)
  , !LongtermKey(~kbs,$B)
  , Fr(~nb)
  ]
  --[ Running_B(a,$B, <m,~nb>) ]->
  [ Out(msg2)
  , StateB(a, $B, m, ~nb, ~kbs) ]

// 3.  	S	->	B	:  	M, {Na, Kab}Kas, {Nb, Kab}Kbs
rule S:
  let msg  = <m, a, b, senc(<'1', na, m, a, b>,~kas), senc(<'2', nb, m, a, b>,~kbs)>
      msg2 = <m, senc(<'3', na, ~kab>,~kas), senc(<'4', nb, ~kab>,~kbs)> in
  [ Fr(~kab)
  , !LongtermKey(~kas,a)
  , !LongtermKey(~kbs,b)
  , In(msg)
  ]
  --[ Secret(a, b, ~kab)
    , Running_S(a,b, <m,~kab>)
    , Commit_S_A(a,b, <m,na>)
    , Commit_S_B(a,b, <m,nb>) ]->
  [ Out(msg2) ]

// 4.   B	->	A	:  	M, {Na, Kab}Kas
rule B_2:
  let msg  = <m, c, senc(<'4', ~nb, kab>,~kbs)>
      msg2 = <m, c> in
  [ !LongtermKey(~kbs,$B)
  , In(msg)
  , StateB(a, $B, m, ~nb, ~kbs)
  ]
  --[ Commit_B(a,$B, <m,kab>)
    , Secret(a,$B, kab)]->
  [ Out(msg2) ]

// 4.   B	->	A	:  	M, {Na, Kab}Kas
rule A_2:
  let msg = <~m, senc(<'3', ~na, kab>,~kas)> in
  [ !LongtermKey(~kas,$A)
  , In(msg)
  , StateA($A, $B, ~m, ~na, ~kas)
  ]
  --[ Commit_A($A,$B, <~m,kab>)
    , Secret($A,$B, kab)]->
  []

// ====================
// ====== Lemmas ======
// ====================

// check the secrecy of a secret x protected by the long-term key of A and B
lemma Secrecy:
  "
    not(
      Ex A B m #i .
        Secret(A, B, m)@ #i
        & (Ex #r. K(m) @ #r)
        & not(Ex #r. Reveal(B) @ #r)
        & not(Ex #r. Reveal(A) @ #r)
    )
  "

// check the authenticity and freshness of the transaction from B's point of view
lemma injectiveagreement_B:
   "All A B t #i.
     Commit_B(A,B,t) @i
     ==> (Ex #j. Running_S(A,B,t) @j
         & j < i
         & not (Ex A2 B2 #i2. Commit_B(A2,B2,t) @i2
                            & not (#i2 = #i)))
               | (Ex #r. Reveal(A)@r)
               | (Ex #r. Reveal(B)@r)"

// check the authenticity of the transaction from B's point of view
lemma agreement_B:
  "All A B t #i.
    Commit_B(A,B,t) @i
    ==> (Ex #j. Running_S(A,B,t) @j  & j < i)
              | (Ex #r. Reveal(A)@r)
              | (Ex #r. Reveal(B)@r)"

// check the authenticity and freshness of the transaction from A's point of view
lemma injectiveagreement_A:
   "All A B t #i.
     Commit_A(A,B,t) @i
     ==> (Ex #j. Running_S(A,B,t) @j
         & j < i
         & not (Ex A2 B2 #i2. Commit_A(A2,B2,t) @i2
                            & not (#i2 = #i)))
               | (Ex #r. Reveal(A)@r)
               | (Ex #r. Reveal(B)@r)"

// check the authenticity of the transaction from A's point of view
lemma agreement_A:
  "All A B t #i.
    Commit_A(A,B,t) @i
    ==> (Ex #j. Running_S(A,B,t) @j  & j < i)
              | (Ex #r. Reveal(A)@r)
              | (Ex #r. Reveal(B)@r)"

// check the authenticity and freshness of the transaction from the server's point of view
lemma injectiveagreement_S:
   "(All A B t #i.
     Commit_S_A(A,B,t) @i
     ==> (Ex #j. Running_A(A,B,t) @j
         & j < i
         & not (Ex A2 B2 #i2. Commit_S_A(A2,B2,t) @i2
                            & not (#i2 = #i)))
               | (Ex #r. Reveal(A)@r)
               | (Ex #r. Reveal(B)@r))
  & (All A B t #i.
     Commit_S_B(A,B,t) @i
     ==> (Ex #j. Running_B(A,B,t) @j
         & j < i
         & not (Ex A2 B2 #i2. Commit_S_B(A2,B2,t) @i2
                            & not (#i2 = #i)))
               | (Ex #r. Reveal(A)@r)
               | (Ex #r. Reveal(B)@r))"

// check the authenticity of the transaction from the server's point of view
lemma agreement_S:
  "(All A B t #i.
    Commit_S_A(A,B,t) @i
    ==> (Ex #j. Running_A(A,B,t) @j  & j < i)
              | (Ex #r. Reveal(A)@r)
              | (Ex #r. Reveal(B)@r))
  & (All A B t #i.
    Commit_S_B(A,B,t) @i
    ==> (Ex #j. Running_B(A,B,t) @j  & j < i)
              | (Ex #r. Reveal(A)@r)
              | (Ex #r. Reveal(B)@r))"

// sanity check: check if honest execution is possible
lemma executability:
 exists-trace
 "// To simplify the proof, consider only executions where all the events are unique
 (All A A2 B B2 t t2 #i #j.(
    Running_A(A, B, t) @ #i
  & Running_A(A2, B2, t2) @ #j
  ==> #i = #j))
 &
 (All A A2 B B2 t t2 #i #j.(
    Running_B(A, B, t) @ #i
  & Running_B(A2, B2, t2) @ #j
  ==> #i = #j))
 &
 (All A A2 B B2 t t2 #i #j.(
    Running_S(A, B, t) @ #i
  & Running_S(A2, B2, t2) @ #j
  ==> #i = #j))
 &
 (All A A2 B B2 t t2 #i #j.(
    Commit_A(A, B, t) @ #i
  & Commit_A(A2, B2, t2) @ #j
  ==> #i = #j))
 &
 (All A A2 B B2 t t2 #i #j.(
    Commit_B(A, B, t) @ #i
  & Commit_B(A2, B2, t2) @ #j
  ==> #i = #j))
 &
 // We want an execution with all for events, and no corruption
 ( Ex A B t t2 t3 #i #j #k #l #m.
   Running_A(A,B,t)@#i
 & Running_B(A,B,t2)@#j & #i<#j
 & Running_S(A,B,t3)@#k & #j<#k
 & Commit_B(A,B,t3)@#l & #k<#l
 & Commit_A(A,B,t3)@#m & #l<#m
 & not(Ex #r1. Reveal(A)@#r1)
 & not(Ex #r2. Reveal(B)@#r2)
 )"

end
