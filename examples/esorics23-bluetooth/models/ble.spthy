theory BluetoothLowEnergyPairing
begin

builtins: diffie-hellman, symmetric-encryption

functions:
    aes_cmac/2, // Interface is aes_cmac(key, data)
    f4/4,
    g2/4,
    f5_mackey/6,
    f5_ltk/6,
    f6/7,
    c1/8, // Function used in Legacy Pairing
    s1/3, // Function used in Legacy Pairing
    split1/1,
    split2/1,
    recover/2,
    low_entropy/1,
    reduce_key/2,
    e/3,
    extract_e/1

equations:
    f4(u,v,x,z) = aes_cmac(x,<u,v,z>), // f4 according to the spec (Vol 3 Part H, 2.2.6)
    g2(u,v,x,y) = aes_cmac(x,<u,v,y>), // g2 according to the spec (Vol 3 Part H, 2.2.9, p.994
    //f5_mackey(w,n1,n2,kid,a1,a2) = aes_cmac(aes_cmac(w, 'salt'), <'0',n1, n2, kid, a1, a2>), // f5 according to the spec (Vol 3 Part H, 2.2.7) <- Tamarin doesn't like constants in equations
    //f5_ltk(w, n1, n2, kid, a1, a2) = aes_cmac(aes_cmac(w, 'salt'), <'1',n1, n2, kid, a1, a2>), // f5 according to the spec (Vol 3 Part H, 2.2.7) <- Tamarin doesn't like constats in equations
    f6(w, n1, n2, r, iocap, a1, a2) = aes_cmac(w, <n1, n2, r, iocap, a1, a2>), // f6 according to the spec (Vol 3 Part H 2.2.8)
    recover(split1(x), split2(x)) = x, // Allow the attacker to reconstruct the passkey from two halves
    extract_e(e(t,s,n)) = n // Representation of a public key, allows the extraction of the public component

#ifdef NoMalleableC1
#else
functions:
    get_nonce/8

equations:
    c1(x, get_nonce(cf, x, b, c, d, e, f, g), b, c, d, e, f, g) = cf, // A representation of Rosa's attack on Legacy Pairing malleable commitment
    get_nonce(c1(x, n, b, c, d, e, f, g), x, b, c, d, e, f, g) = n // A representation of Rosa's attack on Legacy Pairing malleable commitment
#endif

rule CreateDevice:
     []
     --[]->
     [!Device(<$id,$cap,'strong'>), // Represents a device
      Out(<$id,$cap,'strong'>)] // The device announces itself (sort of)
      // 'strong": by default, devices want to have a strong key, i.e. 16 bytes

/*
This represents the messages leading to Pairing (it is very simplified).
Here, the Initiator receives the responder's address and capabilities,
the Responder receives the Initiator's address and capabilities.
*/
rule InitPreparePairing:
    [
    !Device(<$idI, $capI, $keysizeI>),
    In(<$idR, $capR, $keysizeR>)
    ]
    --[
        InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]->
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]

rule RespPreparePairing:
    [
    !Device(<$idR, $capR, $keysizeR>),
    In(<$idI, $capI, $keysizeI>)
    ]
    --[
        RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]->
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]

/*
* Select the Pairing method. Here, it is one of :
* - Legacy JustWorks (LegJW)
* - Legacy Passkey Entry (LegPE)
* - Legacy Out of Band (LegOOB)
* - Secure JustWorks (SecJW)
* - Secure Passkey Entry (SecPE)
* - Secure NumericComparison (SecNC)
* - Secure Out of Band (SecOOB)
*
* The model restricts the choice to one Pairing method per role (Initiator or Responder)
* through the restrictions InitOnlyOncePairing / RespOnlyOncePairing
* Therefore, only one session can be ran. While not ideal, this prevents a state explosion :
* Even with a much simpler model (one Pairing method), Tamarin runs out of RAM when studying
* an unbounded number of sessions
*
* Possibility: Change the model to create a bounded number of sessions
*/

#ifdef InitLegJW
rule InitPrepareLegJW:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitOnlyOncePairing(),
    InitWillDoLegJW()
    ]->
    [
    InitDoLegJW($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespLegJW
rule RespPrepareLegJW:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespOnlyOncePairing(),
    RespWillDoLegJW()
    ]->
    [
    RespDoLegJW($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif


#ifdef InitLegPE
rule InitPrepareLegPE:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitOnlyOncePairing(),
    InitWillDoLegPE()
    ]->
    [
    InitChooseLegPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespLegPE
rule RespPrepareLegPE:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespOnlyOncePairing(),
    RespWillDoLegPE()
    ]->
    [
    RespChooseLegPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitLegOOB
rule InitPrepareLegOOB:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitOnlyOncePairing(),
    InitWillDoLegOOB()
    ]->
    [
    InitDoLegOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespLegOOB
rule RespPrepareLegOOB:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespOnlyOncePairing(),
    RespWillDoLegOOB()
    ]->
    [
    RespDoLegOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitSecJW
rule InitPrepareSecJW:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecJW()
    ]->
    [
    InitDoSecJW($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecJW
rule RespPrepareSecJW:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecJW()
    ]->
    [
    RespDoSecJW($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitSecPE
rule InitPrepareSecPE:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecPE()
    ]->
    [
    InitDoSecPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitChooseSecPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecPE
rule RespPrepareSecPE:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecPE()
    ]->
    [
    RespDoSecPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespChooseSecPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitSecNC
rule InitPrepareSecNC:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecNC()
    ]->
    [
    InitDoSecNC($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecNC
rule RespPrepareSecNC:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecNC()
    ]->
    [
    RespDoSecNC($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitSecOOB
rule InitPrepareSecOOB:
    [
    InitPreparePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecOOB()
    ]->
    [
    InitDoSecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitChooseOOBMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecOOB
rule RespPrepareSecOOB:
    [
    RespPreparePairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecOOB()
    ]->
    [
    RespDoSecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespChooseOOBMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

/*
 * This dispatches the Initiator and Responder to the chosen variant
 * of the PE Pairing method.
 * The possibility are:
 * - PEi : Passkey Entry, can take inputs from the user
 * - PEo : Passkey Entry, device outputs to the user
 * - PEio : Passkey Entry, device can take inputs or outputs to the user
*/

#ifdef InitLegPEi
rule InitDoLegPEi:
    [
    InitChooseLegPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitLegPEOnlyOnce(),
    InitWillDoLegPEi()
    ]->
    [
    InitWaitUserInput(),
    InitTriggerUserInteraction(),
    InitReadyPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitLegPEo
rule InitDoLegPEo:
    [
    InitChooseLegPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~passkey)
    ]
    --[
    InitLegPEOnlyOnce(),
    InitWillDoLegPEo()
    ]->
    [
    InitWaitUserConfirm(~passkey),
    InitTriggerUserInteraction(),
    InitReadyPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitLegPEio
rule InitDoLegPEio:
    [
    InitChooseLegPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~passkey)
    ]
    --[
    InitLegPEOnlyOnce(),
    InitWillDoLegPEio()
    ]->
    [
    InitWaitUserInout(~passkey),
    InitTriggerUserInteraction(),
    InitReadyPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespLegPEi
rule RespDoLegPEi:
    [
    RespChooseLegPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespLegPEOnlyOnce(),
    RespWillDoLegPEi()
    ]->
    [
    RespWaitUserInput(),
    RespTriggerUserInteraction(),
    RespReadyPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespLegPEo
rule RespDoLegPEo:
    [
    RespChooseLegPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    Fr(~passkey)
    ]
    --[
    RespLegPEOnlyOnce(),
    RespWillDoLegPEo()
    ]->
    [
    RespWaitUserConfirm(~passkey),
    RespTriggerUserInteraction(),
    RespReadyPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespLegPEio
rule RespDoLegPEio:
    [
    RespChooseLegPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    Fr(~passkey)
    ]
    --[
    RespLegPEOnlyOnce(),
    RespWillDoLegPEio()
    ]->
    [
    RespWaitUserInout(~passkey),
    RespTriggerUserInteraction(),
    RespReadyPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef InitSecPEi
rule InitChooseSecPEi:
    [
    InitChooseSecPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitSecPEOnlyOnce(),
    InitWillDoSecPEi()
    ]->
    [
    InitWaitUserInput(),
    InitDoSecPEi($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitSecPEo
rule InitChooseSecPEo:
    [
    InitChooseSecPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~passkey)
    ]
    --[
        InitSecPEOnlyOnce(),
        InitWillDoSecPEo()
    ]->
    [
    InitWaitUserConfirm(~passkey),
    InitDoSecPEo($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitSecPEio
rule InitChooseSecPEio:
    [
    InitChooseSecPEMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~passkey)
    ]
    --[
    InitSecPEOnlyOnce(),
    InitWillDoSecPEio()
    ]->
    [
    InitWaitUserInout(~passkey),
    InitDoSecPEio($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecPEi
rule RespChooseSecPEi:
    [
    RespChooseSecPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEi()
    ]->
    [
    RespWaitUserInput(),
    RespDoSecPEi($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespSecPEo
rule RespChooseSecPEo:
    [
    RespChooseSecPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    Fr(~passkey)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEo()
    ]->
    [
    RespWaitUserConfirm(~passkey),
    RespDoSecPEo($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespSecPEio
rule RespChooseSecPEio:
    [
    RespChooseSecPEMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    Fr(~passkey)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEio()
    ]->
    [
    RespWaitUserInout(~passkey),
    RespDoSecPEio($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

/*
 * This dispatches the Initiator and Responder to the chosen variant
 * of the Secure OOB Pairing method.
 * The possibility are:
 * - OOBi : OOB, device expects input OOB data
 * - OOBo : OOB, device outputs OOB data
 * - OOBio : OOB, device expects and outputs OOB data
*/
#ifdef InitSecOOBi
rule InitChooseSecOOBi:
    [
    InitChooseOOBMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBi()
    ]->
    [
    InitDoSecOOBi($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitSecOOBo
rule InitChooseSecOOBo:
    [
    InitChooseOOBMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBo()
    ]->
    [
    InitDoSecOOBo($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef InitSecOOBio
rule InitChooseSecOOBio:
    [
    InitChooseOOBMode($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBio()
    ]->
    [
    InitDoSecOOBio($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
#endif

#ifdef RespSecOOBi
rule RespChooseSecOOBi:
    [
    RespChooseOOBMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBi()
    ]->
    [
    RespDoSecOOBi($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespSecOOBo
rule RespChooseSecOOBo:
    [
    RespChooseOOBMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBo()
    ]->
    [
    RespDoSecOOBo($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

#ifdef RespSecOOBio
rule RespChooseSecOOBio:
    [
    RespChooseOOBMode($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBio()
    ]->
    [
    RespDoSecOOBio($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
#endif

/* Legacy Pairing
*/
#ifdef InitLegJW
rule InitStartLegJW:
    [
    InitDoLegJW($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    InitStartLegJW($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]->
    [
    InitDoLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, 'zero') // In JW, the value 'TK' is a null bitstring
    ]
#endif

#ifdef RespLegJW
rule RespStartLegJW:
    [
    RespDoLegJW($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    RespStartLegJW($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]->
    [
    RespDoLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, 'zero') // In JW, the value 'TK' is a null bitstring
    ]
#endif

#ifdef InitLegPE
rule InitStartLegPE:
    [
    InitReadyPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    InitUserProceed(passkey)
    ]
    --[
    InitStartLegPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, passkey),
    LowEntropy(passkey)
    ]->
    [
    InitDoLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, low_entropy(passkey)), // In PE, the value 'TK' is the passkey
    LowEntropy(passkey)
    ]
#endif

#ifdef RespLegPE
rule RespStartLegPE:
    [
    RespReadyPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    RespUserProceed(passkey)
    ]
    --[
    RespStartLegPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, passkey),
    LowEntropy(passkey)
    ]->
    [
    RespDoLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, low_entropy(passkey)), // In PE, the value 'TK' is the passkey
    LowEntropy(passkey)
    ]
#endif

#ifdef InitLegOOB
rule InitStartLegOOB:
    [
    InitDoLegOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~oob)
    ]
    --[
    InitStartLegOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, ~oob),
    LegOOBChannel(~oob)
    ]->
    [
    InitDoLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, ~oob), // In OOB, the value 'TK' is the OOB data
    LegOOBChannel(~oob)
    ]
#endif

#ifdef RespLegOOB
rule RespStartLegOOB:
    [
    RespDoLegOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
    LegOOBChannel(~oob) // Assume the Initiator sent the OOB data to the responder somehow
    ]
    --[
    RespStartLegOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, ~oob)
    ]->
    [
    RespDoLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, ~oob) // In OOB, the value 'TK' is the OOB data
    ]
#endif


/* Start of Legacy Pairing protocol */

#ifdef InitLeg
rule InitPairingConfirm:
    let Ci = c1(TK, ~ni, $capI, $capR, $idI, $idR, $keysizeI, $keysizeR) in
    [
    InitDoLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK),
    Fr(~ni)
    ]
    --[
    InitSentConfirm($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci)
    ]->
    [
    InitSentConfirm($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci),
    Out(Ci)
    ]

rule InitPairingRandom:
    [
    InitSentConfirm($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci),
    In(Cr)
    ]
    --[
    InitSentRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci, Cr)
    ]->
    [
    InitSentRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci, Cr),
    Out(~ni)
    ]

rule InitEndPairing:
    let computed_Cr = c1(TK, nr, $capI, $capR, $idI, $idR, $keysizeI, $keysizeR) in
    [
    InitSentRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, Ci, computed_Cr), // Verify equality of Cr, computed_Cr
    In(nr)
    ]
    --[
    InitDonePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, Ci, computed_Cr)
    ]->
    [
    InitDonePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, Ci, computed_Cr)
    ]

rule InitLegChooseKeysize:
    [
    InitDonePairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, Ci, Cr)
    ]
    --[
    ]->
    [
    InitChooseKeysize($keysizeI, $keysizeR),
    InitExpectKeysize($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, Ci, Cr)
    ]

rule InitDeriveSTK:
    let stk = reduce_key(s1(TK, ~ni, nr), chosenKeysize) in
    [
    InitExpectKeysize($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, Ci, Cr),
    InitSelectKeysize(chosenKeysize)
    ]
    --[
    InitiatorFinishedLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, stk)
    ]->
    [
    InitiatorFinishedLegPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, TK, ~ni, nr, stk),
    ReduceKeysize(chosenKeysize, stk),
    Out(senc('init', stk))
    ]
#endif


#ifdef RespLeg
rule RespPairingConfirm:
    let Cr = c1(TK, ~nr, $capI, $capR, $idI, $idR, $keysizeI, $keysizeR) in
    [
    RespDoLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK),
    Fr(~nr),
    In(Ci)
    ]
    --[
    RespSentConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, Cr, Ci)
    ]->
    [
    RespSentConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, Cr, Ci),
    Out(Cr)
    ]

rule RespPairingRandom:
    let computed_Ci = c1(TK, ni, $capI, $capR, $idI, $idR, $keysizeI, $keysizeR) in
    [
    RespSentConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, Cr, computed_Ci), // verify the matching between Ci and computed_Ci
    In(ni)
    ]
    --[
    RespSentRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, ni, Cr, computed_Ci)
    ]->
    [
    RespSentRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, ni, Cr, computed_Ci),
    Out(~nr)
    ]

rule RespLegChooseKeysize:
    [
    RespSentRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, ni, Cr, Ci)
    ]
    -->
    [
    RespChooseKeysize($keysizeR, $keysizeI),
    RespExpectKeysize($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~ni, nr, Ci, Cr)
    ]

rule RespDeriveSTK:
    let stk = reduce_key(s1(TK, ni, ~nr), chosenKeysize) in
    [
    RespExpectKeysize($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~ni, nr, Ci, Cr),
    RespSelectKeysize(chosenKeysize)
    ]
    --[
    ResponderFinishedLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, ni, stk)
    ]->
    [
    ResponderFinishedLegPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, TK, ~nr, ni, stk),
    ReduceKeysize(chosenKeysize, stk),
    Out(senc('resp', stk))
    ]
#endif

/*
* Public key exchange, common for all Secure Pairing protocols
* The Initiator sends its public key, and receives the one from
* the Responder:
* I -> R: pkI = is * G
* R -> I: pkR = rs * G
* dh = is * rs * G = rs * pkI = is * pkR
*/

#ifdef InitSec
rule InitSendPublicKey:
    let pkI = <e('C', DH_neutral, 'g'^~is),e('C', DH_neutral, 'g'^~is)> in
    [
    InitDoECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR),
    Fr(~is)
    ]
    --[
        InitBeginECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, ~is, pkI)
    ]->
    [
    InitBeginECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, ~is, pkI),
    Out(pkI)
    ]

rule InitRecvPublicKey:
    [
    InitBeginECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, ~is, pkI),
    In(pkR)
    ]
    --[
        InitComputeECDH( $idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, ~is)
    ]->
    [
    InitComputeECDH( $idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, ~is)
    ]

rule InitDeriveNormalDHKey:
   let
       pkRx = e('C', DH_neutral, n)
       dhkey = e('C', r, n^~is) // In Bluetooth, only X is taken
   in
   [
       InitComputeECDH( $idI, $capI, $keysizeI, $idR, $capR, $keysizeR, <pkIx,pkIy>, <pkRx,pkRy>, ~is),
       In(r)
   ]
  --[
      ValidPt(pkRx,pkRy), Raised('C', DH_neutral, r, ~is),
      InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef InitECDHUnpatched
rule InitDeriveInvalidDHKey:
   let
       pkRx = e(otx,osx,orx)
       pkRy = e(oty,osy,ory)
       dhkey = e(tx, rx, nx^~is) // In Bluetooth, only X is taken
   in
   [
       InitComputeECDH( $idI, $capI, $keysizeI, $idR, $capR, $keysizeR, <pkIx, pkIy>, <pkRx, pkRy>, ~is),
       In(<tx,rx,nx,ty,ry,ny>)
   ]
  --[
       InvalidPt(pkRx,pkRy), Raised(<tx,ty>, <osx,osy>, <rx,ry>, ~is),
       InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
  ]->
   [
       InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef RespSec
rule RespSendPublicKey:
    let
        pkR = <e('C', DH_neutral, 'g'^~rs),e('C', DH_neutral, 'g'^~rs)>
    in
    [
        RespDoECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI),
        Fr(~rs),
        In(pkI)
    ]
    --[
        RespComputeECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, ~rs)
    ]->
    [
        RespComputeECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, ~rs),
        Out(pkR)
    ]

rule RespDeriveNormalDHKey:
   let
       pkIx = e('C', DH_neutral, n)
       dhkey = e('C', r, n^~rs) // In Bluetooth, only X is taken
   in
   [
       RespComputeECDH( $idR, $capR, $keysizeR, $idI, $capI, $keysizeI, <pkRx, pkRy>, <pkIx, pkIy>, ~rs),
       In(r)
   ]
   --[
      ValidPt(pkIx,pkIy), Raised('C', DH_neutral, r, ~rs),
      RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef RespECDHUnpatched
rule RespDeriveInvalidDHKey:
   let
       pkIx = e(otx,osx,orx)
       pkIy = e(oty,osy,ory)
       dhkey = e(tx, rx, nx^~rs) // In Bluetooth, only X is taken
   in
   [
       RespComputeECDH( $idR, $capR, $keysizeR, $idI, $capI, $keysizeI, <pkRx, pkRy>, <pkIx, pkIy>, ~rs),
       In(<tx,rx,nx,ty,ry,ny>)
   ]
  --[
      InvalidPt(pkIx,pkIy), Raised(<tx,ty>, <osx,osy>, <rx,ry>, ~rs),
      RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

/*
* For the Secure Passkey Entry which requires it, we start the user interaction here.
* That is, we trigger the role to have the Passkey Entry user interaction
*/

#ifdef InitSecPE
rule InitTriggerSecPE:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh), // The Initiator has ended the ECDH exchange
    InitDoSecPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR) // The Initiator is doing a PE protocol
    ]
    --[]->
    [
    InitTriggerUserInteraction(),
    InitReadySecPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh)
    ]
#endif

#ifdef RespSecPE
rule RespTriggerSecPE:
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh), // The Initiator has ended the ECDH exchange
    RespDoSecPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI) // The Initiator is doing a PE protocol
    ]
    --[]->
    [
    RespTriggerUserInteraction(),
    RespReadySecPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh)
    ]
#endif

/*
* This implements the Secure JustWorks method
* Devices using this method do not require a user interaction.
* The protocol is the following :
* R -> I: f4(pkR, pkI, nr, '0')
* I -> R: ni
* R -> I: nr
*/

#ifdef RespSecJW
rule RespSecJWSendConfirm:
    let Cr = f4(pkR, pkI, ~nr, '0') in
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    Fr(~nr)
    ]
    --[
        RespSecJWSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr)
    ]->
    [
    RespSecJWSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr),
    Out(Cr)
    ]

rule RespSecJWSendRandom:
    [
    RespSecJWSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr),
    In(ni)
    ]
    --[
        RespSecJWSendRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
        RespSecJWDone($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
        RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, '0', '0')
    ]->
    [
    RespSecJWSendRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
    RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, '0', '0'), // Responder ended step2, ra and rb = 0 in JW mode
    Out(~nr)
    ]
#endif

#ifdef InitSecJW
rule InitSecJWSendRandom:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    Fr(~ni),
    In(Cr)
    ]
    --[
        InitSecJWSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, Cr)
    ]->
    [
    InitSecJWSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, Cr),
    Out(~ni)
    ]


rule InitSecJWRecvRandom:
    let computed_Cr = f4(pkR, pkI, nr, '0') in
    [
    InitSecJWSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, computed_Cr),
    In(nr)
    ]
    --[
        InitSecJWRecvRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
        InitSecJWDone($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
        InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, '0', '0')
    ]->
    [
    InitSecJWRecvRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
    InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, '0', '0') // Responder ended step2, ra and rb = 0 in JW mode
    ]
#endif

/*
* Implement the Secure Passkey Entry method
* The protocol is based on commitment rounds, using the passkey.
* The passkey is always 20 bits long (by the specification)
* notation b0(passkey) represents the first bit of the passkey, b1(passkey) is the second bit, ...
* Round 0:
* I -> R: f4(pkI, pkR, ni0, b0(passkey)
* R -> I: f4(pkR, pkI, nr0, b0(passkey)
* I -> R: ni0
* R -> I: nr0
* Round 1:
* I -> R: f4(pkI, pkR, ni1, b1(passkey)
* R -> I: f4(pkR, pkI, nr1, b1(passkey)
* I -> R: ni1
* R -> I: nr1
* ...
*
* Nonces are drawn at random for each round.
* In this model, we use a reduced version of the Passkey Entry protocol, which consists
* of only two rounds.
* The passkey is split in two using functions split1/1 and split2/1
*/

#ifdef InitSecPE
rule InitSecPESendConfirm1:
    let Ci = f4(pkI, pkR, ~ni, split1(passkey)) in
    [
    InitReadySecPE($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh), // Initiator is ready to perform PE protocol
    InitUserProceed(passkey), // The passkey is provided to the Initiator
    Fr(~ni)
    ]
    --[]->
    [
    InitSecPESendConfirm1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci),
    LowEntropyf4(pkI, pkR, ~ni, split1(passkey)),
    Out(Ci)
    ]

rule InitSecPESendRandom1:
    [
    InitSecPESendConfirm1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci), 
    In(Cr)
    ]
    --[]->
    [
    InitSecPESendRandom1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci, Cr),
    Out(~ni)
    ]

rule InitSecPERecvRandom1:
    let computed_Cr = f4(pkR, pkI, nr, split1(passkey)) in
    [
    InitSecPESendRandom1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci, computed_Cr), 
    In(nr)
    ]
    --[
    ]->
    [
    InitSecPEEndPart1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey)
    ]

rule InitSecPESendConfirm2:
    let Ci = f4(pkI, pkR, ~ni, split2(passkey)) in
    [
    InitSecPEEndPart1($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey),
    Fr(~ni)
    ]
    --[]->
    [
    InitSecPESendConfirm2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci),
    LowEntropyf4(pkI, pkR, ~ni, split2(passkey)),
    Out(Ci)
    ]

rule InitSecPESendRandom2:
    [
    InitSecPESendConfirm2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci), 
    In(Cr)
    ]
    --[]->
    [
    InitSecPESendRandom2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci, Cr),
    Out(~ni)
    ]

rule InitSecPERecvRandom2:
    let computed_Cr = f4(pkR, pkI, nr, split2(passkey)) in
    [
    InitSecPESendRandom2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, passkey, ~ni, Ci, computed_Cr), 
    In(nr)
    ]
    --[
        InitSecPEDone($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, passkey),
        InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, passkey, passkey)
    ]->
    [
    InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, passkey, passkey)
    ]
#endif

#ifdef RespSecPE
rule RespSecPESendConfirm1:
    let Cr = f4(pkR, pkI, ~nr, split1(passkey)) in
    [
    RespReadySecPE($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh), // Initiator is ready to perform PE protocol
    RespUserProceed(passkey), // The passkey is provided to the Initiator
    Fr(~nr),
    In(Ci)
    ]
    --[]->
    [
    RespSecPESendConfirm1($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey, ~nr, Cr, Ci),
    LowEntropyf4(pkR, pkI, ~nr, split1(passkey)),
    Out(Cr)
    ]

rule RespSecPESendRandom1:
    let computed_Ci = f4(pkI, pkR, ni, split1(passkey)) in
    [
    RespSecPESendConfirm1($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey, ~nr, Cr, computed_Ci),
    In(ni)
    ]
    --[
    ]->
    [
    RespSecPEEndPart1($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey),
    Out(~nr)
    ]

rule RespSecPESendConfirm2:
    let Cr = f4(pkR, pkI, ~nr, split2(passkey)) in
    [
    RespSecPEEndPart1($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey), // Initiator is ready to perform PE protocol
    Fr(~nr),
    In(Ci)
    ]
    --[]->
    [
    RespSecPESendConfirm2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey, ~nr, Cr, Ci),
    LowEntropyf4(pkR, pkI, ~nr, split2(passkey)),
    Out(Cr)
    ]

rule RespSecPESendRandom2:
    let computed_Ci = f4(pkI, pkR, ni, split2(passkey)) in
    [
    RespSecPESendConfirm2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, passkey, ~nr, Cr, computed_Ci), 
    In(ni)
    ]
    --[
        RespSecPEDone($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, passkey),
        RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, passkey, passkey)
    ]->
    [
    RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, passkey, passkey),
    Out(~nr)
    ]
#endif

#ifdef NoLowEntropySecure // If flag NoLowEntropySecure is used, this rule won't be written
#else
rule Oracle_f4:
    let verif_val = f4(pk1, pk2, n, s) in
    [
    LowEntropyf4(pk1, pk2, n, s),
    In(pk1),
    In(pk2),
    In(n),
    In(verif_val)
    ]
    --[
        AttackerRecoveredPasskey(s)
    ]->
    [
    Out(s)
    ]
#endif

#ifdef NoLowEntropyLegacy // If flag NoLowEntropyLegacy, this rule won't be written
#else
rule Oracle_passkey:
    let C = c1(low_entropy(passkey), N, capI, capR, idI, idR, keysizeI, keysizeR) in
    [
    LowEntropy(passkey),
    In(C),
    In(N),
    In(capI),
    In(capR),
    In(idI),
    In(idR),
    In(keysizeI),
    In(keysizeR)
    ]
    --[
        AttackerRecoveredPasskey(passkey)
    ]->
    [
    Out(passkey)
    ]
#endif 

#ifdef LowEntropyKeysize// If flag LowEntropyKeysize, this rule will be written
rule Oracle_key:
    [
    ReduceKeysize('weak', key)
    ]
    --[
        AttackerRecoveredKey(key)
    ]->
    [
    Out(key)
    ]
#endif 
    
/*
* Numeric Comparison method
* This protocol is similar to the Secure JustWorks protocol, but the user is
* then presented a code to verify that the Pairing was done correctly
* R -> I: f4(pkR, pkI, nr, '0')
* I -> R: ni
* R -> I: nr
*/


#ifdef RespSecNC
rule RespSecNCSendConfirm:
    let Cr = f4(pkR, pkI, ~nr, '0') in
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    Fr(~nr)
    ]
    --[
        RespSecNCSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr)
    ]->
    [
    RespSecNCSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr),
    Out(Cr)
    ]

rule RespSecNCSendRandom:
    let code = g2(pkI, pkR, ni, ~nr) in
    [
    RespSecNCSendConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, Cr),
    In(ni)
    ]
    --[
        RespSecNCSendRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni)
    ]->
    [
    RespNCWaitConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
    RespWaitUserConfirm(code),
    RespTriggerUserInteraction(),
    Out(~nr)
    ]

rule RespSecNCDone:
    [
    RespNCWaitConfirm($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
    RespUserProceed(code)
    ]
    --[
        RespSecNCDone($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
        RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, '0', '0')
    ]->
    [
    RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, '0', '0') // Initiator ended step2, ra and rb = 0 in JW mode
    ]
#endif


#ifdef InitSecNC
rule InitSecNCSendRandom:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    Fr(~ni),
    In(Cr)
    ]
    --[
        InitSecNCSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, Cr)
    ]->
    [
    InitSecNCSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, Cr),
    Out(~ni)
    ]

rule InitSecNCRecvRandom:
    let 
        computed_Cr = f4(pkR, pkI, nr, '0')
        code = g2(pkI, pkR, ~ni, nr)
    in
    [
    InitSecNCSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, computed_Cr),
    In(nr)
    ]
    --[
        InitSecNCRecvRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr)
    ]->
    [
    InitNCWaitConfirm($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
    InitWaitUserConfirm(code),
    InitTriggerUserInteraction()
    ]

rule InitSecNCDone:
    [
    InitNCWaitConfirm($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
    InitUserProceed(code)
    ]
    --[
        InitSecNCDone($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
        InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, '0', '0')
    ]->
    [
    InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, '0', '0') // Initiator ended step2, ra and rb = 0 in JW mode
    ]
#endif

/*
* Out of Band Pairing method.
* The exact exchange will depend on the choice done for the OOB method.
* If OOBi is used, the device expects an input message
* If OOBo is used, the device sends a message
* If OOBio is used, the device sends a message and expects an input message
*
* Once the OOB exchange is done, both device exchange a nonce, starting from the Initiator:
* I -> R: ni
* R -> I: nr
*/

#ifdef InitSecOOBi
rule InitDoSecOOBi:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitDoSecOOBi($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    ]->
    [
    InitWaitOOBInput(),
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh)
    ]
#endif

#ifdef InitSecOOBo
rule InitDoSecOOBo:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitDoSecOOBo($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    ]->
    [
    InitWaitOOBOutput(),
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh)
    ]
#endif

#ifdef InitSecOOBio
rule InitDoSecOOBio:
    [
    InitEndECDH($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitDoSecOOBio($idI, $capI, $keysizeI, $idR, $capR, $keysizeR)
    ]
    --[
    ]->
    [
    InitWaitOOBInout(),
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh)
    ]
#endif

#ifdef RespSecOOBi
rule RespDoSecOOBi:
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespDoSecOOBi($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    ]->
    [
    RespWaitOOBInput(),
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh)
    ]
#endif

#ifdef RespSecOOBo
rule RespDoSecOOBo:
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespDoSecOOBo($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    ]->
    [
    RespWaitOOBOutput(),
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh)
    ]
#endif

#ifdef RespSecOOBio
rule RespDoSecOOBio:
    [
    RespEndECDH($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespDoSecOOBio($idR, $capR, $keysizeR, $idI, $capI, $keysizeI)
    ]
    --[
    ]->
    [
    RespWaitOOBInout(),
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh)
    ]
#endif

#ifdef InitSecOOB
rule InitSecOOBOut:
    let Ci = f4(pkI, pkI, ~ri, '0') in
    [
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitWaitOOBOutput(),
    Fr(~ri)
    ]
    --[
        InitSentOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ri, Ci)
    ]->
    [
        InitDoneSecOOBexchange($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ri, '0'),
        InitOOBchannel(<$idI, ~ri, Ci>)
    ]

rule InitSecOOBin:
    let computed_Cr = f4(pkR, pkR, ~rr, '0') in
    [
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitWaitOOBInput(),
    RespOOBchannel(<$idR, ~rr, computed_Cr>)
    ]
    --[
    ]->
    [
    InitDoneSecOOBexchange($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, '0', ~rr)
    ]

rule InitSecOOBinout_out:
    let Ci = f4(pkI, pkI, ~ri, '0') in
    [
    InitReadySecOOB($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh),
    InitWaitOOBInout(),
    Fr(~ri)
    ]
    --[
    ]->
    [
    InitDoneSecOOBinout_out($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ri),
    InitOOBchannel(<$idI, ~ri, Ci>)
    ]

rule InitSecOOBinout_in:
    let computed_Cr = f4(pkR, pkR, ~rr, '0') in
    [
    InitDoneSecOOBinout_out($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ri),
    RespOOBchannel(<$idR, ~rr, computed_Cr>)
    ]
    --[
    ]->
    [
    InitDoneSecOOBexchange($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ri, ~rr)
    ]

rule InitSecOOBSendRandom:
    [
    InitDoneSecOOBexchange($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ri, rr),
    Fr(~ni)
    ]
    --[]->
    [
    InitSecOOBSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ri, rr, ~ni),
    Out(~ni)
    ]

rule InitSecOOBRecvRandom:
    [
    InitSecOOBSendRandom($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ri, rr, ~ni),
    In(nr)
    ]
    --[
        InitSecOOBDone($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr),
        InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr)
    ]->
    [
    InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr)
    ]
#endif

#ifdef RespSecOOB
rule RespSecOOBOut:
    let Cr = f4(pkR, pkR, ~rr, '0') in
    [
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespWaitOOBOutput(),
    Fr(~rr)
    ]
    --[
        RespSentSecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~rr, Cr)
    ]->
    [
        RespDoneSecOOBexchange($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~rr, '0'),
        RespOOBchannel(<$idR, ~rr, Cr>)
    ]

rule RespSecOOBin:
    let computed_Ci = f4(pkI, pkI, ~ri, '0') in
    [
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespWaitOOBInput(),
    InitOOBchannel(<$idI, ~ri, computed_Ci>)
    ]
    --[
    ]->
    [
    RespDoneSecOOBexchange($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, '0', ~ri)
    ]

rule RespSecOOBinout_out:
    let Cr = f4(pkR, pkR, ~rr, '0') in
    [
    RespReadySecOOB($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh),
    RespWaitOOBInout(),
    Fr(~rr)
    ]
    --[
    ]->
    [
    RespDoneSecOOBinout_out($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~rr),
    RespOOBchannel(<$idR, ~rr, Cr>)
    ]

rule RespSecOOBinout_in:
    let computed_Ci = f4(pkI, pkI, ~ri, '0') in
    [
    RespDoneSecOOBinout_out($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~rr),
    InitOOBchannel(<$idI, ~ri, computed_Ci>)
    ]
    --[
    ]->
    [
    RespDoneSecOOBexchange($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~rr, ~ri)
    ]

rule RespSecOOBSendRandom:
    [
    RespDoneSecOOBexchange($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, rr, ri),
    Fr(~nr),
    In(ni)
    ]
    --[
        RespSecOOBDone($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, rr, ri),
        RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, rr, ri)
    ]->
    [
    RespSecOOBSendRandom($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, rr, ri, ~nr, ni),
    Out(~nr),
    RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, rr, ri)
    ]
#endif

/*
* DHKeyCheck, this is a key confirmation step
*/

#ifdef InitSec
rule InitDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ~ni, nr, 'btle', $idI, $idR)
        ei = f6(dh, ~ni, nr, rr, $capI, $idI, $idR) // Compute DHKeyCheck confirmation value
    in
    [
    InitEndedStep2($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr) // Initiator needs to be done with step2
    ]
    --[ InitDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr, ei) ]-> // Intermediate fact
    [
    InitSendDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr, ei), // Initiator has sent its dhkey check
    Out(ei) // Send the DHKey Check on the channel
    ]

rule InitDoneDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ~ni, nr, 'btle', $idI, $idR)
        computed_er = f6(dh, nr, ~ni, ri, $capR, $idR, $idI)
    in
    [
    InitSendDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr, ei),
    In(computed_er)
    ]
    --[
        InitDoneDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr, ri, rr, ei, computed_er)
    ]->
    [
    InitEndedDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr)
    ]
#endif

#ifdef RespSec
rule RespDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ni, ~nr, 'btle', $idI, $idR)
        er = f6(dh, ~nr, ni, ri, $capR, $idR, $idI)
        computed_ei = f6(dh, ni, ~nr, rr, $capI, $idI, $idR)
    in
    [
    RespEndedStep2($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, rr, ri),
    In(computed_ei)
    ]
    --[
        RespDoneDHKeyCheck($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni, rr, ri, er, computed_ei)
    ]->
    [
    RespEndedDHKeyCheck($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
    Out(er)
    ]
#endif


/*
Technically, ni should be the nonce sent by the central and nr should be the nonce sent by the peripheral
idI should be the address of the central and idR the address of the peripheral.

Here, we assume Initiator == Central and Responder == Peripheral but that may not be always true

Also, the session key derivation and authentication is not performed here.
*/

#ifdef InitSec
rule InitSecChooseKeysize:
    [
    InitEndedDHKeyCheck($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr)
    ]
    -->
    [
    InitChooseKeysize($keysizeI, $keysizeR),
    InitSecExpectKeysize($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr)
    ]

rule InitSecSendmsg:
    let ltk = reduce_key(f5_ltk(dh, ~ni, nr, 'btle', $idI, $idR), chosenKeysize) in
    [
    InitSecExpectKeysize($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ~ni, nr),
    InitSelectKeysize(chosenKeysize)
    ]
    --[
        InitiatorFinishedSecPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ltk),
        InitiatorSecSentMessage(ltk, 'init')
    ]->
    [
    InitiatorFinishedSecPairing($idI, $capI, $keysizeI, $idR, $capR, $keysizeR, pkI, pkR, dh, ltk),
    ReduceKeysize(chosenKeysize, ltk),
    Out(senc('init',ltk))
    ]
#endif

#ifdef RespSec
rule RespSecChooseKeysize:
    [
    RespEndedDHKeyCheck($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni)
    ]
    -->
    [
    RespChooseKeysize($keysizeR, $keysizeI),
    RespSecExpectKeysize($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni)
    ]


rule RespSecSendmsg:
    let ltk = reduce_key(f5_ltk(dh, ni, ~nr, 'btle', $idI, $idR), chosenKeysize) in
    [
    RespSecExpectKeysize($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ~nr, ni),
    RespSelectKeysize(chosenKeysize),
    In(senc('init', ltk)) 
    ]
    --[
        ResponderFinishedSecPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ltk),
        ResponderSentMessage(ltk, 'resp')
    ]->
    [
    ResponderFinishedSecPairing($idR, $capR, $keysizeR, $idI, $capI, $keysizeI, pkR, pkI, dh, ltk),
    ReduceKeysize(chosenKeysize, ltk),
    Out(senc('resp',ltk))
    ]
#endif

/* User interactions */
/* This is used to represent user interactions in Bluetooth
Devices can have an output, input or input/output capability.
There are four facts that are used to represent interactions:
- InitUserWaitInput(): Initiator waits passkey input from user
- RespUserWaitInput(): Responder waits passkey input from user
- InitUserWaitConfirm(passkey): Initiator waits continuation of the protocol, it chooses passkey
- RespUserWaitConfirm(passkey): Responder waits continuation of the protocol, it chooses passkey
- InitUserWaitInout(passkey): Initiator waits continuation of the protocol
- RespUserWaitInout(passkey): Responder waits the continuation of the protocol

We note that not both devices choose the passkey, in practice only one does.
However, the choice depends on the capabilities of the other device.
This is why when two devices have triggered UserWaitInout(passkey), only one passkey is propagated in the following
rules, to model the choice that was done at the beginning of the protocol.

The possible combinations are:
InitUserWaitInput - RespUserWaitInput -> Valid interaction in PE, user selects a passkey and inputs it in both
InitUserWaitInput - RespUserWaitConfirm -> Valid interaction in PE, user copies the responder's passkey into initiator
InitUserWaitConfirm - RespUserWaitInput -> Valid interaction in PE, user copies the initiator's passkey into responder
InitUserWaitConfirm - RespUserWaitConfirm -> Valid interaction in NC, user verifies that both code match
                                          -> May also occur in PEo/PEio - PEo/PEio, in which case it is valid
*/

#ifdef InputInput
rule UserInputInitInputResp:
    [Fr(~passkey),
    InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(~passkey),RespUserProceed(~passkey)]
#endif

#ifdef InputOutput
rule UserInputInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserConfirm(passkey)]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef InputInout
rule UserInputInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserInout(passkey)]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef OutputInput
rule UserConfirmInitInputResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(passkey),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef OutputInout
rule UserConfirmInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserInout(passkeyr)]
    --[]->
    [InitUserProceed(passkeyi),RespUserProceed(passkeyi)]
#endif

#ifdef InoutInput
rule UserInoutInitInputResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkey),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef InoutOutput
rule UserInoutInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserConfirm(passkeyr)]
    --[]->
    [InitUserProceed(passkeyr),RespUserProceed(passkeyr)]
#endif

#ifdef InoutInout
rule UserInoutInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserInout(passkeyr)]
    --[]->
    [InitUserProceed(passkeyi),RespUserProceed(passkeyi)]
#endif

#ifdef OutputOutput
// This represents Numeric Comparison protocol
rule UserConfirmInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(vi),
    RespTriggerUserInteraction(),RespWaitUserConfirm(vi)]
    --[]->
    [InitUserProceed(vi),RespUserProceed(vi)]
#endif

/* Keysize selection, used for all protocols. The lower keysize is chosen.
Although the keysize is a byte with values 7-16 in BLE specifications,
in this model we use weak/strong keysize. Hence, there are 4 possible combinations. */

rule RespSelectKeysizeSS:
    [RespChooseKeysize('strong', 'strong')] --> [RespSelectKeysize('strong')]

rule RespSelectKeysizeSW:
    [RespChooseKeysize('strong', 'weak')] --> [RespSelectKeysize('weak')]

rule RespSelectKeysizeWS:
    [RespChooseKeysize('weak', 'strong')] --> [RespSelectKeysize('weak')]

rule RespSelectKeysizeWW:
    [RespChooseKeysize('weak', 'weak')] --> [RespSelectKeysize('weak')]

rule InitSelectKeysizeSS:
    [InitChooseKeysize('strong', 'strong')] --> [InitSelectKeysize('strong')]

rule InitSelectKeysizeSW:
    [InitChooseKeysize('strong', 'weak')] --> [InitSelectKeysize('weak')]

rule InitSelectKeysizeWS:
    [InitChooseKeysize('weak', 'strong')] --> [InitSelectKeysize('weak')]

rule InitSelectKeysizeWW:
    [InitChooseKeysize('weak', 'weak')] --> [InitSelectKeysize('weak')]



/* Those two restrictions limit to one honest initiator and one
honest responder. This helps having a finished analysis */
restriction InitOnlyOncePairing:
"All #i #j. InitOnlyOncePairing() @i & InitOnlyOncePairing() @j ==> #i = #j"

restriction RespOnlyOncePairing:
"All #i #j. RespOnlyOncePairing() @i & RespOnlyOncePairing() @j ==> #i = #j"

#ifdef InitLegPE
restriction InitLegPEOnlyOnce:
"All #i #j . InitLegPEOnlyOnce() @i & InitLegPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespLegPE
restriction RespLegPEOnlyOnce:
"All #i #j . RespLegPEOnlyOnce() @i & RespLegPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef InitSecPE
restriction InitSecPEOnlyOnce:
"All #i #j. InitSecPEOnlyOnce() @i & InitSecPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespSecPE
restriction RespSecPEOnlyOnce:
"All #i #j. RespSecPEOnlyOnce() @i & RespSecPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef InitSecOOB
restriction InitSecOOBOnlyOnce:
"All #i #j. InitSecOOBOnlyOnce() @i & InitSecOOBOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespSecOOB
restriction RespSecOOBOnlyOnce:
"All #i #j. RespSecOOBOnlyOnce() @i & RespSecOOBOnlyOnce() @j ==> #i = #j"
#endif

// For ECDH model
restriction DHConsistency:
	"All  t s r1 r2 y #i #j .
	Raised(t,s,r1,y) @ i & Raised(t,s,r2,y) @j
	==> r1 = r2"

restriction DHIdentity:
	"All  t r y #i .
	Raised(t,DH_neutral,r,y) @ i ==> r = DH_neutral"

restriction ValidPt:
  " x y #i.
    (ValidPt(x,y) @ #i)  (x = y)"

restriction InvalidPt:
  " x #i.
    (InvalidPt(x,x) @ #i)  F"

/*************************************/
/* Lemmas about LegJW-LegJW exchange */
/*************************************/

#ifdef LegJWLegJW
lemma legJW_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legJW_legJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legJW_legJW_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legJW_legJW_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legJW_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about LegJW-LegJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about LegJW-LegPEi exchange */
/**************************************/

#ifdef LegJWLegPEi
lemma legJW_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legJW_legPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legJW_legPEi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legJW_legPEi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegJW-LegPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about LegJW-LegPEo exchange */
/**************************************/

#ifdef LegJWLegPEo
lemma legJW_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legJW_legPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legJW_legPEo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legJW_legPEo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegJW-LegPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about LegJW-LegPEio exchange */
/***************************************/

#ifdef LegJWLegPEio
lemma legJW_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legJW_legPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legJW_legPEio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legJW_legPEio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegJW-LegPEio exchange */
/*******************************************/

/**************************************/
/* Lemmas about LegJW-LegOOB exchange */
/**************************************/

#ifdef LegJWLegOOB
lemma legJW_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legJW_legOOB_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legJW_legOOB_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legJW_legOOB_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legOOB_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legJW_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegJW-LegOOB exchange */
/******************************************/

/**************************************/
/* Lemmas about LegPEi-LegJW exchange */
/**************************************/

#ifdef LegPEiLegJW
lemma legPEi_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEi_legJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEi_legJW_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEi_legJW_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legJW_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEi-LegJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegPEi-LegPEi exchange */
/***************************************/

#ifdef LegPEiLegPEi
lemma legPEi_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEi_legPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEi_legPEi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEi_legPEi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEi-LegPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegPEi-LegPEo exchange */
/***************************************/

#ifdef LegPEiLegPEo
lemma legPEi_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEi_legPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEi_legPEo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEi_legPEo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEi-LegPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEi-LegPEio exchange */
/****************************************/

#ifdef LegPEiLegPEio
lemma legPEi_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEi_legPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEi_legPEio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEi_legPEio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEi-LegPEio exchange */
/********************************************/

/***************************************/
/* Lemmas about LegPEi-LegOOB exchange */
/***************************************/

#ifdef LegPEiLegOOB
lemma legPEi_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEi_legOOB_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEi_legOOB_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEi_legOOB_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legOOB_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEi_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEi-LegOOB exchange */
/*******************************************/

/**************************************/
/* Lemmas about LegPEo-LegJW exchange */
/**************************************/

#ifdef LegPEoLegJW
lemma legPEo_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEo_legJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEo_legJW_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEo_legJW_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legJW_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEo-LegJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegPEo-LegPEi exchange */
/***************************************/

#ifdef LegPEoLegPEi
lemma legPEo_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEo_legPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEo_legPEi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEo_legPEi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEo-LegPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegPEo-LegPEo exchange */
/***************************************/

#ifdef LegPEoLegPEo
lemma legPEo_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEo_legPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEo_legPEo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEo_legPEo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEo-LegPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEo-LegPEio exchange */
/****************************************/

#ifdef LegPEoLegPEio
lemma legPEo_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEo_legPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEo_legPEio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEo_legPEio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEo-LegPEio exchange */
/********************************************/

/***************************************/
/* Lemmas about LegPEo-LegOOB exchange */
/***************************************/

#ifdef LegPEoLegOOB
lemma legPEo_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEo_legOOB_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEo_legOOB_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEo_legOOB_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legOOB_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEo_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEo-LegOOB exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegPEio-LegJW exchange */
/***************************************/

#ifdef LegPEioLegJW
lemma legPEio_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEio_legJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEio_legJW_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEio_legJW_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legJW_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEio-LegJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEio-LegPEi exchange */
/****************************************/

#ifdef LegPEioLegPEi
lemma legPEio_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEio_legPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEio_legPEi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEio_legPEi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEio-LegPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPEio-LegPEo exchange */
/****************************************/

#ifdef LegPEioLegPEo
lemma legPEio_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEio_legPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEio_legPEo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEio_legPEo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEio-LegPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPEio-LegPEio exchange */
/*****************************************/

#ifdef LegPEioLegPEio
lemma legPEio_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEio_legPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEio_legPEio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEio_legPEio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEio-LegPEio exchange */
/*********************************************/

/****************************************/
/* Lemmas about LegPEio-LegOOB exchange */
/****************************************/

#ifdef LegPEioLegOOB
lemma legPEio_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legPEio_legOOB_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legPEio_legOOB_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legPEio_legOOB_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legOOB_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legPEio_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEio-LegOOB exchange */
/********************************************/

/**************************************/
/* Lemmas about LegOOB-LegJW exchange */
/**************************************/

#ifdef LegOOBLegJW
lemma legOOB_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legOOB_legJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legOOB_legJW_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legOOB_legJW_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legJW_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegOOB-LegJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegOOB-LegPEi exchange */
/***************************************/

#ifdef LegOOBLegPEi
lemma legOOB_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legOOB_legPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legOOB_legPEi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legOOB_legPEi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegOOB-LegPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegOOB-LegPEo exchange */
/***************************************/

#ifdef LegOOBLegPEo
lemma legOOB_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legOOB_legPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legOOB_legPEo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legOOB_legPEo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegOOB-LegPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegOOB-LegPEio exchange */
/****************************************/

#ifdef LegOOBLegPEio
lemma legOOB_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legOOB_legPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legOOB_legPEio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legOOB_legPEio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegOOB-LegPEio exchange */
/********************************************/

/***************************************/
/* Lemmas about LegOOB-LegOOB exchange */
/***************************************/

#ifdef LegOOBLegOOB
lemma legOOB_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2
    )
"

lemma legOOB_legOOB_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            (Ex ci cr #k2 .
                RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k2
            )
        )
"

lemma legOOB_legOOB_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            (Ex ci cr #k2 .
                InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k2
            )
        )
"

lemma legOOB_legOOB_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legOOB_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
        (All idI idR capI capR ksI ksR tk ni nr stk #k1 .
            ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @k1 ==>
            not (Ex #k2 . K(stk) @k2 )
        )
"

lemma legOOB_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 tk1 ni1 nr1 stk1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk2 ni2 nr2 stk2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk1, ni1, nr1, stk1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk2, nr2, ni2, stk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk1) @k1 & K(stk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegOOB-LegOOB exchange */
/*******************************************/

/*************************************/
/* Lemmas about SecJW-SecJW exchange */
/*************************************/

#ifdef SecJWSecJW
lemma secJW_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*****************************************/
/* End lemmas about SecJW-SecJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecJW-SecPEi exchange */
/**************************************/

#ifdef SecJWSecPEi
lemma secJW_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecJW-SecPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecJW-SecPEo exchange */
/**************************************/

#ifdef SecJWSecPEo
lemma secJW_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecJW-SecPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecJW-SecPEio exchange */
/***************************************/

#ifdef SecJWSecPEio
lemma secJW_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecPEio exchange */
/*******************************************/

/*************************************/
/* Lemmas about SecJW-SecNC exchange */
/*************************************/

#ifdef SecJWSecNC
lemma secJW_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*****************************************/
/* End lemmas about SecJW-SecNC exchange */
/*****************************************/

/***************************************/
/* Lemmas about SecJW-SecOOBi exchange */
/***************************************/

#ifdef SecJWSecOOBi
lemma secJW_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecOOBi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecJW-SecOOBo exchange */
/***************************************/

#ifdef SecJWSecOOBo
lemma secJW_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecOOBo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecJW-SecOOBio exchange */
/****************************************/

#ifdef SecJWSecOOBio
lemma secJW_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecJW-SecOOBio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEi-SecJW exchange */
/**************************************/

#ifdef SecPEiSecJW
lemma secPEi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecPEi-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEi-SecPEi exchange */
/***************************************/

#ifdef SecPEiSecPEi
lemma secPEi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEi-SecPEo exchange */
/***************************************/

#ifdef SecPEiSecPEo
lemma secPEi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEi-SecPEio exchange */
/****************************************/

#ifdef SecPEiSecPEio
lemma secPEi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEi-SecNC exchange */
/**************************************/

#ifdef SecPEiSecNC
lemma secPEi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecPEi-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about SecPEi-SecOOBi exchange */
/****************************************/

#ifdef SecPEiSecOOBi
lemma secPEi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEi-SecOOBo exchange */
/****************************************/

#ifdef SecPEiSecOOBo
lemma secPEi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEi-SecOOBio exchange */
/*****************************************/

#ifdef SecPEiSecOOBio
lemma secPEi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecPEi-SecOOBio exchange */
/*********************************************/

/**************************************/
/* Lemmas about SecPEo-SecJW exchange */
/**************************************/

#ifdef SecPEoSecJW
lemma secPEo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecPEo-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEo-SecPEi exchange */
/***************************************/

#ifdef SecPEoSecPEi
lemma secPEo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEo-SecPEo exchange */
/***************************************/

#ifdef SecPEoSecPEo
lemma secPEo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEo-SecPEio exchange */
/****************************************/

#ifdef SecPEoSecPEio
lemma secPEo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEo-SecNC exchange */
/**************************************/

#ifdef SecPEoSecNC
lemma secPEo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecPEo-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about SecPEo-SecOOBi exchange */
/****************************************/

#ifdef SecPEoSecOOBi
lemma secPEo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEo-SecOOBo exchange */
/****************************************/

#ifdef SecPEoSecOOBo
lemma secPEo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEo-SecOOBio exchange */
/*****************************************/

#ifdef SecPEoSecOOBio
lemma secPEo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecPEo-SecOOBio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecPEio-SecJW exchange */
/***************************************/

#ifdef SecPEioSecJW
lemma secPEio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEio-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEio-SecPEi exchange */
/****************************************/

#ifdef SecPEioSecPEi
lemma secPEio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEio-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEio-SecPEo exchange */
/****************************************/

#ifdef SecPEioSecPEo
lemma secPEio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecPEio-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEio-SecPEio exchange */
/*****************************************/

#ifdef SecPEioSecPEio
lemma secPEio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecPEio-SecNC exchange */
/***************************************/

#ifdef SecPEioSecNC
lemma secPEio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecPEio-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecPEio-SecOOBi exchange */
/*****************************************/

#ifdef SecPEioSecOOBi
lemma secPEio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecPEio-SecOOBo exchange */
/*****************************************/

#ifdef SecPEioSecOOBo
lemma secPEio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecPEio-SecOOBio exchange */
/******************************************/

#ifdef SecPEioSecOOBio
lemma secPEio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecPEio-SecOOBio exchange */
/**********************************************/

/*************************************/
/* Lemmas about SecNC-SecJW exchange */
/*************************************/

#ifdef SecNCSecJW
lemma secNC_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*****************************************/
/* End lemmas about SecNC-SecJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecNC-SecPEi exchange */
/**************************************/

#ifdef SecNCSecPEi
lemma secNC_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecNC-SecPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecNC-SecPEo exchange */
/**************************************/

#ifdef SecNCSecPEo
lemma secNC_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/******************************************/
/* End lemmas about SecNC-SecPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecNC-SecPEio exchange */
/***************************************/

#ifdef SecNCSecPEio
lemma secNC_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecPEio exchange */
/*******************************************/

/*************************************/
/* Lemmas about SecNC-SecNC exchange */
/*************************************/

#ifdef SecNCSecNC
lemma secNC_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*****************************************/
/* End lemmas about SecNC-SecNC exchange */
/*****************************************/

/***************************************/
/* Lemmas about SecNC-SecOOBi exchange */
/***************************************/

#ifdef SecNCSecOOBi
lemma secNC_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecOOBi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecNC-SecOOBo exchange */
/***************************************/

#ifdef SecNCSecOOBo
lemma secNC_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecOOBo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecNC-SecOOBio exchange */
/****************************************/

#ifdef SecNCSecOOBio
lemma secNC_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecNC-SecOOBio exchange */
/********************************************/

/***************************************/
/* Lemmas about SecOOBi-SecJW exchange */
/***************************************/

#ifdef SecOOBiSecJW
lemma secOOBi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecOOBi-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBi-SecPEi exchange */
/****************************************/

#ifdef SecOOBiSecPEi
lemma secOOBi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBi-SecPEo exchange */
/****************************************/

#ifdef SecOOBiSecPEo
lemma secOOBi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecPEio exchange */
/*****************************************/

#ifdef SecOOBiSecPEio
lemma secOOBi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecOOBi-SecNC exchange */
/***************************************/

#ifdef SecOOBiSecNC
lemma secOOBi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecOOBi-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecOOBi exchange */
/*****************************************/

#ifdef SecOOBiSecOOBi
lemma secOOBi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecOOBo exchange */
/*****************************************/

#ifdef SecOOBiSecOOBo
lemma secOOBi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBi-SecOOBio exchange */
/******************************************/

#ifdef SecOOBiSecOOBio
lemma secOOBi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecOOBi-SecOOBio exchange */
/**********************************************/

/***************************************/
/* Lemmas about SecOOBo-SecJW exchange */
/***************************************/

#ifdef SecOOBoSecJW
lemma secOOBo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecOOBo-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBo-SecPEi exchange */
/****************************************/

#ifdef SecOOBoSecPEi
lemma secOOBo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBo-SecPEo exchange */
/****************************************/

#ifdef SecOOBoSecPEo
lemma secOOBo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecPEio exchange */
/*****************************************/

#ifdef SecOOBoSecPEio
lemma secOOBo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecOOBo-SecNC exchange */
/***************************************/

#ifdef SecOOBoSecNC
lemma secOOBo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*******************************************/
/* End lemmas about SecOOBo-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecOOBi exchange */
/*****************************************/

#ifdef SecOOBoSecOOBi
lemma secOOBo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecOOBo exchange */
/*****************************************/

#ifdef SecOOBoSecOOBo
lemma secOOBo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBo-SecOOBio exchange */
/******************************************/

#ifdef SecOOBoSecOOBio
lemma secOOBo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecOOBo-SecOOBio exchange */
/**********************************************/

/****************************************/
/* Lemmas about SecOOBio-SecJW exchange */
/****************************************/

#ifdef SecOOBioSecJW
lemma secOOBio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secJW_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBio-SecJW exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBio-SecPEi exchange */
/*****************************************/

#ifdef SecOOBioSecPEi
lemma secOOBio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-SecPEi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBio-SecPEo exchange */
/*****************************************/

#ifdef SecOOBioSecPEo
lemma secOOBio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-SecPEo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecPEio exchange */
/******************************************/

#ifdef SecOOBioSecPEio
lemma secOOBio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecPEio exchange */
/**********************************************/

/****************************************/
/* Lemmas about SecOOBio-SecNC exchange */
/****************************************/

#ifdef SecOOBioSecNC
lemma secOOBio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secNC_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/********************************************/
/* End lemmas about SecOOBio-SecNC exchange */
/********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecOOBi exchange */
/******************************************/

#ifdef SecOOBioSecOOBi
lemma secOOBio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBi_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecOOBi exchange */
/**********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecOOBo exchange */
/******************************************/

#ifdef SecOOBioSecOOBo
lemma secOOBio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBo_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecOOBo exchange */
/**********************************************/

/*******************************************/
/* Lemmas about SecOOBio-SecOOBio exchange */
/*******************************************/

#ifdef SecOOBioSecOOBio
lemma secOOBio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksI2, idI2, capI2, ksR2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR ksI ksR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBio_double_impersonation:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI1 idR1 capI1 capR1 ksI1 ksR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 ksI2 ksR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
            InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI1, pkR1, dh1, ltk1) @j1 &
            ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
            not (Ex #k1 #k2 .
                K(ltk1) @k1 & K(ltk2) @k2
            )
        )
"

#endif

/***********************************************/
/* End lemmas about SecOOBio-SecOOBio exchange */
/***********************************************/

/*************************************/
/* Lemmas about LegJW-SecJW exchange */
/*************************************/

#ifdef LegJWSecJW
lemma legJW_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secJW_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secJW_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secJW_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about LegJW-SecJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about LegJW-SecPEi exchange */
/**************************************/

#ifdef LegJWSecPEi
lemma legJW_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secPEi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secPEi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secPEi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegJW-SecPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about LegJW-SecPEo exchange */
/**************************************/

#ifdef LegJWSecPEo
lemma legJW_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secPEo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secPEo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secPEo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegJW-SecPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about LegJW-SecPEio exchange */
/***************************************/

#ifdef LegJWSecPEio
lemma legJW_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secPEio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secPEio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secPEio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegJW-SecPEio exchange */
/*******************************************/

/*************************************/
/* Lemmas about LegJW-SecNC exchange */
/*************************************/

#ifdef LegJWSecNC
lemma legJW_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secNC_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secNC_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secNC_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secNC_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secNC_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about LegJW-SecNC exchange */
/*****************************************/

/***************************************/
/* Lemmas about LegJW-SecOOBi exchange */
/***************************************/

#ifdef LegJWSecOOBi
lemma legJW_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secOOBi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secOOBi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secOOBi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secOOBi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secOOBi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegJW-SecOOBi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegJW-SecOOBo exchange */
/***************************************/

#ifdef LegJWSecOOBo
lemma legJW_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secOOBo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secOOBo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secOOBo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secOOBo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secOOBo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegJW-SecOOBo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegJW-SecOOBio exchange */
/****************************************/

#ifdef LegJWSecOOBio
lemma legJW_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legJW_secOOBio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legJW_secOOBio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legJW_secOOBio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legJW_secOOBio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legJW_secOOBio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegJW-SecOOBio exchange */
/********************************************/

/**************************************/
/* Lemmas about LegPEi-SecJW exchange */
/**************************************/

#ifdef LegPEiSecJW
lemma legPEi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secJW_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secJW_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secJW_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEi-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegPEi-SecPEi exchange */
/***************************************/

#ifdef LegPEiSecPEi
lemma legPEi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secPEi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secPEi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secPEi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEi-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegPEi-SecPEo exchange */
/***************************************/

#ifdef LegPEiSecPEo
lemma legPEi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secPEo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secPEo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secPEo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEi-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEi-SecPEio exchange */
/****************************************/

#ifdef LegPEiSecPEio
lemma legPEi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secPEio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secPEio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secPEio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEi-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about LegPEi-SecNC exchange */
/**************************************/

#ifdef LegPEiSecNC
lemma legPEi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secNC_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secNC_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secNC_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secNC_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secNC_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEi-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about LegPEi-SecOOBi exchange */
/****************************************/

#ifdef LegPEiSecOOBi
lemma legPEi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secOOBi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secOOBi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secOOBi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secOOBi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secOOBi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEi-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPEi-SecOOBo exchange */
/****************************************/

#ifdef LegPEiSecOOBo
lemma legPEi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secOOBo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secOOBo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secOOBo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secOOBo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secOOBo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEi-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPEi-SecOOBio exchange */
/*****************************************/

#ifdef LegPEiSecOOBio
lemma legPEi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEi_secOOBio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEi_secOOBio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEi_secOOBio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEi_secOOBio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEi_secOOBio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEi-SecOOBio exchange */
/*********************************************/

/**************************************/
/* Lemmas about LegPEo-SecJW exchange */
/**************************************/

#ifdef LegPEoSecJW
lemma legPEo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secJW_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secJW_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secJW_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEo-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegPEo-SecPEi exchange */
/***************************************/

#ifdef LegPEoSecPEi
lemma legPEo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secPEi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secPEi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secPEi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEo-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegPEo-SecPEo exchange */
/***************************************/

#ifdef LegPEoSecPEo
lemma legPEo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secPEo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secPEo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secPEo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEo-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEo-SecPEio exchange */
/****************************************/

#ifdef LegPEoSecPEio
lemma legPEo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secPEio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secPEio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secPEio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEo-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about LegPEo-SecNC exchange */
/**************************************/

#ifdef LegPEoSecNC
lemma legPEo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secNC_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secNC_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secNC_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secNC_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secNC_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegPEo-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about LegPEo-SecOOBi exchange */
/****************************************/

#ifdef LegPEoSecOOBi
lemma legPEo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secOOBi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secOOBi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secOOBi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secOOBi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secOOBi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEo-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPEo-SecOOBo exchange */
/****************************************/

#ifdef LegPEoSecOOBo
lemma legPEo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secOOBo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secOOBo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secOOBo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secOOBo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secOOBo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEo-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPEo-SecOOBio exchange */
/*****************************************/

#ifdef LegPEoSecOOBio
lemma legPEo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEo_secOOBio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEo_secOOBio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEo_secOOBio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEo_secOOBio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEo_secOOBio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEo-SecOOBio exchange */
/*********************************************/

/***************************************/
/* Lemmas about LegPEio-SecJW exchange */
/***************************************/

#ifdef LegPEioSecJW
lemma legPEio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secJW_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secJW_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secJW_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEio-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPEio-SecPEi exchange */
/****************************************/

#ifdef LegPEioSecPEi
lemma legPEio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secPEi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secPEi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secPEi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEio-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPEio-SecPEo exchange */
/****************************************/

#ifdef LegPEioSecPEo
lemma legPEio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secPEo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secPEo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secPEo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPEio-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPEio-SecPEio exchange */
/*****************************************/

#ifdef LegPEioSecPEio
lemma legPEio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secPEio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secPEio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secPEio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEio-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about LegPEio-SecNC exchange */
/***************************************/

#ifdef LegPEioSecNC
lemma legPEio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secNC_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secNC_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secNC_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secNC_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secNC_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPEio-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about LegPEio-SecOOBi exchange */
/*****************************************/

#ifdef LegPEioSecOOBi
lemma legPEio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secOOBi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secOOBi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secOOBi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secOOBi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secOOBi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEio-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPEio-SecOOBo exchange */
/*****************************************/

#ifdef LegPEioSecOOBo
lemma legPEio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secOOBo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secOOBo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secOOBo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secOOBo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secOOBo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPEio-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPEio-SecOOBio exchange */
/******************************************/

#ifdef LegPEioSecOOBio
lemma legPEio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPEio_secOOBio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPEio_secOOBio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legPEio_secOOBio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legPEio_secOOBio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPEio_secOOBio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPEio-SecOOBio exchange */
/**********************************************/

/**************************************/
/* Lemmas about LegOOB-SecJW exchange */
/**************************************/

#ifdef LegOOBSecJW
lemma legOOB_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secJW_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secJW_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secJW_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegOOB-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about LegOOB-SecPEi exchange */
/***************************************/

#ifdef LegOOBSecPEi
lemma legOOB_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secPEi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secPEi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secPEi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegOOB-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about LegOOB-SecPEo exchange */
/***************************************/

#ifdef LegOOBSecPEo
lemma legOOB_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secPEo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secPEo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secPEo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegOOB-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegOOB-SecPEio exchange */
/****************************************/

#ifdef LegOOBSecPEio
lemma legOOB_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secPEio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secPEio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secPEio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegOOB-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about LegOOB-SecNC exchange */
/**************************************/

#ifdef LegOOBSecNC
lemma legOOB_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secNC_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secNC_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secNC_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secNC_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secNC_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about LegOOB-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about LegOOB-SecOOBi exchange */
/****************************************/

#ifdef LegOOBSecOOBi
lemma legOOB_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secOOBi_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secOOBi_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secOOBi_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secOOBi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secOOBi_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegOOB-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegOOB-SecOOBo exchange */
/****************************************/

#ifdef LegOOBSecOOBo
lemma legOOB_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secOOBo_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secOOBo_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secOOBo_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secOOBo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secOOBo_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegOOB-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegOOB-SecOOBio exchange */
/*****************************************/

#ifdef LegOOBSecOOBio
lemma legOOB_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legOOB_secOOBio_auth_init:
"
    All idI idR capI capR ksI ksR tk nli nlr stk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, nli, nlr, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, ksR, idI, capI, ksI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legOOB_secOOBio_auth_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni ci cr #k .
            InitSentRandom(idI, capI, ksI, idR, capR, ksR, tk, ni, ci, cr) @k
        )
"

lemma legOOB_secOOBio_weaksecret_init:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, ksI, idR, capR, ksR, tk, ni, nr, stk) @j ==>
        not (Ex #k . K(stk) @k )
"

lemma legOOB_secOOBio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, ksR, idI, capI, ksI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legOOB_secOOBio_double_impersonation: 
"
    All #i1 #i2 .
    InitWillDoLegOOB()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, tk, ni, nr, stk) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(stk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegOOB-SecOOBio exchange */
/*********************************************/

/*************************************/
/* Lemmas about SecJW-LegJW exchange */
/*************************************/

#ifdef SecJWLegJW
lemma secJW_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secJW_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secJW_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secJW_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecJW-LegJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecJW-LegPEi exchange */
/**************************************/

#ifdef SecJWLegPEi
lemma secJW_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secJW_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secJW_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secJW_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecJW-LegPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecJW-LegPEo exchange */
/**************************************/

#ifdef SecJWLegPEo
lemma secJW_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secJW_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secJW_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secJW_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecJW-LegPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecJW-LegPEio exchange */
/***************************************/

#ifdef SecJWLegPEio
lemma secJW_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secJW_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secJW_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secJW_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-LegPEio exchange */
/*******************************************/

/**************************************/
/* Lemmas about SecJW-LegOOB exchange */
/**************************************/

#ifdef SecJWLegOOB
lemma secJW_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secJW_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secJW_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secJW_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecJW-LegOOB exchange */
/******************************************/

/**************************************/
/* Lemmas about SecPEi-LegJW exchange */
/**************************************/

#ifdef SecPEiLegJW
lemma secPEi_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEi_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEi_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEi_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEi-LegJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEi-LegPEi exchange */
/***************************************/

#ifdef SecPEiLegPEi
lemma secPEi_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEi_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEi_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEi_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-LegPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEi-LegPEo exchange */
/***************************************/

#ifdef SecPEiLegPEo
lemma secPEi_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEi_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEi_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEi_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-LegPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEi-LegPEio exchange */
/****************************************/

#ifdef SecPEiLegPEio
lemma secPEi_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEi_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEi_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEi_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-LegPEio exchange */
/********************************************/

/***************************************/
/* Lemmas about SecPEi-LegOOB exchange */
/***************************************/

#ifdef SecPEiLegOOB
lemma secPEi_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEi_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEi_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEi_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-LegOOB exchange */
/*******************************************/

/**************************************/
/* Lemmas about SecPEo-LegJW exchange */
/**************************************/

#ifdef SecPEoLegJW
lemma secPEo_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEo_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEo_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEo_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEo-LegJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEo-LegPEi exchange */
/***************************************/

#ifdef SecPEoLegPEi
lemma secPEo_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEo_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEo_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEo_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-LegPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEo-LegPEo exchange */
/***************************************/

#ifdef SecPEoLegPEo
lemma secPEo_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEo_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEo_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEo_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-LegPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEo-LegPEio exchange */
/****************************************/

#ifdef SecPEoLegPEio
lemma secPEo_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEo_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEo_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEo_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-LegPEio exchange */
/********************************************/

/***************************************/
/* Lemmas about SecPEo-LegOOB exchange */
/***************************************/

#ifdef SecPEoLegOOB
lemma secPEo_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEo_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEo_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEo_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-LegOOB exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEio-LegJW exchange */
/***************************************/

#ifdef SecPEioLegJW
lemma secPEio_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEio_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEio_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEio_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEio-LegJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEio-LegPEi exchange */
/****************************************/

#ifdef SecPEioLegPEi
lemma secPEio_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEio_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEio_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEio_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEio-LegPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEio-LegPEo exchange */
/****************************************/

#ifdef SecPEioLegPEo
lemma secPEio_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEio_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEio_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEio_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEio-LegPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEio-LegPEio exchange */
/*****************************************/

#ifdef SecPEioLegPEio
lemma secPEio_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEio_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEio_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEio_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-LegPEio exchange */
/*********************************************/

/****************************************/
/* Lemmas about SecPEio-LegOOB exchange */
/****************************************/

#ifdef SecPEioLegOOB
lemma secPEio_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secPEio_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secPEio_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secPEio_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEio-LegOOB exchange */
/********************************************/

/*************************************/
/* Lemmas about SecNC-LegJW exchange */
/*************************************/

#ifdef SecNCLegJW
lemma secNC_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secNC_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secNC_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secNC_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecNC-LegJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecNC-LegPEi exchange */
/**************************************/

#ifdef SecNCLegPEi
lemma secNC_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secNC_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secNC_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secNC_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecNC-LegPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecNC-LegPEo exchange */
/**************************************/

#ifdef SecNCLegPEo
lemma secNC_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secNC_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secNC_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secNC_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecNC-LegPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecNC-LegPEio exchange */
/***************************************/

#ifdef SecNCLegPEio
lemma secNC_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secNC_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secNC_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secNC_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-LegPEio exchange */
/*******************************************/

/**************************************/
/* Lemmas about SecNC-LegOOB exchange */
/**************************************/

#ifdef SecNCLegOOB
lemma secNC_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secNC_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secNC_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secNC_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecNC-LegOOB exchange */
/******************************************/

/***************************************/
/* Lemmas about SecOOBi-LegJW exchange */
/***************************************/

#ifdef SecOOBiLegJW
lemma secOOBi_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBi_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBi_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBi_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBi-LegJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBi-LegPEi exchange */
/****************************************/

#ifdef SecOOBiLegPEi
lemma secOOBi_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBi_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBi_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBi_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-LegPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBi-LegPEo exchange */
/****************************************/

#ifdef SecOOBiLegPEo
lemma secOOBi_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBi_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBi_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBi_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-LegPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBi-LegPEio exchange */
/*****************************************/

#ifdef SecOOBiLegPEio
lemma secOOBi_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBi_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBi_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBi_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-LegPEio exchange */
/*********************************************/

/****************************************/
/* Lemmas about SecOOBi-LegOOB exchange */
/****************************************/

#ifdef SecOOBiLegOOB
lemma secOOBi_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBi_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBi_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBi_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-LegOOB exchange */
/********************************************/

/***************************************/
/* Lemmas about SecOOBo-LegJW exchange */
/***************************************/

#ifdef SecOOBoLegJW
lemma secOOBo_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBo_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBo_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBo_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBo-LegJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBo-LegPEi exchange */
/****************************************/

#ifdef SecOOBoLegPEi
lemma secOOBo_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBo_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBo_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBo_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-LegPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBo-LegPEo exchange */
/****************************************/

#ifdef SecOOBoLegPEo
lemma secOOBo_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBo_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBo_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBo_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-LegPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBo-LegPEio exchange */
/*****************************************/

#ifdef SecOOBoLegPEio
lemma secOOBo_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBo_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBo_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBo_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-LegPEio exchange */
/*********************************************/

/****************************************/
/* Lemmas about SecOOBo-LegOOB exchange */
/****************************************/

#ifdef SecOOBoLegOOB
lemma secOOBo_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBo_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBo_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBo_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-LegOOB exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBio-LegJW exchange */
/****************************************/

#ifdef SecOOBioLegJW
lemma secOOBio_legJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBio_legJW_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBio_legJW_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legJW_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legJW_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBio_legJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBio-LegJW exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBio-LegPEi exchange */
/*****************************************/

#ifdef SecOOBioLegPEi
lemma secOOBio_legPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBio_legPEi_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBio_legPEi_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPEi_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPEi_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBio_legPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-LegPEi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBio-LegPEo exchange */
/*****************************************/

#ifdef SecOOBioLegPEo
lemma secOOBio_legPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBio_legPEo_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBio_legPEo_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPEo_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPEo_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBio_legPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-LegPEo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBio-LegPEio exchange */
/******************************************/

#ifdef SecOOBioLegPEio
lemma secOOBio_legPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBio_legPEio_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBio_legPEio_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPEio_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPEio_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBio_legPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-LegPEio exchange */
/**********************************************/

/*****************************************/
/* Lemmas about SecOOBio-LegOOB exchange */
/*****************************************/

#ifdef SecOOBioLegOOB
lemma secOOBio_legOOB_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2
    )
"

lemma secOOBio_legOOB_auth_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        (Ex tk ni nr ci cr #k.
            RespSentRandom(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, cr, ci) @k
        )
"

lemma secOOBio_legOOB_auth_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legOOB_weaksecret_init:
"
    All idI idR capI capR ksI ksR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, ksI, idR, capR, ksR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legOOB_weaksecret_resp:
"
    All idI idR capI capR ksI ksR tk ni nr stk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, ksR, idI, capI, ksI, tk, nr, ni, stk) @j ==>
        not (Ex #k. K(stk) @k )
"

lemma secOOBio_legOOB_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegOOB()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 ksI1 ksR1 idI2 idR2 capI2 capR2 ksI2 ksR2 tk ni nr stk pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, ksI1, idR1, capR1, ksR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, ksR2, idI2, capI2, ksI2, tk, nr, ni, stk) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(stk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-LegOOB exchange */
/*********************************************/

/*
* Command-line to generate a Tamarin file with the entire model without all preprocessor macros:
* tamarin-prover ble.spthy -DSecNCSecNC -DLegPEiSecPEo -DSecPEiLegOOB -DSecOOBiLegPEi -DRespLegPE -DLegPEiSecNC -DInitLegPE -DSecJWLegOOB -DLegJWSecJW -DLegPEiLegPEi -DLegPEiLegPEo -DLegJWSecPEo -DRespSecPEo -DSecOOBioSecNC -DLegJWLegPEio -DSecJWSecPEi -DLegPEiLegJW -DRespSec -DSecOOBiSecPEio -DSecPEiSecPEi -DSecPEoLegPEio -DSecOOBioLegOOB -DLegJWLegJW -DLegPEioLegOOB -DLegJWSecNC -DSecNCSecJW -DLegOOBSecPEi -DSecOOBioSecOOBio -DLegPEoLegPEio -DLegPEoSecPEio -DSecNCSecOOBo -DSecPEioSecJW -DInitSecOOBo -DLegOOBSecJW -DLegPEiSecJW -DLegOOBSecOOBi -DSecOOBiLegJW -DSecPEioSecOOBio -DInitSecJW -DLegJWSecOOBio -DRespSecJW -DSecJWLegPEo -DInoutInput -DLegPEioLegJW -DSecPEiSecOOBo -DSecOOBiSecJW -DLegPEoLegJW -DSecOOBoSecPEio -DSecPEioSecPEi -DLegPEiSecOOBo -DInitSecPEio -DLegPEiSecOOBi -DInitSecOOBi -DSecPEoSecJW -DInitLeg -DSecPEiLegPEo -DSecOOBoSecPEi -DRespSecOOBi -DLegOOBLegJW -DSecPEoLegJW -DLegPEioSecOOBi -DInitSecOOBio -DSecPEioSecPEo -DLegPEiSecPEi -DSecOOBoLegPEio -DSecPEoSecPEi -DSecPEiSecPEo -DSecPEiSecOOBi -DRespSecOOBo -DInitLegOOB -DSecPEoSecPEo -DLegJWLegPEi -DSecJWSecJW -DSecPEiLegPEi -DSecOOBoLegOOB -DRespLegPEi -DSecOOBiLegPEio -DSecJWSecNC -DInitLegJW -DSecJWSecOOBio -DRespLegOOB -DSecNCSecOOBi -DRespLeg -DLegPEioLegPEo -DSecNCLegPEo -DLegPEoLegPEi -DSecPEioSecOOBo -DInitSecPEo -DLegPEioSecOOBo -DLegOOBSecPEo -DSecPEoLegPEi -DSecJWSecOOBi -DRespSecPEi -DSecOOBioSecPEio -DSecNCLegJW -DRespSecOOBio -DInitSec -DSecPEoSecOOBi -DSecPEioSecNC -DSecPEiSecOOBio -DInputInput -DSecOOBioSecOOBo -DLegPEioSecNC -DRespLegPEo -DSecNCSecPEio -DSecOOBioSecOOBi -DOutputOutput -DLegJWLegPEo -DLegOOBSecPEio -DSecOOBiSecOOBi -DSecPEioSecPEio -DSecOOBoSecOOBi -DInitLegPEo -DLegJWSecPEi -DSecPEiSecNC -DLegJWSecOOBi -DLegPEiSecOOBio -DSecPEoLegOOB -DRespSecPE -DSecOOBoSecPEo -DSecPEioLegPEo -DLegPEoSecJW -DInitSecNC -DLegPEoSecOOBio -DInputOutput -DLegOOBSecOOBio -DSecOOBoLegPEi -DInoutOutput -DSecOOBioSecPEi -DSecPEiLegJW -DSecOOBiLegPEo -DSecOOBioSecPEo -DLegOOBLegPEio -DLegOOBSecNC -DSecOOBoSecOOBio -DLegPEoSecPEi -DSecOOBioLegPEio -DSecOOBiSecPEo -DSecOOBoSecOOBo -DSecNCLegPEi -DSecJWSecOOBo -DSecPEoSecOOBo -DSecOOBioSecJW -DSecJWLegJW -DLegPEioSecPEi -DSecPEiSecPEio -DSecPEoSecOOBio -DLegOOBLegOOB -DSecOOBiSecOOBio -DInitSecPE -DRespSecNC -DSecOOBioLegPEi -DLegJWSecOOBo -DSecNCLegOOB -DLegPEoLegPEo -DInitSecOOB -DSecOOBoLegJW -DLegPEioSecPEio -DLegPEoSecOOBi -DLegOOBLegPEo -DLegPEioSecPEo -DSecOOBiLegOOB -DLegPEoLegOOB -DSecNCLegPEio -DSecPEiSecJW -DRespSecPEio -DSecNCSecPEi -DOutputInput -DLegPEoSecPEo -DLegPEioSecJW -DSecOOBoSecJW -DInitLegPEio -DOutputInout -DSecPEiLegPEio -DSecPEioLegJW -DSecOOBoLegPEo -DInoutInout -DLegPEoSecOOBo -DRespLegJW -DLegOOBSecOOBo -DSecOOBoSecNC -DLegPEioLegPEi -DLegJWLegOOB -DLegPEoSecNC -DSecPEoLegPEo -DLegPEioSecOOBio -DRespSecOOB -DInitLegPEi -DSecJWLegPEi -DLegPEiLegOOB -DSecNCSecOOBio -DRespLegPEio -DSecPEioLegPEio -DInputInout -DSecNCSecPEo -DSecOOBiSecNC -DSecOOBiSecPEi -DSecOOBioLegPEo -DSecJWSecPEio -DSecOOBioLegJW -DSecOOBiSecOOBo -DSecJWLegPEio -DSecPEioLegPEi -DLegOOBLegPEi -DLegJWSecPEio -DLegPEiSecPEio -DInitSecPEi -DSecJWSecPEo -DLegPEiLegPEio -DSecPEioLegOOB -DSecPEoSecPEio -DSecPEoSecNC -DLegPEioLegPEio -DSecPEioSecOOBi
*/

/* Command lines to prove individual cases:
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespLeg -DRespLegJW -DLegJWLegJW --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespLeg -DRespLegPE -DRespLegPEi -DLegJWLegPEi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespLeg -DRespLegPE -DRespLegPEo -DLegJWLegPEo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespLeg -DRespLegPE -DRespLegPEio -DLegJWLegPEio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespLeg -DRespLegOOB -DLegJWLegOOB --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespLeg -DRespLegJW -DLegPEiLegJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespLeg -DRespLegPE -DRespLegPEi -DLegPEiLegPEi -DInputInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespLeg -DRespLegPE -DRespLegPEo -DLegPEiLegPEo -DInputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespLeg -DRespLegPE -DRespLegPEio -DLegPEiLegPEio -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespLeg -DRespLegOOB -DLegPEiLegOOB -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespLeg -DRespLegJW -DLegPEoLegJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespLeg -DRespLegPE -DRespLegPEi -DLegPEoLegPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespLeg -DRespLegPE -DRespLegPEo -DLegPEoLegPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespLeg -DRespLegPE -DRespLegPEio -DLegPEoLegPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespLeg -DRespLegOOB -DLegPEoLegOOB -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespLeg -DRespLegJW -DLegPEioLegJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespLeg -DRespLegPE -DRespLegPEi -DLegPEioLegPEi -DInoutInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespLeg -DRespLegPE -DRespLegPEo -DLegPEioLegPEo -DInoutOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespLeg -DRespLegPE -DRespLegPEio -DLegPEioLegPEio -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespLeg -DRespLegOOB -DLegPEioLegOOB -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespLeg -DRespLegJW -DLegOOBLegJW --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespLeg -DRespLegPE -DRespLegPEi -DLegOOBLegPEi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespLeg -DRespLegPE -DRespLegPEo -DLegOOBLegPEo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespLeg -DRespLegPE -DRespLegPEio -DLegOOBLegPEio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespLeg -DRespLegOOB -DLegOOBLegOOB --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecJW -DSecJWSecJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEi -DSecJWSecPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEo -DSecJWSecPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEio -DSecJWSecPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecNC -DSecJWSecNC --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBi -DSecJWSecOOBi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBo -DSecJWSecOOBo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBio -DSecJWSecOOBio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecJW -DSecPEiSecJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEi -DSecPEiSecPEi -DInputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEo -DSecPEiSecPEo -DInputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEio -DSecPEiSecPEio -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecNC -DSecPEiSecNC -DInputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEiSecOOBi -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEiSecOOBo -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEiSecOOBio -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecJW -DSecPEoSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEi -DSecPEoSecPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEo -DSecPEoSecPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEio -DSecPEoSecPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecNC -DSecPEoSecNC -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEoSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEoSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEoSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecJW -DSecPEioSecJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEi -DSecPEioSecPEi -DInoutInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEo -DSecPEioSecPEo -DInoutOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEio -DSecPEioSecPEio -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecNC -DSecPEioSecNC -DInoutOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEioSecOOBi -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEioSecOOBo -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEioSecOOBio -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecJW -DSecNCSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEi -DSecNCSecPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEo -DSecNCSecPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEio -DSecNCSecPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecNC -DSecNCSecNC -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBi -DSecNCSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBo -DSecNCSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBio -DSecNCSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecJW -DSecOOBiSecJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBiSecPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBiSecPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBiSecPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecNC -DSecOOBiSecNC --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBiSecOOBi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBiSecOOBo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBiSecOOBio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecJW -DSecOOBoSecJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBoSecPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBoSecPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBoSecPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecNC -DSecOOBoSecNC --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBoSecOOBi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBoSecOOBo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBoSecOOBio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecJW -DSecOOBioSecJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBioSecPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBioSecPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBioSecPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecNC -DSecOOBioSecNC --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBioSecOOBi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBioSecOOBo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBioSecOOBio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecJW -DLegJWSecJW --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecPE -DRespSecPEi -DLegJWSecPEi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecPE -DRespSecPEo -DLegJWSecPEo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecPE -DRespSecPEio -DLegJWSecPEio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecNC -DLegJWSecNC --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecOOB -DRespSecOOBi -DLegJWSecOOBi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecOOB -DRespSecOOBo -DLegJWSecOOBo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegJW -DRespSec -DRespSecOOB -DRespSecOOBio -DLegJWSecOOBio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecJW -DLegPEiSecJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecPE -DRespSecPEi -DLegPEiSecPEi -DInputInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecPE -DRespSecPEo -DLegPEiSecPEo -DInputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecPE -DRespSecPEio -DLegPEiSecPEio -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecNC -DLegPEiSecNC -DInputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPEiSecOOBi -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPEiSecOOBo -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEi -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPEiSecOOBio -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecJW -DLegPEoSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecPE -DRespSecPEi -DLegPEoSecPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecPE -DRespSecPEo -DLegPEoSecPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecPE -DRespSecPEio -DLegPEoSecPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecNC -DLegPEoSecNC -DOutputOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPEoSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPEoSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEo -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPEoSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecJW -DLegPEioSecJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecPE -DRespSecPEi -DLegPEioSecPEi -DInoutInput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecPE -DRespSecPEo -DLegPEioSecPEo -DInoutOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecPE -DRespSecPEio -DLegPEioSecPEio -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecNC -DLegPEioSecNC -DInoutOutput --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPEioSecOOBi -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPEioSecOOBo -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegPE -DInitLegPEio -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPEioSecOOBio -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecJW -DLegOOBSecJW --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecPE -DRespSecPEi -DLegOOBSecPEi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecPE -DRespSecPEo -DLegOOBSecPEo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecPE -DRespSecPEio -DLegOOBSecPEio --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecNC -DLegOOBSecNC --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecOOB -DRespSecOOBi -DLegOOBSecOOBi --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecOOB -DRespSecOOBo -DLegOOBSecOOBo --prove
tamarin-prover ble.spthy -DInitLeg -DInitLegOOB -DRespSec -DRespSecOOB -DRespSecOOBio -DLegOOBSecOOBio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegJW -DSecJWLegJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPE -DRespLegPEi -DSecJWLegPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPE -DRespLegPEo -DSecJWLegPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPE -DRespLegPEio -DSecJWLegPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegOOB -DSecJWLegOOB --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegJW -DSecPEiLegJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPE -DRespLegPEi -DSecPEiLegPEi -DInputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPE -DRespLegPEo -DSecPEiLegPEo -DInputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPE -DRespLegPEio -DSecPEiLegPEio -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegOOB -DSecPEiLegOOB -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegJW -DSecPEoLegJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPE -DRespLegPEi -DSecPEoLegPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPE -DRespLegPEo -DSecPEoLegPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPE -DRespLegPEio -DSecPEoLegPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegOOB -DSecPEoLegOOB -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegJW -DSecPEioLegJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPE -DRespLegPEi -DSecPEioLegPEi -DInoutInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPE -DRespLegPEo -DSecPEioLegPEo -DInoutOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPE -DRespLegPEio -DSecPEioLegPEio -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegOOB -DSecPEioLegOOB -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegJW -DSecNCLegJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPE -DRespLegPEi -DSecNCLegPEi -DOutputInput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPE -DRespLegPEo -DSecNCLegPEo -DOutputOutput --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPE -DRespLegPEio -DSecNCLegPEio -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegOOB -DSecNCLegOOB -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegJW -DSecOOBiLegJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPE -DRespLegPEi -DSecOOBiLegPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPE -DRespLegPEo -DSecOOBiLegPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPE -DRespLegPEio -DSecOOBiLegPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegOOB -DSecOOBiLegOOB --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegJW -DSecOOBoLegJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPE -DRespLegPEi -DSecOOBoLegPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPE -DRespLegPEo -DSecOOBoLegPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPE -DRespLegPEio -DSecOOBoLegPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegOOB -DSecOOBoLegOOB --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegJW -DSecOOBioLegJW --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPE -DRespLegPEi -DSecOOBioLegPEi --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPE -DRespLegPEo -DSecOOBioLegPEo --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPE -DRespLegPEio -DSecOOBioLegPEio --prove
tamarin-prover ble.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegOOB -DSecOOBioLegOOB --prove


JSON configuration file:
{
"LegJWLegJW": ["InitLeg","InitLegJW","RespLeg","RespLegJW","LegJWLegJW"],
"LegJWLegPEi": ["InitLeg","InitLegJW","RespLeg","RespLegPE","RespLegPEi","LegJWLegPEi"],
"LegJWLegPEo": ["InitLeg","InitLegJW","RespLeg","RespLegPE","RespLegPEo","LegJWLegPEo"],
"LegJWLegPEio": ["InitLeg","InitLegJW","RespLeg","RespLegPE","RespLegPEio","LegJWLegPEio"],
"LegJWLegOOB": ["InitLeg","InitLegJW","RespLeg","RespLegOOB","LegJWLegOOB"],
"LegPEiLegJW": ["InitLeg","InitLegPE","InitLegPEi","RespLeg","RespLegJW","LegPEiLegJW","InputInput","InputOutput","InputInout"],
"LegPEiLegPEi": ["InitLeg","InitLegPE","InitLegPEi","RespLeg","RespLegPE","RespLegPEi","LegPEiLegPEi","InputInput"],
"LegPEiLegPEo": ["InitLeg","InitLegPE","InitLegPEi","RespLeg","RespLegPE","RespLegPEo","LegPEiLegPEo","InputOutput"],
"LegPEiLegPEio": ["InitLeg","InitLegPE","InitLegPEi","RespLeg","RespLegPE","RespLegPEio","LegPEiLegPEio","InputInout"],
"LegPEiLegOOB": ["InitLeg","InitLegPE","InitLegPEi","RespLeg","RespLegOOB","LegPEiLegOOB","InputInput","InputOutput","InputInout"],
"LegPEoLegJW": ["InitLeg","InitLegPE","InitLegPEo","RespLeg","RespLegJW","LegPEoLegJW","OutputInput","OutputOutput","OutputInout"],
"LegPEoLegPEi": ["InitLeg","InitLegPE","InitLegPEo","RespLeg","RespLegPE","RespLegPEi","LegPEoLegPEi","OutputInput"],
"LegPEoLegPEo": ["InitLeg","InitLegPE","InitLegPEo","RespLeg","RespLegPE","RespLegPEo","LegPEoLegPEo","OutputOutput"],
"LegPEoLegPEio": ["InitLeg","InitLegPE","InitLegPEo","RespLeg","RespLegPE","RespLegPEio","LegPEoLegPEio","OutputInout"],
"LegPEoLegOOB": ["InitLeg","InitLegPE","InitLegPEo","RespLeg","RespLegOOB","LegPEoLegOOB","OutputInput","OutputOutput","OutputInout"],
"LegPEioLegJW": ["InitLeg","InitLegPE","InitLegPEio","RespLeg","RespLegJW","LegPEioLegJW","InoutInput","InoutOutput","InoutInout"],
"LegPEioLegPEi": ["InitLeg","InitLegPE","InitLegPEio","RespLeg","RespLegPE","RespLegPEi","LegPEioLegPEi","InoutInput"],
"LegPEioLegPEo": ["InitLeg","InitLegPE","InitLegPEio","RespLeg","RespLegPE","RespLegPEo","LegPEioLegPEo","InoutOutput"],
"LegPEioLegPEio": ["InitLeg","InitLegPE","InitLegPEio","RespLeg","RespLegPE","RespLegPEio","LegPEioLegPEio","InoutInout"],
"LegPEioLegOOB": ["InitLeg","InitLegPE","InitLegPEio","RespLeg","RespLegOOB","LegPEioLegOOB","InoutInput","InoutOutput","InoutInout"],
"LegOOBLegJW": ["InitLeg","InitLegOOB","RespLeg","RespLegJW","LegOOBLegJW"],
"LegOOBLegPEi": ["InitLeg","InitLegOOB","RespLeg","RespLegPE","RespLegPEi","LegOOBLegPEi"],
"LegOOBLegPEo": ["InitLeg","InitLegOOB","RespLeg","RespLegPE","RespLegPEo","LegOOBLegPEo"],
"LegOOBLegPEio": ["InitLeg","InitLegOOB","RespLeg","RespLegPE","RespLegPEio","LegOOBLegPEio"],
"LegOOBLegOOB": ["InitLeg","InitLegOOB","RespLeg","RespLegOOB","LegOOBLegOOB"],
"SecJWSecJW": ["InitSec","InitSecJW","RespSec","RespSecJW","SecJWSecJW"],
"SecJWSecPEi": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEi","SecJWSecPEi"],
"SecJWSecPEo": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEo","SecJWSecPEo"],
"SecJWSecPEio": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEio","SecJWSecPEio"],
"SecJWSecNC": ["InitSec","InitSecJW","RespSec","RespSecNC","SecJWSecNC"],
"SecJWSecOOBi": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBi","SecJWSecOOBi"],
"SecJWSecOOBo": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBo","SecJWSecOOBo"],
"SecJWSecOOBio": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBio","SecJWSecOOBio"],
"SecPEiSecJW": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecJW","SecPEiSecJW","InputInput","InputOutput","InputInout"],
"SecPEiSecPEi": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEi","SecPEiSecPEi","InputInput"],
"SecPEiSecPEo": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEo","SecPEiSecPEo","InputOutput"],
"SecPEiSecPEio": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEio","SecPEiSecPEio","InputInout"],
"SecPEiSecNC": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecNC","SecPEiSecNC","InputOutput"],
"SecPEiSecOOBi": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBi","SecPEiSecOOBi","InputInput","InputOutput","InputInout"],
"SecPEiSecOOBo": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBo","SecPEiSecOOBo","InputInput","InputOutput","InputInout"],
"SecPEiSecOOBio": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBio","SecPEiSecOOBio","InputInput","InputOutput","InputInout"],
"SecPEoSecJW": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecJW","SecPEoSecJW","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecPEi": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEi","SecPEoSecPEi","OutputInput"],
"SecPEoSecPEo": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEo","SecPEoSecPEo","OutputOutput"],
"SecPEoSecPEio": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEio","SecPEoSecPEio","OutputInout"],
"SecPEoSecNC": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecNC","SecPEoSecNC","OutputOutput"],
"SecPEoSecOOBi": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBi","SecPEoSecOOBi","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecOOBo": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBo","SecPEoSecOOBo","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecOOBio": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBio","SecPEoSecOOBio","OutputInput","OutputOutput","OutputInout"],
"SecPEioSecJW": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecJW","SecPEioSecJW","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecPEi": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEi","SecPEioSecPEi","InoutInput"],
"SecPEioSecPEo": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEo","SecPEioSecPEo","InoutOutput"],
"SecPEioSecPEio": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEio","SecPEioSecPEio","InoutInout"],
"SecPEioSecNC": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecNC","SecPEioSecNC","InoutOutput"],
"SecPEioSecOOBi": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBi","SecPEioSecOOBi","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecOOBo": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBo","SecPEioSecOOBo","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecOOBio": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBio","SecPEioSecOOBio","InoutInput","InoutOutput","InoutInout"],
"SecNCSecJW": ["InitSec","InitSecNC","RespSec","RespSecJW","SecNCSecJW","OutputInput","OutputOutput","OutputInout"],
"SecNCSecPEi": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEi","SecNCSecPEi","OutputInput"],
"SecNCSecPEo": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEo","SecNCSecPEo","OutputOutput"],
"SecNCSecPEio": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEio","SecNCSecPEio","OutputInout"],
"SecNCSecNC": ["InitSec","InitSecNC","RespSec","RespSecNC","SecNCSecNC","OutputOutput"],
"SecNCSecOOBi": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBi","SecNCSecOOBi","OutputInput","OutputOutput","OutputInout"],
"SecNCSecOOBo": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBo","SecNCSecOOBo","OutputInput","OutputOutput","OutputInout"],
"SecNCSecOOBio": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBio","SecNCSecOOBio","OutputInput","OutputOutput","OutputInout"],
"SecOOBiSecJW": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecJW","SecOOBiSecJW"],
"SecOOBiSecPEi": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEi","SecOOBiSecPEi"],
"SecOOBiSecPEo": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEo","SecOOBiSecPEo"],
"SecOOBiSecPEio": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEio","SecOOBiSecPEio"],
"SecOOBiSecNC": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecNC","SecOOBiSecNC"],
"SecOOBiSecOOBi": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBi","SecOOBiSecOOBi"],
"SecOOBiSecOOBo": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBo","SecOOBiSecOOBo"],
"SecOOBiSecOOBio": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBio","SecOOBiSecOOBio"],
"SecOOBoSecJW": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecJW","SecOOBoSecJW"],
"SecOOBoSecPEi": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEi","SecOOBoSecPEi"],
"SecOOBoSecPEo": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEo","SecOOBoSecPEo"],
"SecOOBoSecPEio": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEio","SecOOBoSecPEio"],
"SecOOBoSecNC": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecNC","SecOOBoSecNC"],
"SecOOBoSecOOBi": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBi","SecOOBoSecOOBi"],
"SecOOBoSecOOBo": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBo","SecOOBoSecOOBo"],
"SecOOBoSecOOBio": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBio","SecOOBoSecOOBio"],
"SecOOBioSecJW": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecJW","SecOOBioSecJW"],
"SecOOBioSecPEi": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEi","SecOOBioSecPEi"],
"SecOOBioSecPEo": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEo","SecOOBioSecPEo"],
"SecOOBioSecPEio": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEio","SecOOBioSecPEio"],
"SecOOBioSecNC": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecNC","SecOOBioSecNC"],
"SecOOBioSecOOBi": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBi","SecOOBioSecOOBi"],
"SecOOBioSecOOBo": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBo","SecOOBioSecOOBo"],
"SecOOBioSecOOBio": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBio","SecOOBioSecOOBio"],
"LegJWSecJW": ["InitLeg","InitLegJW","RespSec","RespSecJW","LegJWSecJW"],
"LegJWSecPEi": ["InitLeg","InitLegJW","RespSec","RespSecPE","RespSecPEi","LegJWSecPEi"],
"LegJWSecPEo": ["InitLeg","InitLegJW","RespSec","RespSecPE","RespSecPEo","LegJWSecPEo"],
"LegJWSecPEio": ["InitLeg","InitLegJW","RespSec","RespSecPE","RespSecPEio","LegJWSecPEio"],
"LegJWSecNC": ["InitLeg","InitLegJW","RespSec","RespSecNC","LegJWSecNC"],
"LegJWSecOOBi": ["InitLeg","InitLegJW","RespSec","RespSecOOB","RespSecOOBi","LegJWSecOOBi"],
"LegJWSecOOBo": ["InitLeg","InitLegJW","RespSec","RespSecOOB","RespSecOOBo","LegJWSecOOBo"],
"LegJWSecOOBio": ["InitLeg","InitLegJW","RespSec","RespSecOOB","RespSecOOBio","LegJWSecOOBio"],
"LegPEiSecJW": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecJW","LegPEiSecJW","InputInput","InputOutput","InputInout"],
"LegPEiSecPEi": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecPE","RespSecPEi","LegPEiSecPEi","InputInput"],
"LegPEiSecPEo": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecPE","RespSecPEo","LegPEiSecPEo","InputOutput"],
"LegPEiSecPEio": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecPE","RespSecPEio","LegPEiSecPEio","InputInout"],
"LegPEiSecNC": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecNC","LegPEiSecNC","InputOutput"],
"LegPEiSecOOBi": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecOOB","RespSecOOBi","LegPEiSecOOBi","InputInput","InputOutput","InputInout"],
"LegPEiSecOOBo": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecOOB","RespSecOOBo","LegPEiSecOOBo","InputInput","InputOutput","InputInout"],
"LegPEiSecOOBio": ["InitLeg","InitLegPE","InitLegPEi","RespSec","RespSecOOB","RespSecOOBio","LegPEiSecOOBio","InputInput","InputOutput","InputInout"],
"LegPEoSecJW": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecJW","LegPEoSecJW","OutputInput","OutputOutput","OutputInout"],
"LegPEoSecPEi": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecPE","RespSecPEi","LegPEoSecPEi","OutputInput"],
"LegPEoSecPEo": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecPE","RespSecPEo","LegPEoSecPEo","OutputOutput"],
"LegPEoSecPEio": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecPE","RespSecPEio","LegPEoSecPEio","OutputInout"],
"LegPEoSecNC": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecNC","LegPEoSecNC","OutputOutput"],
"LegPEoSecOOBi": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecOOB","RespSecOOBi","LegPEoSecOOBi","OutputInput","OutputOutput","OutputInout"],
"LegPEoSecOOBo": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecOOB","RespSecOOBo","LegPEoSecOOBo","OutputInput","OutputOutput","OutputInout"],
"LegPEoSecOOBio": ["InitLeg","InitLegPE","InitLegPEo","RespSec","RespSecOOB","RespSecOOBio","LegPEoSecOOBio","OutputInput","OutputOutput","OutputInout"],
"LegPEioSecJW": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecJW","LegPEioSecJW","InoutInput","InoutOutput","InoutInout"],
"LegPEioSecPEi": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecPE","RespSecPEi","LegPEioSecPEi","InoutInput"],
"LegPEioSecPEo": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecPE","RespSecPEo","LegPEioSecPEo","InoutOutput"],
"LegPEioSecPEio": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecPE","RespSecPEio","LegPEioSecPEio","InoutInout"],
"LegPEioSecNC": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecNC","LegPEioSecNC","InoutOutput"],
"LegPEioSecOOBi": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecOOB","RespSecOOBi","LegPEioSecOOBi","InoutInput","InoutOutput","InoutInout"],
"LegPEioSecOOBo": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecOOB","RespSecOOBo","LegPEioSecOOBo","InoutInput","InoutOutput","InoutInout"],
"LegPEioSecOOBio": ["InitLeg","InitLegPE","InitLegPEio","RespSec","RespSecOOB","RespSecOOBio","LegPEioSecOOBio","InoutInput","InoutOutput","InoutInout"],
"LegOOBSecJW": ["InitLeg","InitLegOOB","RespSec","RespSecJW","LegOOBSecJW"],
"LegOOBSecPEi": ["InitLeg","InitLegOOB","RespSec","RespSecPE","RespSecPEi","LegOOBSecPEi"],
"LegOOBSecPEo": ["InitLeg","InitLegOOB","RespSec","RespSecPE","RespSecPEo","LegOOBSecPEo"],
"LegOOBSecPEio": ["InitLeg","InitLegOOB","RespSec","RespSecPE","RespSecPEio","LegOOBSecPEio"],
"LegOOBSecNC": ["InitLeg","InitLegOOB","RespSec","RespSecNC","LegOOBSecNC"],
"LegOOBSecOOBi": ["InitLeg","InitLegOOB","RespSec","RespSecOOB","RespSecOOBi","LegOOBSecOOBi"],
"LegOOBSecOOBo": ["InitLeg","InitLegOOB","RespSec","RespSecOOB","RespSecOOBo","LegOOBSecOOBo"],
"LegOOBSecOOBio": ["InitLeg","InitLegOOB","RespSec","RespSecOOB","RespSecOOBio","LegOOBSecOOBio"],
"SecJWLegJW": ["InitSec","InitSecJW","RespLeg","RespLegJW","SecJWLegJW"],
"SecJWLegPEi": ["InitSec","InitSecJW","RespLeg","RespLegPE","RespLegPEi","SecJWLegPEi"],
"SecJWLegPEo": ["InitSec","InitSecJW","RespLeg","RespLegPE","RespLegPEo","SecJWLegPEo"],
"SecJWLegPEio": ["InitSec","InitSecJW","RespLeg","RespLegPE","RespLegPEio","SecJWLegPEio"],
"SecJWLegOOB": ["InitSec","InitSecJW","RespLeg","RespLegOOB","SecJWLegOOB"],
"SecPEiLegJW": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegJW","SecPEiLegJW","InputInput","InputOutput","InputInout"],
"SecPEiLegPEi": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPE","RespLegPEi","SecPEiLegPEi","InputInput"],
"SecPEiLegPEo": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPE","RespLegPEo","SecPEiLegPEo","InputOutput"],
"SecPEiLegPEio": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPE","RespLegPEio","SecPEiLegPEio","InputInout"],
"SecPEiLegOOB": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegOOB","SecPEiLegOOB","InputInput","InputOutput","InputInout"],
"SecPEoLegJW": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegJW","SecPEoLegJW","OutputInput","OutputOutput","OutputInout"],
"SecPEoLegPEi": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPE","RespLegPEi","SecPEoLegPEi","OutputInput"],
"SecPEoLegPEo": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPE","RespLegPEo","SecPEoLegPEo","OutputOutput"],
"SecPEoLegPEio": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPE","RespLegPEio","SecPEoLegPEio","OutputInout"],
"SecPEoLegOOB": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegOOB","SecPEoLegOOB","OutputInput","OutputOutput","OutputInout"],
"SecPEioLegJW": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegJW","SecPEioLegJW","InoutInput","InoutOutput","InoutInout"],
"SecPEioLegPEi": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPE","RespLegPEi","SecPEioLegPEi","InoutInput"],
"SecPEioLegPEo": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPE","RespLegPEo","SecPEioLegPEo","InoutOutput"],
"SecPEioLegPEio": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPE","RespLegPEio","SecPEioLegPEio","InoutInout"],
"SecPEioLegOOB": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegOOB","SecPEioLegOOB","InoutInput","InoutOutput","InoutInout"],
"SecNCLegJW": ["InitSec","InitSecNC","RespLeg","RespLegJW","SecNCLegJW","OutputInput","OutputOutput","OutputInout"],
"SecNCLegPEi": ["InitSec","InitSecNC","RespLeg","RespLegPE","RespLegPEi","SecNCLegPEi","OutputInput"],
"SecNCLegPEo": ["InitSec","InitSecNC","RespLeg","RespLegPE","RespLegPEo","SecNCLegPEo","OutputOutput"],
"SecNCLegPEio": ["InitSec","InitSecNC","RespLeg","RespLegPE","RespLegPEio","SecNCLegPEio","OutputInout"],
"SecNCLegOOB": ["InitSec","InitSecNC","RespLeg","RespLegOOB","SecNCLegOOB","OutputInput","OutputOutput","OutputInout"],
"SecOOBiLegJW": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegJW","SecOOBiLegJW"],
"SecOOBiLegPEi": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPE","RespLegPEi","SecOOBiLegPEi"],
"SecOOBiLegPEo": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPE","RespLegPEo","SecOOBiLegPEo"],
"SecOOBiLegPEio": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPE","RespLegPEio","SecOOBiLegPEio"],
"SecOOBiLegOOB": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegOOB","SecOOBiLegOOB"],
"SecOOBoLegJW": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegJW","SecOOBoLegJW"],
"SecOOBoLegPEi": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPE","RespLegPEi","SecOOBoLegPEi"],
"SecOOBoLegPEo": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPE","RespLegPEo","SecOOBoLegPEo"],
"SecOOBoLegPEio": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPE","RespLegPEio","SecOOBoLegPEio"],
"SecOOBoLegOOB": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegOOB","SecOOBoLegOOB"],
"SecOOBioLegJW": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegJW","SecOOBioLegJW"],
"SecOOBioLegPEi": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPE","RespLegPEi","SecOOBioLegPEi"],
"SecOOBioLegPEo": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPE","RespLegPEo","SecOOBioLegPEo"],
"SecOOBioLegPEio": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPE","RespLegPEio","SecOOBioLegPEio"],
"SecOOBioLegOOB": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegOOB","SecOOBioLegOOB"],
}
*/

end
