theory BluetoothClassicPairing
begin

builtins: diffie-hellman, symmetric-encryption, xor

functions:
    hmac_sha256/2, // Interface is hmac_sha256(key, data)
    sha256/1, // sha256(data)
    f1/4, // Commitment computation function
    g/4, // Numeric code computation
    f2/6, // Key derivation, get LK
    f3/7, //Generation of dhkeycheck
    e22/2, // Key generation, generation of Kinit
    e21/2, // Key generation, generation of LK
    e1_sres/3, // Authentication function in Legacy Pairing
    e1_aco/3, // Authentication function in Legacy Pairing
    e0/3, // Encryption, not precise
    split1/1,
    split2/1,
    recover/2,
    e/3,
    extract_e/1
equations:
    f1(u,v,x,z) = hmac_sha256(x,<u,v,z>), // f1 according to the spec (Vol 2 Part H, 7.7.1)
    g(u,v,x,y) = sha256(<x,u,v,y>), // g according to the spec (Vol 2 Part H, 7.7.2)
    f2(w, n1, n2, kid, a1, a2) = hmac_sha256(w, <n1, n2, kid, a1, a2>), // f2 according to the spec (Vol 2 Part H 7.7.3)
    f3(w, n1, n2, r, iocap, a1, a2) = hmac_sha256(w, <n1, n2, r, iocap, a1, a2>), // f3 according to the spec (Vol 2 Part H 7.7.4)
    recover(split1(x), split2(x)) = x, // Allow the attacker to reconstruct the passkey from two halves
    extract_e(e(t,s,n)) = n

rule CreateDevice:
     []
     --[]->
     [!Device(<$id,$cap>), // Represents a device
      Out(<$id,$cap>)] // The device announces itself (sort of)

/*
This represents the messages leading to Pairing (it is very simplified).
Here, the Initiator receives the responder's address and capabilities,
the Responder receives the Initiator's address and capabilities.
*/
rule InitPreparePairing:
    [
    !Device(<$idI, $capI>),
    In(<$idR, $capR>)
    ]
    --[
        InitPreparePairing($idI, $capI, $idR, $capR)
    ]->
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]

rule RespPreparePairing:
    [
    !Device(<$idR, $capR>),
    In(<$idI, $capI>)
    ]
    --[
        RespPreparePairing($idR, $capR, $idI, $capI)
    ]->
    [
    RespPreparePairing($idR, $capR, $idI, $capI)
    ]

/*
* Select the Pairing method. Here, it is one of :
* - Legacy PIN Pairing 
* - Secure JustWorks (SecJW)
* - Secure Passkey Entry (SecPE)
* - Secure NumericComparison (SecNC)
* - Secure Out of Band (SecOOB)
*
* The model restricts the choice to one Pairing method per role (Initiator or Responder)
* through the restrictions InitOnlyOncePairing / RespOnlyOncePairing
* Therefore, only one session can be ran. While not ideal, this prevents a state explosion :
* Even with a much simpler model (one Pairing method), Tamarin runs out of RAM when studying
* an unbounded number of sessions
*
* Possibility: Change the model to create a bounded number of sessions
*/

/*
The variables for BR/EDR PIN Pairing:
The PIN can be either: fixed or variable
The device can have input, output, inputoutput capabilities
*/
#ifdef InitLeg
rule InitPrepareLegPIN:
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoLegPIN()
    ]->
    [
    InitDoLegPIN($idI, $capI, $idR, $capR),
    InitChooseLegPINMode($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespLeg
rule RespPrepareLegPIN:
    [
    RespPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoLegPIN()
    ]->
    [
    RespDoLegPIN($idI, $capI, $idR, $capR),
    RespChooseLegPINMode($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitSecJW
rule InitPrepareSecJW:
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecJW()
    ]->
    [
    InitDoSecJW($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecJW
rule RespPrepareSecJW:
    [
    RespPreparePairing($idR, $capR, $idI, $capI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecJW()
    ]->
    [
    RespDoSecJW($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef InitSecPE
rule InitPrepareSecPE:
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecPE()
    ]->
    [
    InitDoSecPE($idI, $capI, $idR, $capR),
    InitChooseSecPEMode($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecPE
rule RespPrepareSecPE:
    [
    RespPreparePairing($idR, $capR, $idI, $capI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecPE()
    ]->
    [
    RespDoSecPE($idR, $capR, $idI, $capI),
    RespChooseSecPEMode($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef InitSecNC
rule InitPrepareSecNC:
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecNC()
    ]->
    [
    InitDoSecNC($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecNC
rule RespPrepareSecNC:
    [
    RespPreparePairing($idR, $capR, $idI, $capI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecNC()
    ]->
    [
    RespDoSecNC($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef InitSecOOB
rule InitPrepareSecOOB:
    [
    InitPreparePairing($idI, $capI, $idR, $capR)
    ]
    --[
        InitOnlyOncePairing(),
        InitWillDoSecOOB()
    ]->
    [
    InitDoSecOOB($idI, $capI, $idR, $capR),
    InitChooseOOBMode($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecOOB
rule RespPrepareSecOOB:
    [
    RespPreparePairing($idR, $capR, $idI, $capI)
    ]
    --[
        RespOnlyOncePairing(),
        RespWillDoSecOOB()
    ]->
    [
    RespDoSecOOB($idR, $capR, $idI, $capI),
    RespChooseOOBMode($idR, $capR, $idI, $capI)
    ]
#endif

/*
 * This dispatches the Initiator and Responder to the chosen variant
 * of the PE Pairing method.
 * The possibility are:
 * - PEi : Passkey Entry, can take inputs from the user
 * - PEo : Passkey Entry, device outputs to the user
 * - PEio : Passkey Entry, device can take inputs or outputs to the user
*/


/* TODO: To delete, only for example
#ifdef RespLegPEio
rule RespDoLegPEio:
    [
    RespChooseLegPEMode($idR, $capR, $idI, $capI),
    Fr(~passkey)
    ]
    --[
    RespLegPEOnlyOnce(),
    RespWillDoLegPEio()
    ]->
    [
    RespWaitUserInout(~passkey),
    RespTriggerUserInteraction(),
    RespReadyPE($idR, $capR, $idI, $capI)
    ]
#endif
*/

#ifdef InitLegPINi
rule InitDoLegPINi:
    [
    InitChooseLegPINMode($idI, $capI, $idR, $capR)
    ]
    --[
    InitLegPINOnlyOnce(),
    InitWillDoLegPINi()
    ]->
    [
    InitWaitUserInput(),
    InitTriggerUserInteraction(),
    InitReadyPIN($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitLegPINo
rule InitDoLegPINo:
    [
    InitChooseLegPINMode($idI, $capI, $idR, $capR),
    Fr(~pin)
    ]
    --[
    InitLegPINOnlyOnce(),
    InitWillDoLegPINo()
    ]->
    [
    InitWaitUserConfirm(~pin),
    InitTriggerUserInteraction(),
    InitReadyPIN($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitLegPINio
rule InitDoLegPINio:
    [
    InitChooseLegPINMode($idI, $capI, $idR, $capR),
    Fr(~pin)
    ]
    --[
    InitLegPINOnlyOnce(),
    InitWillDoLegPINio()
    ]->
    [
    InitWaitUserInout(~pin),
    InitTriggerUserInteraction(),
    InitReadyPIN($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespLegPINi
rule RespDoLegPINi:
    [
    RespChooseLegPINMode($idR, $capR, $idI, $capI)
    ]
    --[
    RespLegPINOnlyOnce(),
    RespWillDoLegPINi()
    ]->
    [
    RespWaitUserInput(),
    RespTriggerUserInteraction(),
    RespReadyPIN($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespLegPINo
rule RespDoLegPINo:
    [
    RespChooseLegPINMode($idR, $capR, $idI, $capI),
    Fr(~pin)
    ]
    --[
    RespLegPINOnlyOnce(),
    RespWillDoLegPINo()
    ]->
    [
    RespWaitUserConfirm(~pin),
    RespTriggerUserInteraction(),
    RespReadyPIN($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespLegPINio
rule RespDoLegPINio:
    [
    RespChooseLegPINMode($idR, $capR, $idI, $capI),
    Fr(~pin)
    ]
    --[
    RespLegPINOnlyOnce(),
    RespWillDoLegPINio()
    ]->
    [
    RespWaitUserInout(~pin),
    RespTriggerUserInteraction(),
    RespReadyPIN($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef InitSecPEi
rule InitChooseSecPEi:
    [
    InitChooseSecPEMode($idI, $capI, $idR, $capR)
    ]
    --[
    InitSecPEOnlyOnce(),
    InitWillDoSecPEi()
    ]->
    [
    InitWaitUserInput(),
    InitDoSecPEi($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitSecPEo
rule InitChooseSecPEo:
    [
    InitChooseSecPEMode($idI, $capI, $idR, $capR),
    Fr(~passkey)
    ]
    --[
        InitSecPEOnlyOnce(),
        InitWillDoSecPEo()
    ]->
    [
    InitWaitUserConfirm(~passkey),
    InitDoSecPEo($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitSecPEio
rule InitChooseSecPEio:
    [
    InitChooseSecPEMode($idI, $capI, $idR, $capR),
    Fr(~passkey)
    ]
    --[
    InitSecPEOnlyOnce(),
    InitWillDoSecPEio()
    ]->
    [
    InitWaitUserInout(~passkey),
    InitDoSecPEio($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecPEi
rule RespChooseSecPEi:
    [
    RespChooseSecPEMode($idR, $capR, $idI, $capI)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEi()
    ]->
    [
    RespWaitUserInput(),
    RespDoSecPEi($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespSecPEo
rule RespChooseSecPEo:
    [
    RespChooseSecPEMode($idR, $capR, $idI, $capI),
    Fr(~passkey)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEo()
    ]->
    [
    RespWaitUserConfirm(~passkey),
    RespDoSecPEo($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespSecPEio
rule RespChooseSecPEio:
    [
    RespChooseSecPEMode($idR, $capR, $idI, $capI),
    Fr(~passkey)
    ]
    --[
    RespSecPEOnlyOnce(),
    RespWillDoSecPEio()
    ]->
    [
    RespWaitUserInout(~passkey),
    RespDoSecPEio($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

/*
 * This dispatches the Initiator and Responder to the chosen variant
 * of the Secure OOB Pairing method.
 * The possibility are:
 * - OOBi : OOB, device expects input OOB data
 * - OOBo : OOB, device outputs OOB data
 * - OOBio : OOB, device expects and outputs OOB data
*/
#ifdef InitSecOOBi
rule InitChooseSecOOBi:
    [
    InitChooseOOBMode($idI, $capI, $idR, $capR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBi()
    ]->
    [
    InitDoSecOOBi($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitSecOOBo
rule InitChooseSecOOBo:
    [
    InitChooseOOBMode($idI, $capI, $idR, $capR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBo()
    ]->
    [
    InitDoSecOOBo($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef InitSecOOBio
rule InitChooseSecOOBio:
    [
    InitChooseOOBMode($idI, $capI, $idR, $capR)
    ]
    --[
        InitSecOOBOnlyOnce(),
        InitWillDoSecOOBio()
    ]->
    [
    InitDoSecOOBio($idI, $capI, $idR, $capR),
    InitDoECDH($idI, $capI, $idR, $capR)
    ]
#endif

#ifdef RespSecOOBi
rule RespChooseSecOOBi:
    [
    RespChooseOOBMode($idR, $capR, $idI, $capI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBi()
    ]->
    [
    RespDoSecOOBi($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespSecOOBo
rule RespChooseSecOOBo:
    [
    RespChooseOOBMode($idR, $capR, $idI, $capI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBo()
    ]->
    [
    RespDoSecOOBo($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

#ifdef RespSecOOBio
rule RespChooseSecOOBio:
    [
    RespChooseOOBMode($idR, $capR, $idI, $capI)
    ]
    --[
        RespSecOOBOnlyOnce(),
        RespWillDoSecOOBio()
    ]->
    [
    RespDoSecOOBio($idR, $capR, $idI, $capI),
    RespDoECDH($idR, $capR, $idI, $capI)
    ]
#endif

// Legacy PIN Pairing
#ifdef InitLeg
rule InitLegSendInRand:
    let Kinit = e22(pin, ~in_rand) in
    [
    InitReadyPIN($idI, $capI, $idR, $capR),
    InitUserProceed(pin),
    Fr(~in_rand)
    ]
    --[
    InitStartLegPIN($idI, $capI, $idR, $capR, pin, Kinit),
    LowEntropy(pin)
    ]->
    [
    InitDoLegPairing($idI, $capI, $idR, $capR, Kinit),
    LowEntropy(pin),
    Out(~in_rand)
    ]
#endif

#ifdef RespLeg
rule RespLegSendInRand:
    let Kinit = e22(pin, in_rand) in
    [
    RespReadyPIN($idR, $capR, $idI, $capI),
    RespUserProceed(pin),
    In(in_rand)
    ]
    --[
    RespStartLegPIN($idR, $capR, $idI, $capI, pin, Kinit),
    LowEntropy(pin)
    ]->
    [
    RespDoLegPairing($idI, $capI, $idR, $capR, Kinit),
    LowEntropy(pin)
    ]
#endif

#ifdef InitLeg
rule InitSendCompRand:
    let masked_rand_i = Kinit XOR ~rand_i in
    [
    InitDoLegPairing($idI, $capI, $idR, $capR, Kinit),
    Fr(~rand_i)
    ]
    --[
    ]->
    [
    InitSendCompRand($idI, $capI, $idR, $capR, Kinit, ~rand_i),
    Out(masked_rand_i)
    ]
#endif

#ifdef RespLeg
rule RespSendCompRand:
    let
        masked_rand_r = Kinit XOR ~rand_r
        rand_i = Kinit XOR recvd_rand_i
    in
    [
    RespDoLegPairing($idR, $capR, $idI, $capI, Kinit),
    Fr(~rand_r),
    In(recvd_rand_i)
    ]
    --[
    ]->
    [
    RespSendCompRand($idR, $capR, $idI, $capI, Kinit, ~rand_r, rand_i),
    Out(masked_rand_r)
    ]
#endif

#ifdef InitLeg
rule InitDeriveLK:
    let
        rand_r = Kinit XOR recv_rand_r
        LK = e21(~rand_i, $idI) XOR e21(rand_r, $idR)
    in
    [
    InitSendCompRand($idI, $capI, $idR, $capR, Kinit, ~rand_i),
    In(recv_rand_r)
    ]
    --[
    InitFinishedKeyDerivation($idI, $capI, $idR, $capR, LK)
    ]->
    [
    InitFinishedKeyDerivation($idI, $capI, $idR, $capR, LK)
    ]
#endif

#ifdef RespLeg
rule RespDeriveLK:
    let
        LK = e21(rand_i, $idI) XOR e21(~rand_r, $idR)
    in
    [
    RespSendCompRand($idR, $capR, $idI, $capI, Kinit, ~rand_r, rand_i)
    ]
    --[
    RespFinishedKeyDerivation($idR, $capR, $idI, $capI, LK)
    ]->
    [
    RespFinishedKeyDerivation($idR, $capR, $idI, $capI, LK)
    ]
#endif

/*
In the spec
Vol 2 Part C, $4.2.2.4: When the new link key has been created mutual authentication shall be
performed to confirm that the same link key has been created in both devices.
*/

#ifdef InitLeg
rule InitBeginAuthVerifier1:
    [
    InitFinishedKeyDerivation($idI, $capI, $idR, $capR, LK),
    Fr(~au_rand_1)
    ]
    --[
    AuthOnlyOneBegin(),
    InitBeginAuth($idI, $capI, $idR, $capR, LK, ~au_rand_1)
    ]->
    [
    InitBeginAuth($idI, $capI, $idR, $capR, LK, ~au_rand_1),
    Out(~au_rand_1)
    ]
#endif

#ifdef RespLeg
rule RespClaimantAuth1:
    let
        sres = e1_sres(LK, $idR, au_rand_1)
        aco = e1_aco(LK, $idR, au_rand_1)
    in
    [
    RespFinishedKeyDerivation($idR, $capR, $idI, $capI, LK),
    In(au_rand_1)
    ]
    --[
    RespClaimantAuth1($idR, $capR, $idI, $capI, LK, sres, aco)
    ]->
    [
    RespClaimantAuth1($idR, $capR, $idI, $capI, LK, sres, aco),
    OracleLK(au_rand_1, sres),
    Out(sres)
    ]
#endif

#ifdef InitLeg
rule InitVerifierRecvAuth1:
    let
        sres = e1_sres(LK, $idR, ~au_rand_1)
        aco = e1_aco(LK, $idR, ~au_rand_1)
    in
    [
    InitBeginAuth($idI, $capI, $idR, $capR, LK, ~au_rand_1),
    In(e1_sres(LK, $idR, ~au_rand_1))
    ]
    --[ ]->
    [
    InitVerifierAuth1($idI, $capI, $idR, $capR, LK, aco)
    ]
#endif

#ifdef RespLeg
rule RespVerifierSendAuth2:
    [
    RespClaimantAuth1($idR, $capR, $idI, $capI, LK, sres, aco),
    Fr(~au_rand_2)
    ]
    --[
        RespVerifierSendAuth2($idR, $capR, $idI, $capI, LK, ~au_rand_2)
    ]->
    [
    RespVerifierSendAuth2($idR, $capR, $idI, $capI, LK, ~au_rand_2),
    Out(~au_rand_2)
    ]
#endif

#ifdef InitLeg
rule InitClaimantAuth2:
    let
        sres = e1_sres(LK, $idI, au_rand_2)
        aco = e1_aco(LK, $idI, au_rand_2)
    in
    [
    InitVerifierAuth1($idI, $capI, $idR, $capR, LK, old_aco),
    In(au_rand_2)
    ]
    --[
        InitClaimantAuth2($idI, $capI, $idR, $capR, LK, aco)
    ]->
    [
    InitClaimantAuth2($idI, $capI, $idR, $capR, LK, aco),
    OracleLK(au_rand_2, sres),
    Out(sres)
    ]
#endif

#ifdef RespLeg
rule RespVerifierRecvAuth2:
    let aco = e1_aco(LK, $idI, ~au_rand_2) in
    [
    RespVerifierSendAuth2($idR, $capR, $idI, $capI, LK, ~au_rand_2),
    In(e1_sres(LK, $idI, ~au_rand_2))
    ]   
    --[
        ResponderFinishedLegPairing($idR, $capR, $idI, $capI, LK, aco)
    ]->
    [
    ResponderFinishedLegPairing($idR, $capR, $idI, $capI, LK, aco)
    ]
#endif

#ifdef InitLeg
rule InitLegFinishPairing:
    [
    InitClaimantAuth2($idI, $capI, $idR, $capR, LK, aco)
    ]
    --[
    InitiatorFinishedLegPairing($idI, $capI, $idR, $capR, LK, aco)
    ]->
    [
    InitiatorFinishedLegPairing($idI, $capI, $idR, $capR, LK, aco)
    ]
#endif

#ifdef RespLeg
rule RespBeginAuthVerifier1:
    [
    RespFinishedKeyDerivation($idR, $capR, $idI, $capI, LK),
    Fr(~au_rand_1)
    ]
    --[
    AuthOnlyOneBegin(),
    RespBeginAuth($idR, $capR, $idI, $capI, LK, ~au_rand_1)
    ]->
    [
    RespBeginAuth($idR, $capR, $idI, $capI, LK, ~au_rand_1),
    Out(~au_rand_1)
    ]
#endif

#ifdef InitLeg
rule InitClaimantAuth1:
    let
        sres = e1_sres(LK, $idI, au_rand_1)
        aco = e1_aco(LK, $idI, au_rand_1)
    in
    [
    InitFinishedKeyDerivation($idI, $capI, $idR, $capR, LK),
    In(au_rand_1)
    ]
    --[
        InitClaimantAuth1($idI, $capI, $idR, $capR, LK, aco)
    ]->
    [
    InitClaimantAuth1($idI, $capI, $idR, $capR, LK, aco),
    OracleLK(au_rand_1, sres),
    Out(sres)
    ]
#endif

#ifdef RespLeg
rule RespVerifierRecvAuth1:
    let aco = e1_aco(LK, $idI, ~au_rand_1) in
    [
    RespBeginAuth($idR, $capR, $idI, $capI, LK, ~au_rand_1),
    In(e1_sres(LK, $idI, ~au_rand_1))
    ]
    --[
        RespVerifierRecvAuth1($idR, $capR, $idI, $capI, LK, aco)
    ]->
    [
    RespVerifierRecvAuth1($idR, $capR, $idI, $capI, LK, aco)
    ]
#endif

#ifdef InitLeg
rule InitVerifierSendAuth2:
    [
    InitClaimantAuth1($idI, $capI, $idR, $capR, LK, old_aco),
    Fr(~au_rand_2)
    ]
    --[
        InitVerifierSendAuth2($idI, $capI, $idR, $capR, LK, ~au_rand_2)
    ]->
    [
    InitVerifierSendAuth2($idI, $capI, $idR, $capR, LK, ~au_rand_2),
    Out(~au_rand_2)
    ]
#endif

#ifdef RespLeg
rule RespClaimantAuth2:
    let 
        sres = e1_sres(LK, $idR, au_rand_2)
        aco = e1_aco(LK, $idR, au_rand_2)
    in
    [
    RespVerifierRecvAuth1($idR, $capR, $idI, $capI, LK, old_aco),
    In(au_rand_2)
    ]
    --[
        RespClaimantAuth2($idR, $capR, $idI, $capI, LK, aco)
    ]->
    [
    RespClaimantAuth2($idR, $capR, $idI, $capI, LK, aco),
    OracleLK(au_rand_2, sres),
    Out(sres)
    ]
#endif

#ifdef InitLeg
rule InitVerifierRecvAuth2:
    let
        aco = e1_aco(LK, $idR, ~au_rand_2)
    in
    [
    InitVerifierSendAuth2($idI, $capI, $idR, $capR, LK, ~au_rand_2),
    In(e1_sres(LK, $idR, ~au_rand_2))
    ]
    --[
        InitiatorFinishedLegPairing($idI, $capI, $idR, $capR, LK, aco)
    ]->
    [
    InitiatorFinishedLegPairing($idI, $capI, $idR, $capR, LK, aco)
    ]
#endif

#ifdef RespLeg
rule RespFinishedPairing:
    [
    RespClaimantAuth2($idR, $capR, $idI, $capI, LK, aco)
    ]
    --[
        ResponderFinishedLegPairing($idR, $capR, $idI, $capI, LK, aco)
    ]->
    [
    ResponderFinishedLegPairing($idR, $capR, $idI, $capI, LK, aco)
    ]
#endif

/* Easy encryption, decryption, to be able to make lemmas which will encompass both authentication paths */

#ifdef InitLeg
rule InitLegSendMsg:
    [
    InitiatorFinishedLegPairing($idI, $capI, $idR, $capR, LK, aco)
    ]
    --[
        InitSendMsg($idI, $capI, $idR, $capR, LK, aco, 'init')
    ]->
    [
    InitLegSentMsg($idI, $capI, $idR, $capR, LK, aco, 'init'),
    Out(e0(LK, aco, 'init'))
    ]
#endif

#ifdef RespLeg
rule RespLegRecvMsg:
    [
    ResponderFinishedLegPairing($idR, $capR, $idI, $capI, LK, aco),
    In(e0(LK, aco, 'init'))
    ]
    --[
        RespRecvSendMsg($idR, $capR, $idI, $capI, LK, aco, 'resp')
    ]->
    [
    RespLegSentMsg($idR, $capR, $idI, $capI, LK, aco, 'resp'),
    Out(e0(LK, aco, 'resp'))
    ]
#endif

#ifdef InitLeg
rule InitLegRecvMsg:
    [
    InitLegSentMsg($idI, $capI, $idR, $capR, LK, aco, m),
    In(e0(LK, aco, 'resp'))
    ]
    --[
        InitRecvMsg($idI, $capI, $idR, $capR, LK, aco, 'resp')
    ]->
    [
    InitLegRecvMsg($idI, $capI, $idR, $capR, LK, aco, 'resp')
    ]
#endif

/*
* Public key exchange, common for all Secure Pairing protocols
* The Initiator sends its public key, and receives the one from
* the Responder:
* I -> R: pkI = is * G
* R -> I: pkR = rs * G
* dh = is * rs * G = rs * pkI = is * pkR
*/

#ifdef InitSec
rule InitSendPublicKey:
    let pkI = <e('C', DH_neutral, 'g'^~is),e('C', DH_neutral, 'g'^~is)> in
    [
    InitDoECDH($idI, $capI, $idR, $capR),
    Fr(~is)
    ]
    --[
        InitBeginECDH($idI, $capI, $idR, $capR, ~is, pkI)
    ]->
    [
    InitBeginECDH($idI, $capI, $idR, $capR, ~is, pkI),
    Out(pkI)
    ]

rule InitRecvPublicKey:
    [
    InitBeginECDH($idI, $capI, $idR, $capR, ~is, pkI),
    In(pkR)
    ]
    --[
        InitComputeECDH( $idI, $capI, $idR, $capR, pkI, pkR, ~is)
    ]->
    [
    InitComputeECDH( $idI, $capI, $idR, $capR, pkI, pkR, ~is)
    ]

rule InitDeriveNormalDHKey:
   let
       pkRx = e('C', DH_neutral, n)
       dhkey = e('C', r, n^~is) // In Bluetooth, only X is taken
   in
   [
       InitComputeECDH( $idI, $capI, $idR, $capR, <pkIx,pkIy>, <pkRx,pkRy>, ~is),
       In(r)
   ]
  --[
      ValidPt(pkRx,pkRy), Raised('C', DH_neutral, r, ~is),
      InitEndECDH($idI, $capI, $idR, $capR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      InitEndECDH($idI, $capI, $idR, $capR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef InitECDHUnpatched
rule InitDeriveInvalidDHKey:
   let
       pkRx = e(otx,osx,orx)
       pkRy = e(oty,osy,ory)
       dhkey = e(tx, rx, nx^~is) // In Bluetooth, only X is taken
   in
   [
       InitComputeECDH( $idI, $capI, $idR, $capR, <pkIx, pkIy>, <pkRx, pkRy>, ~is),
       In(<tx,rx,nx,ty,ry,ny>)
   ]
  --[
       InvalidPt(pkRx,pkRy), Raised(<tx,ty>, <osx,osy>, <rx,ry>, ~is),
       InitEndECDH($idI, $capI, $idR, $capR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
  ]->
   [
       InitEndECDH($idI, $capI, $idR, $capR, pkIx, pkRx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef RespSec
rule RespSendPublicKey:
    let
        pkR = <e('C', DH_neutral, 'g'^~rs),e('C', DH_neutral, 'g'^~rs)>
    in
    [
        RespDoECDH($idR, $capR, $idI, $capI),
        Fr(~rs),
        In(pkI)
    ]
    --[
        RespComputeECDH($idR, $capR, $idI, $capI, pkR, pkI, ~rs)
    ]->
    [
        RespComputeECDH($idR, $capR, $idI, $capI, pkR, pkI, ~rs),
        Out(pkR)
    ]

rule RespDeriveNormalDHKey:
   let
       pkIx = e('C', DH_neutral, n)
       dhkey = e('C', r, n^~rs) // In Bluetooth, only X is taken
   in
   [
       RespComputeECDH( $idR, $capR, $idI, $capI, <pkRx, pkRy>, <pkIx, pkIy>, ~rs),
       In(r)
   ]
   --[
      ValidPt(pkIx,pkIy), Raised('C', DH_neutral, r, ~rs),
      RespEndECDH($idR, $capR, $idI, $capI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      RespEndECDH($idR, $capR, $idI, $capI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

#ifdef RespECDHUnpatched
rule RespDeriveInvalidDHKey:
   let
       pkIx = e(otx,osx,orx)
       pkIy = e(oty,osy,ory)
       dhkey = e(tx, rx, nx^~rs) // In Bluetooth, only X is taken
   in
   [
       RespComputeECDH( $idR, $capR, $idI, $capI, <pkRx, pkRy>, <pkIx, pkIy>, ~rs),
       In(<tx,rx,nx,ty,ry,ny>)
   ]
  --[
      InvalidPt(pkIx,pkIy), Raised(<tx,ty>, <osx,osy>, <rx,ry>, ~rs),
      RespEndECDH($idR, $capR, $idI, $capI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]->
   [
      RespEndECDH($idR, $capR, $idI, $capI, pkRx, pkIx, dhkey) // Once DHKey is computed, only x-coordinate is used in the rest of the protocol
   ]
#endif

/*
* For the Secure Passkey Entry which requires it, we start the user interaction here.
* That is, we trigger the role to have the Passkey Entry user interaction
*/

#ifdef InitSecPE
rule InitTriggerSecPE:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh), // The Initiator has ended the ECDH exchange
    InitDoSecPE($idI, $capI, $idR, $capR) // The Initiator is doing a PE protocol
    ]
    --[]->
    [
    InitTriggerUserInteraction(),
    InitReadySecPE($idI, $capI, $idR, $capR, pkI, pkR, dh)
    ]
#endif

#ifdef RespSecPE
rule RespTriggerSecPE:
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh), // The Initiator has ended the ECDH exchange
    RespDoSecPE($idR, $capR, $idI, $capI) // The Initiator is doing a PE protocol
    ]
    --[]->
    [
    RespTriggerUserInteraction(),
    RespReadySecPE($idR, $capR, $idI, $capI, pkR, pkI, dh)
    ]
#endif

/*
* This implements the Secure JustWorks method
* Devices using this method do not require a user interaction.
* The protocol is the following :
* R -> I: f1(pkR, pkI, nr, '0')
* I -> R: ni
* R -> I: nr
*/

#ifdef RespSecJW
rule RespSecJWSendConfirm:
    let Cr = f1(pkR, pkI, ~nr, '0') in
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh),
    Fr(~nr)
    ]
    --[
        RespSecJWSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr)
    ]->
    [
    RespSecJWSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr),
    Out(Cr)
    ]

rule RespSecJWSendRandom:
    [
    RespSecJWSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr),
    In(ni)
    ]
    --[
        RespSecJWSendRandom($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
        RespSecJWDone($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
        RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, '0', '0')
    ]->
    [
    RespSecJWSendRandom($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
    RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, '0', '0'), // Responder ended step2, ra and rb = 0 in JW mode
    Out(~nr)
    ]
#endif

#ifdef InitSecJW
rule InitSecJWSendRandom:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh),
    Fr(~ni),
    In(Cr)
    ]
    --[
        InitSecJWSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, Cr)
    ]->
    [
    InitSecJWSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, Cr),
    Out(~ni)
    ]


rule InitSecJWRecvRandom:
    let computed_Cr = f1(pkR, pkI, nr, '0') in
    [
    InitSecJWSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, computed_Cr),
    In(nr)
    ]
    --[
        InitSecJWRecvRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
        InitSecJWDone($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
        InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, '0', '0')
    ]->
    [
    InitSecJWRecvRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
    InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, '0', '0') // Responder ended step2, ra and rb = 0 in JW mode
    ]
#endif

/*
* Implement the Secure Passkey Entry method
* The protocol is based on commitment rounds, using the passkey.
* The passkey is always 20 bits long (by the specification)
* notation b0(passkey) represents the first bit of the passkey, b1(passkey) is the second bit, ...
* Round 0:
* I -> R: f1(pkI, pkR, ni0, b0(passkey)
* R -> I: f1(pkR, pkI, nr0, b0(passkey)
* I -> R: ni0
* R -> I: nr0
* Round 1:
* I -> R: f1(pkI, pkR, ni1, b1(passkey)
* R -> I: f1(pkR, pkI, nr1, b1(passkey)
* I -> R: ni1
* R -> I: nr1
* ...
*
* Nonces are drawn at random for each round.
* In this model, we use a reduced version of the Passkey Entry protocol, which consists
* of only two rounds.
* The passkey is split in two using functions split1/1 and split2/1
*/

#ifdef InitSecPE
rule InitSecPESendConfirm1:
    let Ci = f1(pkI, pkR, ~ni, split1(passkey)) in
    [
    InitReadySecPE($idI, $capI, $idR, $capR, pkI, pkR, dh), // Initiator is ready to perform PE protocol
    InitUserProceed(passkey), // The passkey is provided to the Initiator
    Fr(~ni)
    ]
    --[]->
    [
    InitSecPESendConfirm1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci),
    LowEntropyf1(pkI, pkR, ~ni, split1(passkey)),
    Out(Ci)
    ]

rule InitSecPESendRandom1:
    [
    InitSecPESendConfirm1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci), 
    In(Cr)
    ]
    --[]->
    [
    InitSecPESendRandom1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci, Cr),
    Out(~ni)
    ]

rule InitSecPERecvRandom1:
    let computed_Cr = f1(pkR, pkI, nr, split1(passkey)) in
    [
    InitSecPESendRandom1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci, computed_Cr), 
    In(nr)
    ]
    --[
    ]->
    [
    InitSecPEEndPart1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey)
    ]

rule InitSecPESendConfirm2:
    let Ci = f1(pkI, pkR, ~ni, split2(passkey)) in
    [
    InitSecPEEndPart1($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey),
    Fr(~ni)
    ]
    --[]->
    [
    InitSecPESendConfirm2($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci),
    LowEntropyf1(pkI, pkR, ~ni, split2(passkey)),
    Out(Ci)
    ]

rule InitSecPESendRandom2:
    [
    InitSecPESendConfirm2($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci), 
    In(Cr)
    ]
    --[]->
    [
    InitSecPESendRandom2($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci, Cr),
    Out(~ni)
    ]

rule InitSecPERecvRandom2:
    let computed_Cr = f1(pkR, pkI, nr, split2(passkey)) in
    [
    InitSecPESendRandom2($idI, $capI, $idR, $capR, pkI, pkR, dh, passkey, ~ni, Ci, computed_Cr), 
    In(nr)
    ]
    --[
        InitSecPEDone($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, passkey),
        InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, passkey, passkey)
    ]->
    [
    InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, passkey, passkey)
    ]
#endif

#ifdef RespSecPE
rule RespSecPESendConfirm1:
    let Cr = f1(pkR, pkI, ~nr, split1(passkey)) in
    [
    RespReadySecPE($idR, $capR, $idI, $capI, pkR, pkI, dh), // Initiator is ready to perform PE protocol
    RespUserProceed(passkey), // The passkey is provided to the Initiator
    Fr(~nr),
    In(Ci)
    ]
    --[]->
    [
    RespSecPESendConfirm1($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey, ~nr, Cr, Ci),
    LowEntropyf1(pkR, pkI, ~nr, split1(passkey)),
    Out(Cr)
    ]

rule RespSecPESendRandom1:
    let computed_Ci = f1(pkI, pkR, ni, split1(passkey)) in
    [
    RespSecPESendConfirm1($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey, ~nr, Cr, computed_Ci),
    In(ni)
    ]
    --[
    ]->
    [
    RespSecPEEndPart1($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey),
    Out(~nr)
    ]

rule RespSecPESendConfirm2:
    let Cr = f1(pkR, pkI, ~nr, split2(passkey)) in
    [
    RespSecPEEndPart1($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey), // Initiator is ready to perform PE protocol
    Fr(~nr),
    In(Ci)
    ]
    --[]->
    [
    RespSecPESendConfirm2($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey, ~nr, Cr, Ci),
    LowEntropyf1(pkR, pkI, ~nr, split2(passkey)),
    Out(Cr)
    ]

rule RespSecPESendRandom2:
    let computed_Ci = f1(pkI, pkR, ni, split2(passkey)) in
    [
    RespSecPESendConfirm2($idR, $capR, $idI, $capI, pkR, pkI, dh, passkey, ~nr, Cr, computed_Ci), 
    In(ni)
    ]
    --[
        RespSecPEDone($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, passkey),
        RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, passkey, passkey)
    ]->
    [
    RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, passkey, passkey),
    Out(~nr)
    ]
#endif

#ifdef NoLowEntropySecure
#else
rule Oracle_f1:
    let verif_val = f1(pk1, pk2, n, s) in
    [
    LowEntropyf1(pk1, pk2, n, s),
    In(pk1),
    In(pk2),
    In(n),
    In(verif_val)
    ]
    --[
        AttackerRecoveredPasskey(s)
    ]->
    [
    Out(s)
    ]
#endif

#ifdef NoLowEntropyLegacy
#else
rule Oracle_pin:
    let 
        Kinit = e22(pin, in_rand)
        rand_i = Kinit XOR masked_rand_i
        rand_r = Kinit XOR masked_rand_r
        LK = e21(rand_i, idI) XOR e21(rand_r, idR)
        sres = e1_sres(LK, id_sres, au_rand)
    in
    [
    LowEntropy(pin),
    OracleLK(au_rand, sres),
    In(in_rand),
    In(masked_rand_i),
    In(masked_rand_r),
    In(au_rand),
    In(id_sres),
    In(idI),
    In(idR),
    In(sres)
    ]
    --[
        AttackerRecoveredPIN(pin)
    ]->
    [
    Out(pin)
    ]
#endif

/*
* Numeric Comparison method
* This protocol is similar to the Secure JustWorks protocol, but the user is
* then presented a code to verify that the Pairing was done correctly
* R -> I: f1(pkR, pkI, nr, '0')
* I -> R: ni
* R -> I: nr
*/


#ifdef RespSecNC
rule RespSecNCSendConfirm:
    let Cr = f1(pkR, pkI, ~nr, '0') in
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh),
    Fr(~nr)
    ]
    --[
        RespSecNCSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr)
    ]->
    [
    RespSecNCSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr),
    Out(Cr)
    ]

rule RespSecNCSendRandom:
    let code = g(pkI, pkR, ni, ~nr) in
    [
    RespSecNCSendConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, Cr),
    In(ni)
    ]
    --[
        RespSecNCSendRandom($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni)
    ]->
    [
    RespNCWaitConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
    RespWaitUserConfirm(code),
    RespTriggerUserInteraction(),
    Out(~nr)
    ]

rule RespSecNCDone:
    [
    RespNCWaitConfirm($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
    RespUserProceed(code)
    ]
    --[
        RespSecNCDone($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
        RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, '0', '0')
    ]->
    [
    RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, '0', '0') // Initiator ended step2, ra and rb = 0 in JW mode
    ]
#endif


#ifdef InitSecNC
rule InitSecNCSendRandom:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh),
    Fr(~ni),
    In(Cr)
    ]
    --[
        InitSecNCSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, Cr)
    ]->
    [
    InitSecNCSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, Cr),
    Out(~ni)
    ]

rule InitSecNCRecvRandom:
    let 
        computed_Cr = f1(pkR, pkI, nr, '0')
        code = g(pkI, pkR, ~ni, nr)
    in
    [
    InitSecNCSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, computed_Cr),
    In(nr)
    ]
    --[
        InitSecNCRecvRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr)
    ]->
    [
    InitNCWaitConfirm($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
    InitWaitUserConfirm(code),
    InitTriggerUserInteraction()
    ]

rule InitSecNCDone:
    [
    InitNCWaitConfirm($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
    InitUserProceed(code)
    ]
    --[
        InitSecNCDone($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr),
        InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, '0', '0')
    ]->
    [
    InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, '0', '0') // Initiator ended step2, ra and rb = 0 in JW mode
    ]
#endif

/*
* Out of Band Pairing method.
* The exact exchange will depend on the choice done for the OOB method.
* If OOBi is used, the device expects an input message
* If OOBo is used, the device sends a message
* If OOBio is used, the device sends a message and expects an input message
*
* Once the OOB exchange is done, both device exchange a nonce, starting from the Initiator:
* I -> R: ni
* R -> I: nr
*/

#ifdef InitSecOOBi
rule InitDoSecOOBi:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitDoSecOOBi($idI, $capI, $idR, $capR)
    ]
    --[
    ]->
    [
    InitWaitOOBInput(),
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh)
    ]
#endif

#ifdef InitSecOOBo
rule InitDoSecOOBo:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitDoSecOOBo($idI, $capI, $idR, $capR)
    ]
    --[
    ]->
    [
    InitWaitOOBOutput(),
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh)
    ]
#endif

#ifdef InitSecOOBio
rule InitDoSecOOBio:
    [
    InitEndECDH($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitDoSecOOBio($idI, $capI, $idR, $capR)
    ]
    --[
    ]->
    [
    InitWaitOOBInout(),
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh)
    ]
#endif

#ifdef RespSecOOBi
rule RespDoSecOOBi:
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespDoSecOOBi($idR, $capR, $idI, $capI)
    ]
    --[
    ]->
    [
    RespWaitOOBInput(),
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh)
    ]
#endif

#ifdef RespSecOOBo
rule RespDoSecOOBo:
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespDoSecOOBo($idR, $capR, $idI, $capI)
    ]
    --[
    ]->
    [
    RespWaitOOBOutput(),
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh)
    ]
#endif

#ifdef RespSecOOBio
rule RespDoSecOOBio:
    [
    RespEndECDH($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespDoSecOOBio($idR, $capR, $idI, $capI)
    ]
    --[
    ]->
    [
    RespWaitOOBInout(),
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh)
    ]
#endif

#ifdef InitSecOOB
rule InitSecOOBOut:
    let Ci = f1(pkI, pkI, ~ri, '0') in
    [
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitWaitOOBOutput(),
    Fr(~ri)
    ]
    --[
        InitSentOOB($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ri, Ci)
    ]->
    [
        InitDoneSecOOBexchange($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ri, '0'),
        InitOOBchannel(<$idI, ~ri, Ci>)
    ]

rule InitSecOOBin:
    let computed_Cr = f1(pkR, pkR, ~rr, '0') in
    [
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitWaitOOBInput(),
    RespOOBchannel(<$idR, ~rr, computed_Cr>)
    ]
    --[
    ]->
    [
    InitDoneSecOOBexchange($idI, $capI, $idR, $capR, pkI, pkR, dh, '0', ~rr)
    ]

rule InitSecOOBinout_out:
    let Ci = f1(pkI, pkI, ~ri, '0') in
    [
    InitReadySecOOB($idI, $capI, $idR, $capR, pkI, pkR, dh),
    InitWaitOOBInout(),
    Fr(~ri)
    ]
    --[
    ]->
    [
    InitDoneSecOOBinout_out($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ri),
    InitOOBchannel(<$idI, ~ri, Ci>)
    ]

rule InitSecOOBinout_in:
    let computed_Cr = f1(pkR, pkR, ~rr, '0') in
    [
    InitDoneSecOOBinout_out($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ri),
    RespOOBchannel(<$idR, ~rr, computed_Cr>)
    ]
    --[
    ]->
    [
    InitDoneSecOOBexchange($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ri, ~rr)
    ]

rule InitSecOOBSendRandom:
    [
    InitDoneSecOOBexchange($idI, $capI, $idR, $capR, pkI, pkR, dh, ri, rr),
    Fr(~ni)
    ]
    --[]->
    [
    InitSecOOBSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ri, rr, ~ni),
    Out(~ni)
    ]

rule InitSecOOBRecvRandom:
    [
    InitSecOOBSendRandom($idI, $capI, $idR, $capR, pkI, pkR, dh, ri, rr, ~ni),
    In(nr)
    ]
    --[
        InitSecOOBDone($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr),
        InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr)
    ]->
    [
    InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr)
    ]
#endif

#ifdef RespSecOOB
rule RespSecOOBOut:
    let Cr = f1(pkR, pkR, ~rr, '0') in
    [
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespWaitOOBOutput(),
    Fr(~rr)
    ]
    --[
        RespSentSecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh, ~rr, Cr)
    ]->
    [
        RespDoneSecOOBexchange($idR, $capR, $idI, $capI, pkR, pkI, dh, ~rr, '0'),
        RespOOBchannel(<$idR, ~rr, Cr>)
    ]

rule RespSecOOBin:
    let computed_Ci = f1(pkI, pkI, ~ri, '0') in
    [
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespWaitOOBInput(),
    InitOOBchannel(<$idI, ~ri, computed_Ci>)
    ]
    --[
    ]->
    [
    RespDoneSecOOBexchange($idR, $capR, $idI, $capI, pkR, pkI, dh, '0', ~ri)
    ]

rule RespSecOOBinout_out:
    let Cr = f1(pkR, pkR, ~rr, '0') in
    [
    RespReadySecOOB($idR, $capR, $idI, $capI, pkR, pkI, dh),
    RespWaitOOBInout(),
    Fr(~rr)
    ]
    --[
    ]->
    [
    RespDoneSecOOBinout_out($idR, $capR, $idI, $capI, pkR, pkI, dh, ~rr),
    RespOOBchannel(<$idR, ~rr, Cr>)
    ]

rule RespSecOOBinout_in:
    let computed_Ci = f1(pkI, pkI, ~ri, '0') in
    [
    RespDoneSecOOBinout_out($idR, $capR, $idI, $capI, pkR, pkI, dh, ~rr),
    InitOOBchannel(<$idI, ~ri, computed_Ci>)
    ]
    --[
    ]->
    [
    RespDoneSecOOBexchange($idR, $capR, $idI, $capI, pkR, pkI, dh, ~rr, ~ri)
    ]

rule RespSecOOBSendRandom:
    [
    RespDoneSecOOBexchange($idR, $capR, $idI, $capI, pkR, pkI, dh, rr, ri),
    Fr(~nr),
    In(ni)
    ]
    --[
        RespSecOOBDone($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, rr, ri),
        RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, rr, ri)
    ]->
    [
    RespSecOOBSendRandom($idR, $capR, $idI, $capI, pkR, pkI, dh, rr, ri, ~nr, ni),
    Out(~nr),
    RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, rr, ri)
    ]
#endif

/*
* DHKeyCheck, this is a key confirmation step
*/

#ifdef InitSec
rule InitDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ~ni, nr, 'btle', $idI, $idR)
        ei = f3(dh, ~ni, nr, rr, $capI, $idI, $idR) // Compute DHKeyCheck confirmation value
    in
    [
    InitEndedStep2($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr) // Initiator needs to be done with step2
    ]
    --[ InitDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr, ei) ]-> // Intermediate fact
    [
    InitSendDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr, ei), // Initiator has sent its dhkey check
    Out(ei) // Send the DHKey Check on the channel
    ]

rule InitDoneDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ~ni, nr, 'btle', $idI, $idR)
        computed_er = f3(dh, nr, ~ni, ri, $capR, $idR, $idI)
    in
    [
    InitSendDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr, ei),
    In(computed_er)
    ]
    --[
        InitDoneDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr, ri, rr, ei, computed_er)
    ]->
    [
    InitEndedDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr)
    ]
#endif

#ifdef RespSec
rule RespDHKeyCheck:
    let
        //mackey = f5_mackey(dh, ni, ~nr, 'btle', $idI, $idR)
        er = f3(dh, ~nr, ni, ri, $capR, $idR, $idI)
        computed_ei = f3(dh, ni, ~nr, rr, $capI, $idI, $idR)
    in
    [
    RespEndedStep2($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, rr, ri),
    In(computed_ei)
    ]
    --[
        RespDoneDHKeyCheck($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni, rr, ri, er, computed_ei)
    ]->
    [
    RespEndedDHKeyCheck($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
    Out(er)
    ]
#endif


/*
Technically, ni should be the nonce sent by the central and nr should be the nonce sent by the peripheral
idI should be the address of the central and idR the address of the peripheral.

Here, we assume Initiator == Central and Responder == Peripheral but that may not be always true

Also, the session key derivation and authentication is not performed here.
*/

#ifdef InitSec
rule InitSecSendmsg:
    let ltk = f2(dh, ~ni, nr, 'bredr', $idI, $idR) in
    [
    InitEndedDHKeyCheck($idI, $capI, $idR, $capR, pkI, pkR, dh, ~ni, nr)
    ]
    --[
        InitiatorFinishedSecPairing($idI, $capI, $idR, $capR, pkI, pkR, dh, ltk),
        InitiatorSecSentMessage(ltk, 'init')
    ]->
    [
    InitiatorFinishedSecPairing($idI, $capI, $idR, $capR, pkI, pkR, dh, ltk),
    Out(senc('init',ltk))
    ]
#endif

#ifdef RespSec
rule RespSecSendmsg:
    let ltk = f2(dh, ni, ~nr, 'bredr', $idI, $idR) in
    [
    RespEndedDHKeyCheck($idR, $capR, $idI, $capI, pkR, pkI, dh, ~nr, ni),
    In(senc('init', ltk)) 
    ]
    --[
        ResponderFinishedSecPairing($idR, $capR, $idI, $capI, pkR, pkI, dh, ltk),
        ResponderSentMessage(ltk, 'resp')
    ]->
    [
    ResponderFinishedSecPairing($idR, $capR, $idI, $capI, pkR, pkI, dh, ltk),
    Out(senc('resp',ltk))
    ]
#endif

/* User interactions */
/* This is used to represent user interactions in Bluetooth
Devices can have an output, input or input/output capability.
There are four facts that are used to represent interactions:
- InitUserWaitInput(): Initiator waits passkey input from user
- RespUserWaitInput(): Responder waits passkey input from user
- InitUserWaitConfirm(passkey): Initiator waits continuation of the protocol, it chooses passkey
- RespUserWaitConfirm(passkey): Responder waits continuation of the protocol, it chooses passkey
- InitUserWaitInout(passkey): Initiator waits continuation of the protocol
- RespUserWaitInout(passkey): Responder waits the continuation of the protocol

We note that not both devices choose the passkey, in practice only one does.
However, the choice depends on the capabilities of the other device.
This is why when two devices have triggered UserWaitInout(passkey), only one passkey is propagated in the following
rules, to model the choice that was done at the beginning of the protocol.

The possible combinations are:
InitUserWaitInput - RespUserWaitInput -> Valid interaction in PE, user selects a passkey and inputs it in both
InitUserWaitInput - RespUserWaitConfirm -> Valid interaction in PE, user copies the responder's passkey into initiator
InitUserWaitConfirm - RespUserWaitInput -> Valid interaction in PE, user copies the initiator's passkey into responder
InitUserWaitConfirm - RespUserWaitConfirm -> Valid interaction in NC, user verifies that both code match
                                          -> May also occur in PEo/PEio - PEo/PEio, in which case it is valid
*/

#ifdef InputInput
rule UserInputInitInputResp:
    [Fr(~passkey),
    InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(~passkey),RespUserProceed(~passkey)]
#endif

#ifdef InputOutput
rule UserInputInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserConfirm(passkey)]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef InputInout
rule UserInputInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserInput(),
    RespTriggerUserInteraction(),RespWaitUserInout(passkey)]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef OutputInput
rule UserConfirmInitInputResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(passkey),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef OutputInout
rule UserConfirmInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserInout(passkeyr)]
    --[]->
    [InitUserProceed(passkeyi),RespUserProceed(passkeyi)]
#endif

#ifdef InoutInput
rule UserInoutInitInputResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkey),
    RespTriggerUserInteraction(),RespWaitUserInput()]
    --[]->
    [InitUserProceed(passkey),RespUserProceed(passkey)]
#endif

#ifdef InoutOutput
rule UserInoutInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserConfirm(passkeyr)]
    --[]->
    [InitUserProceed(passkeyr),RespUserProceed(passkeyr)]
#endif

#ifdef InoutInout
rule UserInoutInitInoutResp:
    [InitTriggerUserInteraction(),InitWaitUserInout(passkeyi),
    RespTriggerUserInteraction(),RespWaitUserInout(passkeyr)]
    --[]->
    [InitUserProceed(passkeyi),RespUserProceed(passkeyi)]
#endif

#ifdef OutputOutput
// This represents Numeric Comparison protocol
rule UserConfirmInitConfirmResp:
    [InitTriggerUserInteraction(),InitWaitUserConfirm(vi),
    RespTriggerUserInteraction(),RespWaitUserConfirm(vi)]
    --[]->
    [InitUserProceed(vi),RespUserProceed(vi)]
#endif


/* Those two restrictions limit to one honest initiator and one
honest responder. This helps having a finished analysis */
restriction InitOnlyOncePairing:
"All #i #j. InitOnlyOncePairing() @i & InitOnlyOncePairing() @j ==> #i = #j"

restriction RespOnlyOncePairing:
"All #i #j. RespOnlyOncePairing() @i & RespOnlyOncePairing() @j ==> #i = #j"

restriction OnlyOneAuthPath:
"All #i #j. AuthOnlyOneBegin() @i & AuthOnlyOneBegin() @j ==> #i = #j"

#ifdef InitLeg
restriction InitLegPINOnlyOnce:
"All #i #j. InitLegPINOnlyOnce() @i & InitLegPINOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespLeg
restriction RespLegPINOnlyOnce:
"All #i #j. RespLegPINOnlyOnce() @i & RespLegPINOnlyOnce() @j ==> #i = #j"
#endif

#ifdef InitSecPE
restriction InitSecPEOnlyOnce:
"All #i #j. InitSecPEOnlyOnce() @i & InitSecPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespSecPE
restriction RespSecPEOnlyOnce:
"All #i #j. RespSecPEOnlyOnce() @i & RespSecPEOnlyOnce() @j ==> #i = #j"
#endif

#ifdef InitSecOOB
restriction InitSecOOBOnlyOnce:
"All #i #j. InitSecOOBOnlyOnce() @i & InitSecOOBOnlyOnce() @j ==> #i = #j"
#endif

#ifdef RespSecOOB
restriction RespSecOOBOnlyOnce:
"All #i #j. RespSecOOBOnlyOnce() @i & RespSecOOBOnlyOnce() @j ==> #i = #j"
#endif

// For ECDH model
restriction DHConsistency:
	"All  t s r1 r2 y #i #j .
	Raised(t,s,r1,y) @ i & Raised(t,s,r2,y) @j
	==> r1 = r2"

restriction DHIdentity:
	"All  t r y #i .
	Raised(t,DH_neutral,r,y) @ i ==> r = DH_neutral"

restriction ValidPt:
  "âˆ€ x y #i.
    (ValidPt(x,y) @ #i) â‡’ (x = y)"

restriction InvalidPt:
  "âˆ€ x #i.
    (InvalidPt(x,x) @ #i) â‡’ F"


/*****************************************/
/* Lemmas about LegPINi-LegPINi exchange */
/*****************************************/

#ifdef LegPINiLegPINi
lemma legPINi_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINi_legPINi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINi-LegPINi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPINi-LegPINo exchange */
/*****************************************/

#ifdef LegPINiLegPINo
lemma legPINi_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINi_legPINo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINi-LegPINo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPINi-LegPINio exchange */
/******************************************/

#ifdef LegPINiLegPINio
lemma legPINi_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINi_legPINio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINi_legPINio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINi_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINi-LegPINio exchange */
/**********************************************/

/*****************************************/
/* Lemmas about LegPINo-LegPINi exchange */
/*****************************************/

#ifdef LegPINoLegPINi
lemma legPINo_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINo_legPINi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINo-LegPINi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPINo-LegPINo exchange */
/*****************************************/

#ifdef LegPINoLegPINo
lemma legPINo_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINo_legPINo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINo-LegPINo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPINo-LegPINio exchange */
/******************************************/

#ifdef LegPINoLegPINio
lemma legPINo_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINo_legPINio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINo_legPINio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINo_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINo-LegPINio exchange */
/**********************************************/

/******************************************/
/* Lemmas about LegPINio-LegPINi exchange */
/******************************************/

#ifdef LegPINioLegPINi
lemma legPINio_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINio_legPINi_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINi_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINi_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINi_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINio-LegPINi exchange */
/**********************************************/

/******************************************/
/* Lemmas about LegPINio-LegPINo exchange */
/******************************************/

#ifdef LegPINioLegPINo
lemma legPINio_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINio_legPINo_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINo_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINo_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINo_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINio-LegPINo exchange */
/**********************************************/

/*******************************************/
/* Lemmas about LegPINio-LegPINio exchange */
/*******************************************/

#ifdef LegPINioLegPINio
lemma legPINio_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2
    )
"

lemma legPINio_legPINio_auth_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            InitRecvMsg(idI, capI1, idR, capR1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINio_auth_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI1 capR1 lk aco m #k1 .
            RespRecvSendMsg(idR, capR1, idI, capI1, lk, aco, m) @k1 ==>
            (Ex capI2 capR2 #k2 .
                InitiatorFinishedLegPairing(idI, capI2, idR, capR2, lk, aco) @k2
            )
        )
"

lemma legPINio_legPINio_weaksecret_init:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINio_weaksecret_resp:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
        (All idI idR capI capR lk aco #k1 .
            ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @k1 ==>
            not (Ex #k2 . K(lk) @k2 )
        )
"

lemma legPINio_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk1 lk2 aco1 aco2 #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk1, aco1) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk2, aco2) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk1) @k1 & K(lk2) @k2
        )
    )
"

#endif

/***********************************************/
/* End lemmas about LegPINio-LegPINio exchange */
/***********************************************/

/*************************************/
/* Lemmas about SecJW-SecJW exchange */
/*************************************/

#ifdef SecJWSecJW
lemma secJW_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecJW-SecJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecJW-SecPEi exchange */
/**************************************/

#ifdef SecJWSecPEi
lemma secJW_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecJW-SecPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecJW-SecPEo exchange */
/**************************************/

#ifdef SecJWSecPEo
lemma secJW_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecJW-SecPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecJW-SecPEio exchange */
/***************************************/

#ifdef SecJWSecPEio
lemma secJW_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecPEio exchange */
/*******************************************/

/*************************************/
/* Lemmas about SecJW-SecNC exchange */
/*************************************/

#ifdef SecJWSecNC
lemma secJW_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecJW-SecNC exchange */
/*****************************************/

/***************************************/
/* Lemmas about SecJW-SecOOBi exchange */
/***************************************/

#ifdef SecJWSecOOBi
lemma secJW_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecOOBi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecJW-SecOOBo exchange */
/***************************************/

#ifdef SecJWSecOOBo
lemma secJW_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-SecOOBo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecJW-SecOOBio exchange */
/****************************************/

#ifdef SecJWSecOOBio
lemma secJW_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secJW_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secJW_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secJW_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secJW_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecJW-SecOOBio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEi-SecJW exchange */
/**************************************/

#ifdef SecPEiSecJW
lemma secPEi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEi-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEi-SecPEi exchange */
/***************************************/

#ifdef SecPEiSecPEi
lemma secPEi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEi-SecPEo exchange */
/***************************************/

#ifdef SecPEiSecPEo
lemma secPEi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEi-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEi-SecPEio exchange */
/****************************************/

#ifdef SecPEiSecPEio
lemma secPEi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEi-SecNC exchange */
/**************************************/

#ifdef SecPEiSecNC
lemma secPEi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEi-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about SecPEi-SecOOBi exchange */
/****************************************/

#ifdef SecPEiSecOOBi
lemma secPEi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEi-SecOOBo exchange */
/****************************************/

#ifdef SecPEiSecOOBo
lemma secPEi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEi-SecOOBio exchange */
/*****************************************/

#ifdef SecPEiSecOOBio
lemma secPEi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEi_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEi_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEi_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEi_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEi-SecOOBio exchange */
/*********************************************/

/**************************************/
/* Lemmas about SecPEo-SecJW exchange */
/**************************************/

#ifdef SecPEoSecJW
lemma secPEo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEo-SecJW exchange */
/******************************************/

/***************************************/
/* Lemmas about SecPEo-SecPEi exchange */
/***************************************/

#ifdef SecPEoSecPEi
lemma secPEo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-SecPEi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecPEo-SecPEo exchange */
/***************************************/

#ifdef SecPEoSecPEo
lemma secPEo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEo-SecPEo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEo-SecPEio exchange */
/****************************************/

#ifdef SecPEoSecPEio
lemma secPEo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecPEio exchange */
/********************************************/

/**************************************/
/* Lemmas about SecPEo-SecNC exchange */
/**************************************/

#ifdef SecPEoSecNC
lemma secPEo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecPEo-SecNC exchange */
/******************************************/

/****************************************/
/* Lemmas about SecPEo-SecOOBi exchange */
/****************************************/

#ifdef SecPEoSecOOBi
lemma secPEo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecOOBi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEo-SecOOBo exchange */
/****************************************/

#ifdef SecPEoSecOOBo
lemma secPEo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-SecOOBo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEo-SecOOBio exchange */
/*****************************************/

#ifdef SecPEoSecOOBio
lemma secPEo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEo_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEo_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEo_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEo_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEo-SecOOBio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecPEio-SecJW exchange */
/***************************************/

#ifdef SecPEioSecJW
lemma secPEio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEio-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecPEio-SecPEi exchange */
/****************************************/

#ifdef SecPEioSecPEi
lemma secPEio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEio-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEio-SecPEo exchange */
/****************************************/

#ifdef SecPEioSecPEo
lemma secPEio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEio-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEio-SecPEio exchange */
/*****************************************/

#ifdef SecPEioSecPEio
lemma secPEio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecPEio-SecNC exchange */
/***************************************/

#ifdef SecPEioSecNC
lemma secPEio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecPEio-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecPEio-SecOOBi exchange */
/*****************************************/

#ifdef SecPEioSecOOBi
lemma secPEio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecPEio-SecOOBo exchange */
/*****************************************/

#ifdef SecPEioSecOOBo
lemma secPEio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecPEio-SecOOBio exchange */
/******************************************/

#ifdef SecPEioSecOOBio
lemma secPEio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secPEio_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secPEio_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secPEio_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secPEio_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecPEio-SecOOBio exchange */
/**********************************************/

/*************************************/
/* Lemmas about SecNC-SecJW exchange */
/*************************************/

#ifdef SecNCSecJW
lemma secNC_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecNC-SecJW exchange */
/*****************************************/

/**************************************/
/* Lemmas about SecNC-SecPEi exchange */
/**************************************/

#ifdef SecNCSecPEi
lemma secNC_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecNC-SecPEi exchange */
/******************************************/

/**************************************/
/* Lemmas about SecNC-SecPEo exchange */
/**************************************/

#ifdef SecNCSecPEo
lemma secNC_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/******************************************/
/* End lemmas about SecNC-SecPEo exchange */
/******************************************/

/***************************************/
/* Lemmas about SecNC-SecPEio exchange */
/***************************************/

#ifdef SecNCSecPEio
lemma secNC_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecPEio exchange */
/*******************************************/

/*************************************/
/* Lemmas about SecNC-SecNC exchange */
/*************************************/

#ifdef SecNCSecNC
lemma secNC_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*****************************************/
/* End lemmas about SecNC-SecNC exchange */
/*****************************************/

/***************************************/
/* Lemmas about SecNC-SecOOBi exchange */
/***************************************/

#ifdef SecNCSecOOBi
lemma secNC_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecOOBi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecNC-SecOOBo exchange */
/***************************************/

#ifdef SecNCSecOOBo
lemma secNC_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-SecOOBo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecNC-SecOOBio exchange */
/****************************************/

#ifdef SecNCSecOOBio
lemma secNC_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secNC_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secNC_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secNC_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secNC_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecNC-SecOOBio exchange */
/********************************************/

/***************************************/
/* Lemmas about SecOOBi-SecJW exchange */
/***************************************/

#ifdef SecOOBiSecJW
lemma secOOBi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBi-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBi-SecPEi exchange */
/****************************************/

#ifdef SecOOBiSecPEi
lemma secOOBi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBi-SecPEo exchange */
/****************************************/

#ifdef SecOOBiSecPEo
lemma secOOBi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBi-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecPEio exchange */
/*****************************************/

#ifdef SecOOBiSecPEio
lemma secOOBi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecOOBi-SecNC exchange */
/***************************************/

#ifdef SecOOBiSecNC
lemma secOOBi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBi-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecOOBi exchange */
/*****************************************/

#ifdef SecOOBiSecOOBi
lemma secOOBi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBi-SecOOBo exchange */
/*****************************************/

#ifdef SecOOBiSecOOBo
lemma secOOBi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBi-SecOOBio exchange */
/******************************************/

#ifdef SecOOBiSecOOBio
lemma secOOBi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBi_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBi_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBi_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBi_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBi-SecOOBio exchange */
/**********************************************/

/***************************************/
/* Lemmas about SecOOBo-SecJW exchange */
/***************************************/

#ifdef SecOOBoSecJW
lemma secOOBo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBo-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecOOBo-SecPEi exchange */
/****************************************/

#ifdef SecOOBoSecPEi
lemma secOOBo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecOOBo-SecPEo exchange */
/****************************************/

#ifdef SecOOBoSecPEo
lemma secOOBo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBo-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecPEio exchange */
/*****************************************/

#ifdef SecOOBoSecPEio
lemma secOOBo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about SecOOBo-SecNC exchange */
/***************************************/

#ifdef SecOOBoSecNC
lemma secOOBo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecOOBo-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecOOBi exchange */
/*****************************************/

#ifdef SecOOBoSecOOBi
lemma secOOBo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBo-SecOOBo exchange */
/*****************************************/

#ifdef SecOOBoSecOOBo
lemma secOOBo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBo-SecOOBio exchange */
/******************************************/

#ifdef SecOOBoSecOOBio
lemma secOOBo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBo_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBo_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBo_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBo_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBo-SecOOBio exchange */
/**********************************************/

/****************************************/
/* Lemmas about SecOOBio-SecJW exchange */
/****************************************/

#ifdef SecOOBioSecJW
lemma secOOBio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secJW_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secJW_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secJW_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secJW_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBio-SecJW exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBio-SecPEi exchange */
/*****************************************/

#ifdef SecOOBioSecPEi
lemma secOOBio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-SecPEi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBio-SecPEo exchange */
/*****************************************/

#ifdef SecOOBioSecPEo
lemma secOOBio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBio-SecPEo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecPEio exchange */
/******************************************/

#ifdef SecOOBioSecPEio
lemma secOOBio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secPEio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secPEio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secPEio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecPEio exchange */
/**********************************************/

/****************************************/
/* Lemmas about SecOOBio-SecNC exchange */
/****************************************/

#ifdef SecOOBioSecNC
lemma secOOBio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secNC_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secNC_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secNC_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secNC_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecOOBio-SecNC exchange */
/********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecOOBi exchange */
/******************************************/

#ifdef SecOOBioSecOOBi
lemma secOOBio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBi_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBi_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBi_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBi_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecOOBi exchange */
/**********************************************/

/******************************************/
/* Lemmas about SecOOBio-SecOOBo exchange */
/******************************************/

#ifdef SecOOBioSecOOBo
lemma secOOBio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBo_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBo_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBo_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBo_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-SecOOBo exchange */
/**********************************************/

/*******************************************/
/* Lemmas about SecOOBio-SecOOBio exchange */
/*******************************************/

#ifdef SecOOBioSecOOBio
lemma secOOBio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2
    )
"

lemma secOOBio_secOOBio_auth_init:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            (Ex ni nr ri rr ei er #k2 .
                RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nr, ni, rr, ri, er, ei) @k2
            )
        )
"

lemma secOOBio_secOOBio_auth_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            (Ex #k2 .
                InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k2
            )
        )
"

lemma secOOBio_secOOBio_weaksecret_init:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBio_weaksecret_resp:
"
    All #i1 #i2 .
        InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
        (All idI idR capI capR pkI pkR dh ltk #k1 .
            ResponderFinishedSecPairing(idR, capR, idI, capI, pkR, pkI, dh, ltk) @k1 ==>
            not (Ex #k2 . K(ltk) @k2)
        )
"

lemma secOOBio_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 pkI1 pkR1 dh1 ltk1 idI2 idR2 capI2 capR2 pkI2 pkR2 dh2 ltk2 #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI1, pkR1, dh1, ltk1) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR2, pkI2, dh2, ltk2) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk1) @k1 & K(ltk2) @k2
        )
    )
"

#endif

/***********************************************/
/* End lemmas about SecOOBio-SecOOBio exchange */
/***********************************************/

/***************************************/
/* Lemmas about LegPINi-SecJW exchange */
/***************************************/

#ifdef LegPINiSecJW
lemma legPINi_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secJW_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secJW_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secJW_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secJW_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPINi-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPINi-SecPEi exchange */
/****************************************/

#ifdef LegPINiSecPEi
lemma legPINi_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secPEi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secPEi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secPEi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secPEi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINi-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPINi-SecPEo exchange */
/****************************************/

#ifdef LegPINiSecPEo
lemma legPINi_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secPEo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secPEo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secPEo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secPEo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINi-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPINi-SecPEio exchange */
/*****************************************/

#ifdef LegPINiSecPEio
lemma legPINi_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secPEio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secPEio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secPEio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secPEio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINi-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about LegPINi-SecNC exchange */
/***************************************/

#ifdef LegPINiSecNC
lemma legPINi_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secNC_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secNC_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secNC_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secNC_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPINi-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about LegPINi-SecOOBi exchange */
/*****************************************/

#ifdef LegPINiSecOOBi
lemma legPINi_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secOOBi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secOOBi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secOOBi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secOOBi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINi-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPINi-SecOOBo exchange */
/*****************************************/

#ifdef LegPINiSecOOBo
lemma legPINi_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secOOBo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secOOBo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secOOBo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secOOBo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINi-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPINi-SecOOBio exchange */
/******************************************/

#ifdef LegPINiSecOOBio
lemma legPINi_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINi_secOOBio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINi_secOOBio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINi_secOOBio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINi_secOOBio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINi_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINi()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINi-SecOOBio exchange */
/**********************************************/

/***************************************/
/* Lemmas about LegPINo-SecJW exchange */
/***************************************/

#ifdef LegPINoSecJW
lemma legPINo_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secJW_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secJW_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secJW_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secJW_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPINo-SecJW exchange */
/*******************************************/

/****************************************/
/* Lemmas about LegPINo-SecPEi exchange */
/****************************************/

#ifdef LegPINoSecPEi
lemma legPINo_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secPEi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secPEi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secPEi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secPEi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINo-SecPEi exchange */
/********************************************/

/****************************************/
/* Lemmas about LegPINo-SecPEo exchange */
/****************************************/

#ifdef LegPINoSecPEo
lemma legPINo_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secPEo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secPEo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secPEo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secPEo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINo-SecPEo exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPINo-SecPEio exchange */
/*****************************************/

#ifdef LegPINoSecPEio
lemma legPINo_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secPEio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secPEio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secPEio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secPEio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINo-SecPEio exchange */
/*********************************************/

/***************************************/
/* Lemmas about LegPINo-SecNC exchange */
/***************************************/

#ifdef LegPINoSecNC
lemma legPINo_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secNC_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secNC_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secNC_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secNC_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about LegPINo-SecNC exchange */
/*******************************************/

/*****************************************/
/* Lemmas about LegPINo-SecOOBi exchange */
/*****************************************/

#ifdef LegPINoSecOOBi
lemma legPINo_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secOOBi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secOOBi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secOOBi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secOOBi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINo-SecOOBi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPINo-SecOOBo exchange */
/*****************************************/

#ifdef LegPINoSecOOBo
lemma legPINo_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secOOBo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secOOBo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secOOBo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secOOBo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINo-SecOOBo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPINo-SecOOBio exchange */
/******************************************/

#ifdef LegPINoSecOOBio
lemma legPINo_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINo_secOOBio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINo_secOOBio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINo_secOOBio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINo_secOOBio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINo_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINo()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINo-SecOOBio exchange */
/**********************************************/

/****************************************/
/* Lemmas about LegPINio-SecJW exchange */
/****************************************/

#ifdef LegPINioSecJW
lemma legPINio_secJW_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secJW_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secJW_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secJW_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secJW_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secJW_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecJW()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINio-SecJW exchange */
/********************************************/

/*****************************************/
/* Lemmas about LegPINio-SecPEi exchange */
/*****************************************/

#ifdef LegPINioSecPEi
lemma legPINio_secPEi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secPEi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secPEi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secPEi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secPEi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secPEi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINio-SecPEi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about LegPINio-SecPEo exchange */
/*****************************************/

#ifdef LegPINioSecPEo
lemma legPINio_secPEo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secPEo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secPEo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secPEo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secPEo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secPEo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about LegPINio-SecPEo exchange */
/*********************************************/

/******************************************/
/* Lemmas about LegPINio-SecPEio exchange */
/******************************************/

#ifdef LegPINioSecPEio
lemma legPINio_secPEio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secPEio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secPEio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secPEio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secPEio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secPEio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecPEio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINio-SecPEio exchange */
/**********************************************/

/****************************************/
/* Lemmas about LegPINio-SecNC exchange */
/****************************************/

#ifdef LegPINioSecNC
lemma legPINio_secNC_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secNC_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secNC_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secNC_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secNC_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secNC_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecNC()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about LegPINio-SecNC exchange */
/********************************************/

/******************************************/
/* Lemmas about LegPINio-SecOOBi exchange */
/******************************************/

#ifdef LegPINioSecOOBi
lemma legPINio_secOOBi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secOOBi_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secOOBi_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secOOBi_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secOOBi_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secOOBi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINio-SecOOBi exchange */
/**********************************************/

/******************************************/
/* Lemmas about LegPINio-SecOOBo exchange */
/******************************************/

#ifdef LegPINioSecOOBo
lemma legPINio_secOOBo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secOOBo_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secOOBo_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secOOBo_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secOOBo_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secOOBo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about LegPINio-SecOOBo exchange */
/**********************************************/

/*******************************************/
/* Lemmas about LegPINio-SecOOBio exchange */
/*******************************************/

#ifdef LegPINioSecOOBio
lemma legPINio_secOOBio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2
    )
"

lemma legPINio_secOOBio_auth_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        (Ex pkI pkR dh nsi nsr ri rr ei er #k .
            RespDoneDHKeyCheck(idR, capR, idI, capI, pkR, pkI, dh, nsr, nsi, rr, ri, er, ei) @k
        )
"

lemma legPINio_secOOBio_auth_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        (Ex lk aco #k .
            InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @k
        )
"

lemma legPINio_secOOBio_weaksecret_init:
"
    All idI idR capI capR lk aco #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    InitiatorFinishedLegPairing(idI, capI, idR, capR, lk, aco) @j ==>
        not (Ex #k . K(lk) @k )
"

lemma legPINio_secOOBio_weaksecret_resp:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j.
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 &
    ResponderFinishedSecPairing(idR, capR, idI, capI, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k . K(ltk) @k )
"

lemma legPINio_secOOBio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoLegPINio()[+] @i1 & RespWillDoSecOOBio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedLegPairing(idI1, capI1, idR1, capR1, lk, aco) @j1 &
        ResponderFinishedSecPairing(idR2, capR2, idI2, capI2, pkR, pkI, dh, ltk) @j2 ==>
        not (Ex #k1 #k2 .
            K(lk) @k1 & K(ltk) @k2
        )
    )
"

#endif

/***********************************************/
/* End lemmas about LegPINio-SecOOBio exchange */
/***********************************************/

/***************************************/
/* Lemmas about SecJW-LegPINi exchange */
/***************************************/

#ifdef SecJWLegPINi
lemma secJW_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secJW_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secJW_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secJW_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-LegPINi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecJW-LegPINo exchange */
/***************************************/

#ifdef SecJWLegPINo
lemma secJW_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secJW_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secJW_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secJW_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecJW-LegPINo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecJW-LegPINio exchange */
/****************************************/

#ifdef SecJWLegPINio
lemma secJW_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secJW_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secJW_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secJW_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secJW_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secJW_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecJW()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecJW-LegPINio exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEi-LegPINi exchange */
/****************************************/

#ifdef SecPEiLegPINi
lemma secPEi_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEi_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEi_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEi_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-LegPINi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEi-LegPINo exchange */
/****************************************/

#ifdef SecPEiLegPINo
lemma secPEi_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEi_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEi_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEi_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEi-LegPINo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEi-LegPINio exchange */
/*****************************************/

#ifdef SecPEiLegPINio
lemma secPEi_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEi_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEi_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEi_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEi_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEi_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEi-LegPINio exchange */
/*********************************************/

/****************************************/
/* Lemmas about SecPEo-LegPINi exchange */
/****************************************/

#ifdef SecPEoLegPINi
lemma secPEo_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEo_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEo_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEo_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-LegPINi exchange */
/********************************************/

/****************************************/
/* Lemmas about SecPEo-LegPINo exchange */
/****************************************/

#ifdef SecPEoLegPINo
lemma secPEo_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEo_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEo_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEo_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecPEo-LegPINo exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecPEo-LegPINio exchange */
/*****************************************/

#ifdef SecPEoLegPINio
lemma secPEo_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEo_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEo_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEo_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEo_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEo_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEo-LegPINio exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecPEio-LegPINi exchange */
/*****************************************/

#ifdef SecPEioLegPINi
lemma secPEio_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEio_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEio_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEio_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-LegPINi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecPEio-LegPINo exchange */
/*****************************************/

#ifdef SecPEioLegPINo
lemma secPEio_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEio_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEio_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEio_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecPEio-LegPINo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecPEio-LegPINio exchange */
/******************************************/

#ifdef SecPEioLegPINio
lemma secPEio_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secPEio_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secPEio_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secPEio_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secPEio_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secPEio_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecPEio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecPEio-LegPINio exchange */
/**********************************************/

/***************************************/
/* Lemmas about SecNC-LegPINi exchange */
/***************************************/

#ifdef SecNCLegPINi
lemma secNC_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secNC_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secNC_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secNC_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-LegPINi exchange */
/*******************************************/

/***************************************/
/* Lemmas about SecNC-LegPINo exchange */
/***************************************/

#ifdef SecNCLegPINo
lemma secNC_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secNC_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secNC_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secNC_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*******************************************/
/* End lemmas about SecNC-LegPINo exchange */
/*******************************************/

/****************************************/
/* Lemmas about SecNC-LegPINio exchange */
/****************************************/

#ifdef SecNCLegPINio
lemma secNC_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secNC_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secNC_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secNC_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secNC_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secNC_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecNC()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/********************************************/
/* End lemmas about SecNC-LegPINio exchange */
/********************************************/

/*****************************************/
/* Lemmas about SecOOBi-LegPINi exchange */
/*****************************************/

#ifdef SecOOBiLegPINi
lemma secOOBi_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBi_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBi_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBi_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-LegPINi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBi-LegPINo exchange */
/*****************************************/

#ifdef SecOOBiLegPINo
lemma secOOBi_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBi_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBi_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBi_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBi-LegPINo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBi-LegPINio exchange */
/******************************************/

#ifdef SecOOBiLegPINio
lemma secOOBi_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBi_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBi_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBi_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBi_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBi_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBi()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBi-LegPINio exchange */
/**********************************************/

/*****************************************/
/* Lemmas about SecOOBo-LegPINi exchange */
/*****************************************/

#ifdef SecOOBoLegPINi
lemma secOOBo_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBo_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBo_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBo_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-LegPINi exchange */
/*********************************************/

/*****************************************/
/* Lemmas about SecOOBo-LegPINo exchange */
/*****************************************/

#ifdef SecOOBoLegPINo
lemma secOOBo_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBo_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBo_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBo_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/*********************************************/
/* End lemmas about SecOOBo-LegPINo exchange */
/*********************************************/

/******************************************/
/* Lemmas about SecOOBo-LegPINio exchange */
/******************************************/

#ifdef SecOOBoLegPINio
lemma secOOBo_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBo_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBo_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBo_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBo_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBo_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBo()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBo-LegPINio exchange */
/**********************************************/

/******************************************/
/* Lemmas about SecOOBio-LegPINi exchange */
/******************************************/

#ifdef SecOOBioLegPINi
lemma secOOBio_legPINi_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBio_legPINi_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBio_legPINi_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPINi_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPINi_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBio_legPINi_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINi()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-LegPINi exchange */
/**********************************************/

/******************************************/
/* Lemmas about SecOOBio-LegPINo exchange */
/******************************************/

#ifdef SecOOBioLegPINo
lemma secOOBio_legPINo_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBio_legPINo_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBio_legPINo_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPINo_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPINo_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBio_legPINo_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINo()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif

/**********************************************/
/* End lemmas about SecOOBio-LegPINo exchange */
/**********************************************/

/*******************************************/
/* Lemmas about SecOOBio-LegPINio exchange */
/*******************************************/

#ifdef SecOOBioLegPINio
lemma secOOBio_legPINio_functional: exists-trace
"
    Ex #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    (Ex idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2
    )
"

lemma secOOBio_legPINio_auth_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        (Ex capI2 capR2 lk aco #k.
            ResponderFinishedLegPairing(idR, capR2, idI, capI2, lk, aco) @k
        )
"

lemma secOOBio_legPINio_auth_resp:
"
    All idI idR capI1 capR1 lk aco #i1 #i2 #j.
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR1, idI, capI1, lk, aco) @j ==>
        (Ex capI2 capR2 pkI pkR dh nsi nsr ri rr ei #k .
            InitDHKeyCheck(idI, capI2, idR, capR2, pkI, pkR, dh, nsi, nsr, ri, rr, ei) @k
        )
"

lemma secOOBio_legPINio_weaksecret_init:
"
    All idI idR capI capR pkI pkR dh ltk #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    InitiatorFinishedSecPairing(idI, capI, idR, capR, pkI, pkR, dh, ltk) @j ==>
        not (Ex #k. K(ltk) @k )
"

lemma secOOBio_legPINio_weaksecret_resp:
"
    All idI idR capI capR lk aco #i1 #i2 #j .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 &
    ResponderFinishedLegPairing(idR, capR, idI, capI, lk, aco) @j ==>
        not (Ex #k. K(lk) @k )
"

lemma secOOBio_legPINio_double_impersonation:
"
    All #i1 #i2 .
    InitWillDoSecOOBio()[+] @i1 & RespWillDoLegPINio()[+] @i2 ==>
    (All idI1 idR1 capI1 capR1 idI2 idR2 capI2 capR2 lk aco pkI pkR dh ltk #j1 #j2 .
        InitiatorFinishedSecPairing(idI1, capI1, idR1, capR1, pkI, pkR, dh, ltk) @j1 &
        ResponderFinishedLegPairing(idR2, capR2, idI2, capI2, lk, aco) @j2 ==>
        not (Ex #k1 #k2 .
            K(ltk) @k1 & K(lk) @k2
        )
    )
"

#endif


/***********************************************/
/* End lemmas about SecOOBio-LegPINio exchange */
/***********************************************/

/*
* Command-line to generate a Tamarin file with the entire model without all preprocessor macros:
* tamarin-prover ble.spthy -DInitSec -DLegPINiSecJW -DSecJWLegPINio -DSecOOBiSecPEio -DLegPINoSecJW -DSecPEioSecNC -DSecPEoSecJW -DSecNCLegPINi -DSecOOBoSecPEo -DSecOOBiLegPINo -DInitSecOOBio -DSecOOBoSecOOBo -DLegPINiSecNC -DSecPEiSecOOBi -DSecOOBioLegPINi -DSecPEioLegPINio -DRespLegPINo -DSecOOBiLegPINi -DSecJWSecOOBio -DRespSecPEi -DSecOOBiSecPEi -DSecOOBioSecOOBo -DSecPEoSecPEo -DInitLeg -DSecJWSecPEo -DSecOOBiLegPINio -DSecOOBoLegPINi -DSecOOBoSecOOBio -DLegPINoSecOOBi -DSecPEoSecPEi -DSecNCLegPINo -DRespSecPEo -DRespSecOOBo -DSecNCSecPEi -DSecPEioLegPINi -DInputInput -DInitSecPE -DRespSecOOBi -DSecPEioSecOOBi -DRespLegPINio -DRespSecOOB -DLegPINiSecPEo -DLegPINoSecPEo -DSecPEoLegPINio -DSecOOBoSecNC -DSecJWLegPINo -DSecPEioSecOOBio -DSecPEoSecOOBi -DLegPINiSecOOBo -DLegPINioSecPEo -DInitSecNC -DSecJWSecOOBi -DSecJWLegPINi -DSecJWSecNC -DInitSecOOBi -DLegPINiLegPINo -DLegPINiSecOOBio -DSecOOBioLegPINio -DSecPEioSecPEo -DLegPINioSecJW -DInitSecPEo -DSecNCSecJW -DLegPINioLegPINi -DSecOOBoLegPINo -DSecPEiSecPEi -DSecOOBioSecJW -DLegPINoSecPEio -DRespSecOOBio -DInitSecPEi -DRespSecPE -DSecPEoSecOOBo -DSecNCSecOOBio -DLegPINioSecOOBo -DOutputOutput -DSecNCSecOOBi -DInoutInput -DSecPEiSecJW -DSecPEoSecPEio -DLegPINioLegPINo -DLegPINiSecOOBi -DSecPEiSecOOBo -DSecOOBiSecOOBio -DLegPINoSecOOBo -DSecPEoSecNC -DInputInout -DLegPINoLegPINo -DInitLegPINo -DSecPEioSecPEio -DRespSecPEio -DSecOOBioSecOOBio -DSecNCSecPEo -DLegPINiLegPINio -DLegPINioSecOOBio -DSecOOBoSecPEi -DSecNCSecPEio -DSecNCSecOOBo -DInoutInout -DRespSecJW -DSecOOBioSecOOBi -DLegPINoSecNC -DSecPEiLegPINi -DSecPEioSecJW -DOutputInput -DInitLegPINio -DSecOOBiSecOOBo -DSecOOBioLegPINo -DSecOOBoLegPINio -DSecOOBioSecPEo -DSecOOBiSecOOBi -DSecJWSecPEio -DSecPEoSecOOBio -DSecOOBiSecNC -DSecPEoLegPINi -DSecOOBoSecOOBi -DLegPINiSecPEi -DSecPEioLegPINo -DSecNCLegPINio -DOutputInout -DSecOOBiSecPEo -DSecOOBioSecPEio -DRespLeg -DSecOOBoSecPEio -DSecPEiSecPEio -DSecPEiLegPINio -DLegPINioLegPINio -DLegPINioSecPEi -DSecPEiSecPEo -DLegPINiSecPEio -DSecPEoLegPINo -DLegPINoLegPINio -DLegPINoSecOOBio -DRespSec -DSecJWSecJW -DSecOOBioSecPEi -DSecPEiSecNC -DSecPEiSecOOBio -DLegPINoSecPEi -DRespSecNC -DInitLegPINi -DSecJWSecPEi -DSecPEioSecOOBo -DSecOOBoSecJW -DInitSecOOBo -DSecJWSecOOBo -DRespLegPINi -DLegPINioSecNC -DLegPINioSecOOBi -DInputOutput -DInitSecPEio -DLegPINioSecPEio -DInoutOutput -DSecOOBiSecJW -DInitSecOOB -DInitSecJW -DSecOOBioSecNC -DSecPEioSecPEi -DLegPINiLegPINi -DSecNCSecNC -DLegPINoLegPINi -DSecPEiLegPINo
*/

/* Command lines to prove individual cases:
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespLeg -DRespLegPINi -DLegPINiLegPINi -DInputInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespLeg -DRespLegPINo -DLegPINiLegPINo -DInputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespLeg -DRespLegPINio -DLegPINiLegPINio -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespLeg -DRespLegPINi -DLegPINoLegPINi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespLeg -DRespLegPINo -DLegPINoLegPINo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespLeg -DRespLegPINio -DLegPINoLegPINio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespLeg -DRespLegPINi -DLegPINioLegPINi -DInoutInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespLeg -DRespLegPINo -DLegPINioLegPINo -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespLeg -DRespLegPINio -DLegPINioLegPINio -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecJW -DSecJWSecJW --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEi -DSecJWSecPEi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEo -DSecJWSecPEo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecPE -DRespSecPEio -DSecJWSecPEio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecNC -DSecJWSecNC --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBi -DSecJWSecOOBi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBo -DSecJWSecOOBo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespSec -DRespSecOOB -DRespSecOOBio -DSecJWSecOOBio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecJW -DSecPEiSecJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEi -DSecPEiSecPEi -DInputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEo -DSecPEiSecPEo -DInputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecPE -DRespSecPEio -DSecPEiSecPEio -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecNC -DSecPEiSecNC -DInputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEiSecOOBi -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEiSecOOBo -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEiSecOOBio -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecJW -DSecPEoSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEi -DSecPEoSecPEi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEo -DSecPEoSecPEo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecPE -DRespSecPEio -DSecPEoSecPEio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecNC -DSecPEoSecNC -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEoSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEoSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEoSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecJW -DSecPEioSecJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEi -DSecPEioSecPEi -DInoutInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEo -DSecPEioSecPEo -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecPE -DRespSecPEio -DSecPEioSecPEio -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecNC -DSecPEioSecNC -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBi -DSecPEioSecOOBi -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBo -DSecPEioSecOOBo -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespSec -DRespSecOOB -DRespSecOOBio -DSecPEioSecOOBio -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecJW -DSecNCSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEi -DSecNCSecPEi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEo -DSecNCSecPEo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecPE -DRespSecPEio -DSecNCSecPEio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecNC -DSecNCSecNC -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBi -DSecNCSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBo -DSecNCSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespSec -DRespSecOOB -DRespSecOOBio -DSecNCSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecJW -DSecOOBiSecJW --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBiSecPEi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBiSecPEo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBiSecPEio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecNC -DSecOOBiSecNC --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBiSecOOBi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBiSecOOBo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBiSecOOBio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecJW -DSecOOBoSecJW --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBoSecPEi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBoSecPEo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBoSecPEio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecNC -DSecOOBoSecNC --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBoSecOOBi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBoSecOOBo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBoSecOOBio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecJW -DSecOOBioSecJW --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEi -DSecOOBioSecPEi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEo -DSecOOBioSecPEo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecPE -DRespSecPEio -DSecOOBioSecPEio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecNC -DSecOOBioSecNC --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBi -DSecOOBioSecOOBi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBo -DSecOOBioSecOOBo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespSec -DRespSecOOB -DRespSecOOBio -DSecOOBioSecOOBio --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecJW -DLegPINiSecJW -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecPE -DRespSecPEi -DLegPINiSecPEi -DInputInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecPE -DRespSecPEo -DLegPINiSecPEo -DInputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecPE -DRespSecPEio -DLegPINiSecPEio -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecNC -DLegPINiSecNC -DInputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPINiSecOOBi -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPINiSecOOBo -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINi -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPINiSecOOBio -DInputInput -DInputOutput -DInputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecJW -DLegPINoSecJW -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecPE -DRespSecPEi -DLegPINoSecPEi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecPE -DRespSecPEo -DLegPINoSecPEo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecPE -DRespSecPEio -DLegPINoSecPEio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecNC -DLegPINoSecNC -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPINoSecOOBi -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPINoSecOOBo -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINo -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPINoSecOOBio -DOutputInput -DOutputOutput -DOutputInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecJW -DLegPINioSecJW -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecPE -DRespSecPEi -DLegPINioSecPEi -DInoutInput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecPE -DRespSecPEo -DLegPINioSecPEo -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecPE -DRespSecPEio -DLegPINioSecPEio -DInoutInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecNC -DLegPINioSecNC -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecOOB -DRespSecOOBi -DLegPINioSecOOBi -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecOOB -DRespSecOOBo -DLegPINioSecOOBo -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitLeg -DInitLegPINio -DRespSec -DRespSecOOB -DRespSecOOBio -DLegPINioSecOOBio -DInoutInput -DInoutOutput -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPINi -DSecJWLegPINi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPINo -DSecJWLegPINo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecJW -DRespLeg -DRespLegPINio -DSecJWLegPINio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPINi -DSecPEiLegPINi -DInputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPINo -DSecPEiLegPINo -DInputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEi -DRespLeg -DRespLegPINio -DSecPEiLegPINio -DInputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPINi -DSecPEoLegPINi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPINo -DSecPEoLegPINo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEo -DRespLeg -DRespLegPINio -DSecPEoLegPINio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPINi -DSecPEioLegPINi -DInoutInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPINo -DSecPEioLegPINo -DInoutOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecPE -DInitSecPEio -DRespLeg -DRespLegPINio -DSecPEioLegPINio -DInoutInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPINi -DSecNCLegPINi -DOutputInput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPINo -DSecNCLegPINo -DOutputOutput --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecNC -DRespLeg -DRespLegPINio -DSecNCLegPINio -DOutputInout --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPINi -DSecOOBiLegPINi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPINo -DSecOOBiLegPINo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBi -DRespLeg -DRespLegPINio -DSecOOBiLegPINio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPINi -DSecOOBoLegPINi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPINo -DSecOOBoLegPINo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBo -DRespLeg -DRespLegPINio -DSecOOBoLegPINio --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPINi -DSecOOBioLegPINi --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPINo -DSecOOBioLegPINo --prove
tamarin-prover bredr.spthy -DInitSec -DInitSecOOB -DInitSecOOBio -DRespLeg -DRespLegPINio -DSecOOBioLegPINio --prove


JSON configuration file:
{
"LegPINiLegPINi": ["InitLeg","InitLegPINi","RespLeg","RespLegPINi","LegPINiLegPINi","InputInput"],
"LegPINiLegPINo": ["InitLeg","InitLegPINi","RespLeg","RespLegPINo","LegPINiLegPINo","InputOutput"],
"LegPINiLegPINio": ["InitLeg","InitLegPINi","RespLeg","RespLegPINio","LegPINiLegPINio","InputInout"],
"LegPINoLegPINi": ["InitLeg","InitLegPINo","RespLeg","RespLegPINi","LegPINoLegPINi","OutputInput"],
"LegPINoLegPINo": ["InitLeg","InitLegPINo","RespLeg","RespLegPINo","LegPINoLegPINo","OutputOutput"],
"LegPINoLegPINio": ["InitLeg","InitLegPINo","RespLeg","RespLegPINio","LegPINoLegPINio","OutputInout"],
"LegPINioLegPINi": ["InitLeg","InitLegPINio","RespLeg","RespLegPINi","LegPINioLegPINi","InoutInput"],
"LegPINioLegPINo": ["InitLeg","InitLegPINio","RespLeg","RespLegPINo","LegPINioLegPINo","InoutOutput"],
"LegPINioLegPINio": ["InitLeg","InitLegPINio","RespLeg","RespLegPINio","LegPINioLegPINio","InoutInout"],
"SecJWSecJW": ["InitSec","InitSecJW","RespSec","RespSecJW","SecJWSecJW"],
"SecJWSecPEi": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEi","SecJWSecPEi"],
"SecJWSecPEo": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEo","SecJWSecPEo"],
"SecJWSecPEio": ["InitSec","InitSecJW","RespSec","RespSecPE","RespSecPEio","SecJWSecPEio"],
"SecJWSecNC": ["InitSec","InitSecJW","RespSec","RespSecNC","SecJWSecNC"],
"SecJWSecOOBi": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBi","SecJWSecOOBi"],
"SecJWSecOOBo": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBo","SecJWSecOOBo"],
"SecJWSecOOBio": ["InitSec","InitSecJW","RespSec","RespSecOOB","RespSecOOBio","SecJWSecOOBio"],
"SecPEiSecJW": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecJW","SecPEiSecJW","InputInput","InputOutput","InputInout"],
"SecPEiSecPEi": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEi","SecPEiSecPEi","InputInput"],
"SecPEiSecPEo": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEo","SecPEiSecPEo","InputOutput"],
"SecPEiSecPEio": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecPE","RespSecPEio","SecPEiSecPEio","InputInout"],
"SecPEiSecNC": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecNC","SecPEiSecNC","InputOutput"],
"SecPEiSecOOBi": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBi","SecPEiSecOOBi","InputInput","InputOutput","InputInout"],
"SecPEiSecOOBo": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBo","SecPEiSecOOBo","InputInput","InputOutput","InputInout"],
"SecPEiSecOOBio": ["InitSec","InitSecPE","InitSecPEi","RespSec","RespSecOOB","RespSecOOBio","SecPEiSecOOBio","InputInput","InputOutput","InputInout"],
"SecPEoSecJW": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecJW","SecPEoSecJW","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecPEi": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEi","SecPEoSecPEi","OutputInput"],
"SecPEoSecPEo": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEo","SecPEoSecPEo","OutputOutput"],
"SecPEoSecPEio": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecPE","RespSecPEio","SecPEoSecPEio","OutputInout"],
"SecPEoSecNC": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecNC","SecPEoSecNC","OutputOutput"],
"SecPEoSecOOBi": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBi","SecPEoSecOOBi","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecOOBo": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBo","SecPEoSecOOBo","OutputInput","OutputOutput","OutputInout"],
"SecPEoSecOOBio": ["InitSec","InitSecPE","InitSecPEo","RespSec","RespSecOOB","RespSecOOBio","SecPEoSecOOBio","OutputInput","OutputOutput","OutputInout"],
"SecPEioSecJW": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecJW","SecPEioSecJW","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecPEi": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEi","SecPEioSecPEi","InoutInput"],
"SecPEioSecPEo": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEo","SecPEioSecPEo","InoutOutput"],
"SecPEioSecPEio": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecPE","RespSecPEio","SecPEioSecPEio","InoutInout"],
"SecPEioSecNC": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecNC","SecPEioSecNC","InoutOutput"],
"SecPEioSecOOBi": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBi","SecPEioSecOOBi","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecOOBo": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBo","SecPEioSecOOBo","InoutInput","InoutOutput","InoutInout"],
"SecPEioSecOOBio": ["InitSec","InitSecPE","InitSecPEio","RespSec","RespSecOOB","RespSecOOBio","SecPEioSecOOBio","InoutInput","InoutOutput","InoutInout"],
"SecNCSecJW": ["InitSec","InitSecNC","RespSec","RespSecJW","SecNCSecJW","OutputInput","OutputOutput","OutputInout"],
"SecNCSecPEi": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEi","SecNCSecPEi","OutputInput"],
"SecNCSecPEo": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEo","SecNCSecPEo","OutputOutput"],
"SecNCSecPEio": ["InitSec","InitSecNC","RespSec","RespSecPE","RespSecPEio","SecNCSecPEio","OutputInout"],
"SecNCSecNC": ["InitSec","InitSecNC","RespSec","RespSecNC","SecNCSecNC","OutputOutput"],
"SecNCSecOOBi": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBi","SecNCSecOOBi","OutputInput","OutputOutput","OutputInout"],
"SecNCSecOOBo": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBo","SecNCSecOOBo","OutputInput","OutputOutput","OutputInout"],
"SecNCSecOOBio": ["InitSec","InitSecNC","RespSec","RespSecOOB","RespSecOOBio","SecNCSecOOBio","OutputInput","OutputOutput","OutputInout"],
"SecOOBiSecJW": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecJW","SecOOBiSecJW"],
"SecOOBiSecPEi": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEi","SecOOBiSecPEi"],
"SecOOBiSecPEo": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEo","SecOOBiSecPEo"],
"SecOOBiSecPEio": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecPE","RespSecPEio","SecOOBiSecPEio"],
"SecOOBiSecNC": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecNC","SecOOBiSecNC"],
"SecOOBiSecOOBi": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBi","SecOOBiSecOOBi"],
"SecOOBiSecOOBo": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBo","SecOOBiSecOOBo"],
"SecOOBiSecOOBio": ["InitSec","InitSecOOB","InitSecOOBi","RespSec","RespSecOOB","RespSecOOBio","SecOOBiSecOOBio"],
"SecOOBoSecJW": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecJW","SecOOBoSecJW"],
"SecOOBoSecPEi": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEi","SecOOBoSecPEi"],
"SecOOBoSecPEo": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEo","SecOOBoSecPEo"],
"SecOOBoSecPEio": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecPE","RespSecPEio","SecOOBoSecPEio"],
"SecOOBoSecNC": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecNC","SecOOBoSecNC"],
"SecOOBoSecOOBi": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBi","SecOOBoSecOOBi"],
"SecOOBoSecOOBo": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBo","SecOOBoSecOOBo"],
"SecOOBoSecOOBio": ["InitSec","InitSecOOB","InitSecOOBo","RespSec","RespSecOOB","RespSecOOBio","SecOOBoSecOOBio"],
"SecOOBioSecJW": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecJW","SecOOBioSecJW"],
"SecOOBioSecPEi": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEi","SecOOBioSecPEi"],
"SecOOBioSecPEo": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEo","SecOOBioSecPEo"],
"SecOOBioSecPEio": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecPE","RespSecPEio","SecOOBioSecPEio"],
"SecOOBioSecNC": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecNC","SecOOBioSecNC"],
"SecOOBioSecOOBi": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBi","SecOOBioSecOOBi"],
"SecOOBioSecOOBo": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBo","SecOOBioSecOOBo"],
"SecOOBioSecOOBio": ["InitSec","InitSecOOB","InitSecOOBio","RespSec","RespSecOOB","RespSecOOBio","SecOOBioSecOOBio"],
"LegPINiSecJW": ["InitLeg","InitLegPINi","RespSec","RespSecJW","LegPINiSecJW","InputInput","InputOutput","InputInout"],
"LegPINiSecPEi": ["InitLeg","InitLegPINi","RespSec","RespSecPE","RespSecPEi","LegPINiSecPEi","InputInput"],
"LegPINiSecPEo": ["InitLeg","InitLegPINi","RespSec","RespSecPE","RespSecPEo","LegPINiSecPEo","InputOutput"],
"LegPINiSecPEio": ["InitLeg","InitLegPINi","RespSec","RespSecPE","RespSecPEio","LegPINiSecPEio","InputInout"],
"LegPINiSecNC": ["InitLeg","InitLegPINi","RespSec","RespSecNC","LegPINiSecNC","InputOutput"],
"LegPINiSecOOBi": ["InitLeg","InitLegPINi","RespSec","RespSecOOB","RespSecOOBi","LegPINiSecOOBi","InputInput","InputOutput","InputInout"],
"LegPINiSecOOBo": ["InitLeg","InitLegPINi","RespSec","RespSecOOB","RespSecOOBo","LegPINiSecOOBo","InputInput","InputOutput","InputInout"],
"LegPINiSecOOBio": ["InitLeg","InitLegPINi","RespSec","RespSecOOB","RespSecOOBio","LegPINiSecOOBio","InputInput","InputOutput","InputInout"],
"LegPINoSecJW": ["InitLeg","InitLegPINo","RespSec","RespSecJW","LegPINoSecJW","OutputInput","OutputOutput","OutputInout"],
"LegPINoSecPEi": ["InitLeg","InitLegPINo","RespSec","RespSecPE","RespSecPEi","LegPINoSecPEi","OutputInput"],
"LegPINoSecPEo": ["InitLeg","InitLegPINo","RespSec","RespSecPE","RespSecPEo","LegPINoSecPEo","OutputOutput"],
"LegPINoSecPEio": ["InitLeg","InitLegPINo","RespSec","RespSecPE","RespSecPEio","LegPINoSecPEio","OutputInout"],
"LegPINoSecNC": ["InitLeg","InitLegPINo","RespSec","RespSecNC","LegPINoSecNC","OutputOutput"],
"LegPINoSecOOBi": ["InitLeg","InitLegPINo","RespSec","RespSecOOB","RespSecOOBi","LegPINoSecOOBi","OutputInput","OutputOutput","OutputInout"],
"LegPINoSecOOBo": ["InitLeg","InitLegPINo","RespSec","RespSecOOB","RespSecOOBo","LegPINoSecOOBo","OutputInput","OutputOutput","OutputInout"],
"LegPINoSecOOBio": ["InitLeg","InitLegPINo","RespSec","RespSecOOB","RespSecOOBio","LegPINoSecOOBio","OutputInput","OutputOutput","OutputInout"],
"LegPINioSecJW": ["InitLeg","InitLegPINio","RespSec","RespSecJW","LegPINioSecJW","InoutInput","InoutOutput","InoutInout"],
"LegPINioSecPEi": ["InitLeg","InitLegPINio","RespSec","RespSecPE","RespSecPEi","LegPINioSecPEi","InoutInput"],
"LegPINioSecPEo": ["InitLeg","InitLegPINio","RespSec","RespSecPE","RespSecPEo","LegPINioSecPEo","InoutOutput"],
"LegPINioSecPEio": ["InitLeg","InitLegPINio","RespSec","RespSecPE","RespSecPEio","LegPINioSecPEio","InoutInout"],
"LegPINioSecNC": ["InitLeg","InitLegPINio","RespSec","RespSecNC","LegPINioSecNC","InoutOutput"],
"LegPINioSecOOBi": ["InitLeg","InitLegPINio","RespSec","RespSecOOB","RespSecOOBi","LegPINioSecOOBi","InoutInput","InoutOutput","InoutInout"],
"LegPINioSecOOBo": ["InitLeg","InitLegPINio","RespSec","RespSecOOB","RespSecOOBo","LegPINioSecOOBo","InoutInput","InoutOutput","InoutInout"],
"LegPINioSecOOBio": ["InitLeg","InitLegPINio","RespSec","RespSecOOB","RespSecOOBio","LegPINioSecOOBio","InoutInput","InoutOutput","InoutInout"],
"SecJWLegPINi": ["InitSec","InitSecJW","RespLeg","RespLegPINi","SecJWLegPINi"],
"SecJWLegPINo": ["InitSec","InitSecJW","RespLeg","RespLegPINo","SecJWLegPINo"],
"SecJWLegPINio": ["InitSec","InitSecJW","RespLeg","RespLegPINio","SecJWLegPINio"],
"SecPEiLegPINi": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPINi","SecPEiLegPINi","InputInput"],
"SecPEiLegPINo": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPINo","SecPEiLegPINo","InputOutput"],
"SecPEiLegPINio": ["InitSec","InitSecPE","InitSecPEi","RespLeg","RespLegPINio","SecPEiLegPINio","InputInout"],
"SecPEoLegPINi": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPINi","SecPEoLegPINi","OutputInput"],
"SecPEoLegPINo": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPINo","SecPEoLegPINo","OutputOutput"],
"SecPEoLegPINio": ["InitSec","InitSecPE","InitSecPEo","RespLeg","RespLegPINio","SecPEoLegPINio","OutputInout"],
"SecPEioLegPINi": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPINi","SecPEioLegPINi","InoutInput"],
"SecPEioLegPINo": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPINo","SecPEioLegPINo","InoutOutput"],
"SecPEioLegPINio": ["InitSec","InitSecPE","InitSecPEio","RespLeg","RespLegPINio","SecPEioLegPINio","InoutInout"],
"SecNCLegPINi": ["InitSec","InitSecNC","RespLeg","RespLegPINi","SecNCLegPINi","OutputInput"],
"SecNCLegPINo": ["InitSec","InitSecNC","RespLeg","RespLegPINo","SecNCLegPINo","OutputOutput"],
"SecNCLegPINio": ["InitSec","InitSecNC","RespLeg","RespLegPINio","SecNCLegPINio","OutputInout"],
"SecOOBiLegPINi": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPINi","SecOOBiLegPINi"],
"SecOOBiLegPINo": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPINo","SecOOBiLegPINo"],
"SecOOBiLegPINio": ["InitSec","InitSecOOB","InitSecOOBi","RespLeg","RespLegPINio","SecOOBiLegPINio"],
"SecOOBoLegPINi": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPINi","SecOOBoLegPINi"],
"SecOOBoLegPINo": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPINo","SecOOBoLegPINo"],
"SecOOBoLegPINio": ["InitSec","InitSecOOB","InitSecOOBo","RespLeg","RespLegPINio","SecOOBoLegPINio"],
"SecOOBioLegPINi": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPINi","SecOOBioLegPINi"],
"SecOOBioLegPINo": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPINo","SecOOBioLegPINo"],
"SecOOBioLegPINio": ["InitSec","InitSecOOB","InitSecOOBio","RespLeg","RespLegPINio","SecOOBioLegPINio"],
}
*/

end
