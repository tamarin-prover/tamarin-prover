theory StatVerif_Security_Device begin

/*
   Protocol:    Simple security device (Example 1 from [1])
   Modeler:     Robert KÃ¼nnemann
   Date:        May 2013

   Status:      working

   [1] M. Arapinis, E. Ritter and M. Ryan. StatVerif: Verification of Stateful
   Processes. In CSF'11. IEEE Computer Society Press, pages 33-47 , 2011.

/* StatVerif source code of the original model from [1].

fun pair/2.
fun aenc/3.
fun pk/1.
free left.
free right.
free init.
free c.

reduc
    projl(pair(xleft, xright)) = xleft;
    projr(pair(xleft, xright)) = xright;
    adec(u, aenc(pk(u), v, w)) = w.

query
    att:vs,pair(sl,sr).

let device =
    out(c, pk(k)) |
    ( ! lock(s); in(c, x); read s as y;
        if y = init then
            (if x = left then s := x; unlock(s)
            else if x = right then s := x; unlock(s))  ) |
    ( ! lock(s); in(c, x); read s as y; let z = adec(k, x) in
        let zl = projl(z) in
        let zr = projr(z) in
        ((if y = left then out(c, zl); unlock(s)) |
         (if y = right then out(c, zr); unlock(s)))).

let user =
    new sl; new sr; new r;
        out(c, aenc(pk(k), r, pair(sl,sr))).

process
    new k; new s; [s |-> init] | device | ! user

*/

builtins: asymmetric-encryption

let Device=(
	out(pk(sk)) 
	||
	!(	lock s ; in(req);
		lookup s as status in
			if status='init' then
                            (if req='left' then
                                event InitDevice(s);
				insert s,req;
				unlock s
                            else
                                if req='right' then
                                event InitDevice(s);
				insert s,req;
				unlock s)
	) 
	||
	!(
		lock s;
		in(aenc{<x,y>}pk(sk));
		lookup s as status in
			if status='left' then
				event Access(x); out(x); unlock s
			else if status='right' then
				event Access(y); out(y); unlock s
		else unlock s
         )
)

let User=new lm; new rm; event Exclusive(lm,rm); out(aenc{<lm,rm>}pk(sk))

!( new sk; new s; insert s,'init'; ( Device || ! User ))

// Source lemma, taken from Tamarin's example directory:

// As we use a backwards search, we must specify the possible structure of
// messages sent in 'UseLeftDevice' and 'UseRightDevice' precise enough such
// that we can solve all chain constraints starting from the sent message. We
// therefore log the message being accessed and relate it to its possible
// origins: known to the intruder in an earlier step or part of an exclusive
// message generated by 'Alice'. Source lemmas are proven by induction and
// incorporated in the precomputation of the sources.
lemma source [sources]:
  "All m #i. Access(m) @ i ==>
      (Ex #j. KU(m) @ j & j < i)  // Make use of the KU-facts logged
                                  // by the construction rules.
    | (Ex x #j. Exclusive(x,m) @ j)
    | (Ex y #j. Exclusive(m,y) @ j)
  "

/* lemma sources2 [sources]: */
/*   "All s #t1 #t2 . InitDevice(s)@t1 & InitDevice(s)@t2 ==>  #t1=#t2 " */

// Check that there is some trace where the intruder knows the left message of
// an exclusive message-tuple. In contrast to the source lemma, we use the
// standard 'K'-fact, which is logged by the built-in 'ISend' rule.
lemma reachability_left:
  exists-trace
  "Ex x y #i #j. Exclusive(x,y) @i & K(x) @ j"

lemma reachability_right:
  exists-trace
  "Ex x y #i #k. Exclusive(x,y) @i & K(y) @ k"

// Check that exclusivity is maintained
lemma secrecy:
  "not(Ex x y #i #k1 #k2.
         Exclusive(x,y) @i & K(x) @ k1 & K(y) @ k2
      )
  "

end
