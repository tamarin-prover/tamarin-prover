theory EncWrapDecUnwrap begin

// Function signature and definition of the equational theory E

functions: att/1, fst/1, key/1, pair/2, sdec/2, senc/2, snd/1
equations:
    att(<k, a>) = a,
    fst(<x.1, x.2>) = x.1,
    key(<k, a>) = k,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2

rule (modulo E) 0:
   [ ] --[ Init( ) ]-> [ !State_0( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep0:
   [ !State_0( ) ] --> [ State_01( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par01:
   [ State_01( ) ] --> [ State_011( ), State_012( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par011:
   [ State_011( ) ] --> [ State_0111( ), State_0112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par0111:
   [ State_0111( ) ] --> [ State_01111( ), State_01112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par01111:
   [ State_01111( ) ] --> [ State_011111( ), State_011112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par011111:
   [ State_011111( ) ] --> [ State_0111111( ), State_0111112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par0111111:
   [ State_0111111( ) ] --> [ State_01111111( ), State_01111112( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in__create_01111111:
   [ State_01111111( ), In( 'create' ) ] --> [ State_011111111( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_011111111:
   [ State_011111111( ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, 'device' ) ]->
   [ State_0111111111( ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_h0111111111:
   [ State_0111111111( ~lock7 ), Fr( h ) ]
  -->
   [ State_01111111111( h, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_k01111111111:
   [ State_01111111111( h, ~lock7 ), Fr( k ) ]
  -->
   [ State_011111111111( h, k, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_NewKey_h__k_011111111111:
   [ State_011111111111( h, k, ~lock7 ) ]
  --[ Event( ), NewKey( h, k ) ]->
   [ State_0111111111111( h, k, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_h__k___init__0111111111111:
   [ State_0111111111111( h, k, ~lock7 ) ]
  --[ Insert( h, <k, 'init'> ) ]->
   [ State_01111111111111( h, k, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_h01111111111111:
   [ State_01111111111111( h, k, ~lock7 ) ]
  -->
   [ Out( h ), State_011111111111111( h, k, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock__device_011111111111111:
   [ State_011111111111111( h, k, ~lock7 ) ]
  --[ Unlock( ~lock7, 'device' ) ]->
   [ State_0111111111111111( h, k, ~lock7 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in___set_wrap___h_01111112:
   [ State_01111112( ), In( <'set_wrap', h> ) ]
  -->
   [ State_011111121( h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_011111121:
   [ State_011111121( h ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, 'device' ) ]->
   [ State_0111111211( ~lock7, h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h_as_v0111111211:
   [ State_0111111211( ~lock7, h ) ]
  --[ IsIn( h, v ) ]->
   [ State_01111112111( ~lock7, h, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h_as_v0111111211:
   [ State_0111111211( ~lock7, h ) ]
  --[ IsNotSet( h ) ]->
   [ State_01111112112( ~lock7, h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v____init__01111112111:
   [ State_01111112111( ~lock7, h, v ) ]
  --[ Pred_eq( att(v), 'init' ) ]->
   [ State_011111121111( ~lock7, h, v ) ]

  /*
  rule (modulo AC) if_eq_att_v____init__01111112111:
     [ State_01111112111( ~lock7, h, v ) ]
    --[ Pred_eq( z, 'init' ) ]->
     [ State_011111121111( ~lock7, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = att(v.6)
    
    2. v     = <x.8, z.7>
       z     = z.7
  */

rule (modulo E) else__if_eq_att_v____init__01111112111:
   [ State_01111112111( ~lock7, h, v ) ]
  --[ Pred_not_eq( att(v), 'init' ) ]->
   [ State_011111121112( ~lock7, h, v ) ]

  /*
  rule (modulo AC) else__if_eq_att_v____init__01111112111:
     [ State_01111112111( ~lock7, h, v ) ]
    --[ Pred_not_eq( z, 'init' ) ]->
     [ State_011111121112( ~lock7, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = att(v.6)
    
    2. v     = <x.8, z.7>
       z     = z.7
  */

rule (modulo E) event_WrapKey_h__key_v__011111121111:
   [ State_011111121111( ~lock7, h, v ) ]
  --[ Event( ), WrapKey( h, key(v) ) ]->
   [ State_0111111211111( ~lock7, h, v ) ]

  /*
  rule (modulo AC) event_WrapKey_h__key_v__011111121111:
     [ State_011111121111( ~lock7, h, v ) ]
    --[ Event( ), WrapKey( h, z ) ]->
     [ State_0111111211111( ~lock7, h, v ) ]
    variants (modulo AC)
    1. v     = v.5
       z     = key(v.5)
    
    2. v     = <x.5, x.6>
       z     = x.5
  */

rule (modulo E) insert_h__key_v____wrap__0111111211111:
   [ State_0111111211111( ~lock7, h, v ) ]
  --[ Insert( h, <key(v), 'wrap'> ) ]->
   [ State_01111112111111( ~lock7, h, v ) ]

  /*
  rule (modulo AC) insert_h__key_v____wrap__0111111211111:
     [ State_0111111211111( ~lock7, h, v ) ]
    --[ Insert( h, <z, 'wrap'> ) ]->
     [ State_01111112111111( ~lock7, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = key(v.6)
    
    2. v     = <z.7, x.9>
       z     = z.7
  */

rule (modulo E) event_WrapHandle_h_01111112111111:
   [ State_01111112111111( ~lock7, h, v ) ]
  --[ Event( ), WrapHandle( h ) ]->
   [ State_011111121111111( ~lock7, h, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock__device_011111121111111:
   [ State_011111121111111( ~lock7, h, v ) ]
  --[ Unlock( ~lock7, 'device' ) ]->
   [ State_0111111211111111( ~lock7, h, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero011111121112:
   [ State_011111121112( ~lock7, h, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in___set_dec___h_0111112:
   [ State_0111112( ), In( <'set_dec', h> ) ]
  -->
   [ State_01111121( h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_01111121:
   [ State_01111121( h ), Fr( ~lock6 ) ]
  --[ Lock( ~lock6, 'device' ) ]->
   [ State_011111211( ~lock6, h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h_as_v011111211:
   [ State_011111211( ~lock6, h ) ]
  --[ IsIn( h, v ) ]->
   [ State_0111112111( ~lock6, h, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h_as_v011111211:
   [ State_011111211( ~lock6, h ) ]
  --[ IsNotSet( h ) ]->
   [ State_0111112112( ~lock6, h ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v____init__0111112111:
   [ State_0111112111( ~lock6, h, v ) ]
  --[ Pred_eq( att(v), 'init' ) ]->
   [ State_01111121111( ~lock6, h, v ) ]

  /*
  rule (modulo AC) if_eq_att_v____init__0111112111:
     [ State_0111112111( ~lock6, h, v ) ]
    --[ Pred_eq( z, 'init' ) ]->
     [ State_01111121111( ~lock6, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = att(v.6)
    
    2. v     = <x.8, z.7>
       z     = z.7
  */

rule (modulo E) else__if_eq_att_v____init__0111112111:
   [ State_0111112111( ~lock6, h, v ) ]
  --[ Pred_not_eq( att(v), 'init' ) ]->
   [ State_01111121112( ~lock6, h, v ) ]

  /*
  rule (modulo AC) else__if_eq_att_v____init__0111112111:
     [ State_0111112111( ~lock6, h, v ) ]
    --[ Pred_not_eq( z, 'init' ) ]->
     [ State_01111121112( ~lock6, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = att(v.6)
    
    2. v     = <x.8, z.7>
       z     = z.7
  */

rule (modulo E) event_DecKey_h__key_v__01111121111:
   [ State_01111121111( ~lock6, h, v ) ]
  --[ Event( ), DecKey( h, key(v) ) ]->
   [ State_011111211111( ~lock6, h, v ) ]

  /*
  rule (modulo AC) event_DecKey_h__key_v__01111121111:
     [ State_01111121111( ~lock6, h, v ) ]
    --[ Event( ), DecKey( h, z ) ]->
     [ State_011111211111( ~lock6, h, v ) ]
    variants (modulo AC)
    1. v     = v.5
       z     = key(v.5)
    
    2. v     = <x.5, x.6>
       z     = x.5
  */

rule (modulo E) insert_h__key_v____dec__011111211111:
   [ State_011111211111( ~lock6, h, v ) ]
  --[ Insert( h, <key(v), 'dec'> ) ]->
   [ State_0111112111111( ~lock6, h, v ) ]

  /*
  rule (modulo AC) insert_h__key_v____dec__011111211111:
     [ State_011111211111( ~lock6, h, v ) ]
    --[ Insert( h, <z, 'dec'> ) ]->
     [ State_0111112111111( ~lock6, h, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = key(v.6)
    
    2. v     = <z.7, x.9>
       z     = z.7
  */

rule (modulo E) unlock__device_0111112111111:
   [ State_0111112111111( ~lock6, h, v ) ]
  --[ Unlock( ~lock6, 'device' ) ]->
   [ State_01111121111111( ~lock6, h, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero01111121112:
   [ State_01111121112( ~lock6, h, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in__h__senc_m__k__011112:
   [ State_011112( ), In( <h, senc(m, k)> ) ]
  -->
   [ State_0111121( h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_0111121:
   [ State_0111121( h, k, m ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, 'device' ) ]->
   [ State_01111211( ~lock7, h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h_as_v01111211:
   [ State_01111211( ~lock7, h, k, m ) ]
  --[ IsIn( h, v ) ]->
   [ State_011112111( ~lock7, h, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h_as_v01111211:
   [ State_01111211( ~lock7, h, k, m ) ]
  --[ IsNotSet( h ) ]->
   [ State_011112112( ~lock7, h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v____dec__011112111:
   [ State_011112111( ~lock7, h, k, m, v ) ]
  --[ Pred_eq( att(v), 'dec' ) ]->
   [ State_0111121111( ~lock7, h, k, m, v ) ]

  /*
  rule (modulo AC) if_eq_att_v____dec__011112111:
     [ State_011112111( ~lock7, h, k, m, v ) ]
    --[ Pred_eq( z, 'dec' ) ]->
     [ State_0111121111( ~lock7, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) else__if_eq_att_v____dec__011112111:
   [ State_011112111( ~lock7, h, k, m, v ) ]
  --[ Pred_not_eq( att(v), 'dec' ) ]->
   [ State_0111121112( ~lock7, h, k, m, v ) ]

  /*
  rule (modulo AC) else__if_eq_att_v____dec__011112111:
     [ State_011112111( ~lock7, h, k, m, v ) ]
    --[ Pred_not_eq( z, 'dec' ) ]->
     [ State_0111121112( ~lock7, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) if_eq_key_v___k_0111121111:
   [ State_0111121111( ~lock7, h, k, m, v ) ]
  --[ Pred_eq( key(v), k ) ]->
   [ State_01111211111( ~lock7, h, k, m, v ) ]

  /*
  rule (modulo AC) if_eq_key_v___k_0111121111:
     [ State_0111121111( ~lock7, h, k, m, v ) ]
    --[ Pred_eq( z, k ) ]->
     [ State_01111211111( ~lock7, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <x.7, x.8>
       z     = x.7
  */

rule (modulo E) else__if_eq_key_v___k_0111121111:
   [ State_0111121111( ~lock7, h, k, m, v ) ]
  --[ Pred_not_eq( key(v), k ) ]->
   [ State_01111211112( ~lock7, h, k, m, v ) ]

  /*
  rule (modulo AC) else__if_eq_key_v___k_0111121111:
     [ State_0111121111( ~lock7, h, k, m, v ) ]
    --[ Pred_not_eq( z, k ) ]->
     [ State_01111211112( ~lock7, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <x.7, x.8>
       z     = x.7
  */

rule (modulo E) event_DecUsing_k__m_01111211111:
   [ State_01111211111( ~lock7, h, k, m, v ) ]
  --[ Event( ), DecUsing( k, m ) ]->
   [ State_011112111111( ~lock7, h, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_m011112111111:
   [ State_011112111111( ~lock7, h, k, m, v ) ]
  -->
   [ Out( m ), State_0111121111111( ~lock7, h, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock__device_0111121111111:
   [ State_0111121111111( ~lock7, h, k, m, v ) ]
  --[ Unlock( ~lock7, 'device' ) ]->
   [ State_01111211111111( ~lock7, h, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero01111211112:
   [ State_01111211112( ~lock7, h, k, m, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero0111121112:
   [ State_0111121112( ~lock7, h, k, m, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in__h__m_01112:
   [ State_01112( ), In( <h, m> ) ] --> [ State_011121( h, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_011121:
   [ State_011121( h, m ), Fr( ~lock6 ) ]
  --[ Lock( ~lock6, 'device' ) ]->
   [ State_0111211( ~lock6, h, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h_as_v0111211:
   [ State_0111211( ~lock6, h, m ) ]
  --[ IsIn( h, v ) ]->
   [ State_01112111( ~lock6, h, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h_as_v0111211:
   [ State_0111211( ~lock6, h, m ) ]
  --[ IsNotSet( h ) ]->
   [ State_01112112( ~lock6, h, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v____dec__01112111:
   [ State_01112111( ~lock6, h, m, v ) ]
  --[ Pred_eq( att(v), 'dec' ) ]->
   [ State_011121111( ~lock6, h, m, v ) ]

  /*
  rule (modulo AC) if_eq_att_v____dec__01112111:
     [ State_01112111( ~lock6, h, m, v ) ]
    --[ Pred_eq( z, 'dec' ) ]->
     [ State_011121111( ~lock6, h, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = att(v.7)
    
    2. v     = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) else__if_eq_att_v____dec__01112111:
   [ State_01112111( ~lock6, h, m, v ) ]
  --[ Pred_not_eq( att(v), 'dec' ) ]->
   [ State_011121112( ~lock6, h, m, v ) ]

  /*
  rule (modulo AC) else__if_eq_att_v____dec__01112111:
     [ State_01112111( ~lock6, h, m, v ) ]
    --[ Pred_not_eq( z, 'dec' ) ]->
     [ State_011121112( ~lock6, h, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = att(v.7)
    
    2. v     = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) event_EncUsing_key_v___m_011121111:
   [ State_011121111( ~lock6, h, m, v ) ]
  --[ Event( ), EncUsing( key(v), m ) ]->
   [ State_0111211111( ~lock6, h, m, v ) ]

  /*
  rule (modulo AC) event_EncUsing_key_v___m_011121111:
     [ State_011121111( ~lock6, h, m, v ) ]
    --[ Event( ), EncUsing( z, m ) ]->
     [ State_0111211111( ~lock6, h, m, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = key(v.6)
    
    2. v     = <x.6, x.7>
       z     = x.6
  */

rule (modulo E) out_senc_m__key_v__0111211111:
   [ State_0111211111( ~lock6, h, m, v ) ]
  -->
   [ Out( senc(m, key(v)) ), State_01112111111( ~lock6, h, m, v ) ]

  /*
  rule (modulo AC) out_senc_m__key_v__0111211111:
     [ State_0111211111( ~lock6, h, m, v ) ]
    -->
     [ Out( senc(m, z) ), State_01112111111( ~lock6, h, m, v ) ]
    variants (modulo AC)
    1. v     = v.6
       z     = key(v.6)
    
    2. v     = <x.6, x.7>
       z     = x.6
  */

rule (modulo E) unlock__device_01112111111:
   [ State_01112111111( ~lock6, h, m, v ) ]
  --[ Unlock( ~lock6, 'device' ) ]->
   [ State_011121111111( ~lock6, h, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero011121112:
   [ State_011121112( ~lock6, h, m, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in__h1__h2_0112:
   [ State_0112( ), In( <h1, h2> ) ] --> [ State_01121( h1, h2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_01121:
   [ State_01121( h1, h2 ), Fr( ~lock8 ) ]
  --[ Lock( ~lock8, 'device' ) ]->
   [ State_011211( ~lock8, h1, h2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h1_as_v1011211:
   [ State_011211( ~lock8, h1, h2 ) ]
  --[ IsIn( h1, v1 ) ]->
   [ State_0112111( ~lock8, h1, h2, v1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h1_as_v1011211:
   [ State_011211( ~lock8, h1, h2 ) ]
  --[ IsNotSet( h1 ) ]->
   [ State_0112112( ~lock8, h1, h2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v1____wrap__0112111:
   [ State_0112111( ~lock8, h1, h2, v1 ) ]
  --[ Pred_eq( att(v1), 'wrap' ) ]->
   [ State_01121111( ~lock8, h1, h2, v1 ) ]

  /*
  rule (modulo AC) if_eq_att_v1____wrap__0112111:
     [ State_0112111( ~lock8, h1, h2, v1 ) ]
    --[ Pred_eq( z, 'wrap' ) ]->
     [ State_01121111( ~lock8, h1, h2, v1 ) ]
    variants (modulo AC)
    1. v1    = v1.7
       z     = att(v1.7)
    
    2. v1    = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) else__if_eq_att_v1____wrap__0112111:
   [ State_0112111( ~lock8, h1, h2, v1 ) ]
  --[ Pred_not_eq( att(v1), 'wrap' ) ]->
   [ State_01121112( ~lock8, h1, h2, v1 ) ]

  /*
  rule (modulo AC) else__if_eq_att_v1____wrap__0112111:
     [ State_0112111( ~lock8, h1, h2, v1 ) ]
    --[ Pred_not_eq( z, 'wrap' ) ]->
     [ State_01121112( ~lock8, h1, h2, v1 ) ]
    variants (modulo AC)
    1. v1    = v1.7
       z     = att(v1.7)
    
    2. v1    = <x.9, z.8>
       z     = z.8
  */

rule (modulo E) lookup_h2_as_v201121111:
   [ State_01121111( ~lock8, h1, h2, v1 ) ]
  --[ IsIn( h2, v2 ) ]->
   [ State_011211111( ~lock8, h1, h2, v1, v2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h2_as_v201121111:
   [ State_01121111( ~lock8, h1, h2, v1 ) ]
  --[ IsNotSet( h2 ) ]->
   [ State_011211112( ~lock8, h1, h2, v1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v2____wrap__011211111:
   [ State_011211111( ~lock8, h1, h2, v1, v2 ) ]
  --[ Pred_eq( att(v2), 'wrap' ) ]->
   [ State_0112111111( ~lock8, h1, h2, v1, v2 ) ]

  /*
  rule (modulo AC) if_eq_att_v2____wrap__011211111:
     [ State_011211111( ~lock8, h1, h2, v1, v2 ) ]
    --[ Pred_eq( z, 'wrap' ) ]->
     [ State_0112111111( ~lock8, h1, h2, v1, v2 ) ]
    variants (modulo AC)
    1. v2    = v2.8
       z     = att(v2.8)
    
    2. v2    = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) else__if_eq_att_v2____wrap__011211111:
   [ State_011211111( ~lock8, h1, h2, v1, v2 ) ]
  --[ Pred_not_eq( att(v2), 'wrap' ) ]->
   [ State_0112111112( ~lock8, h1, h2, v1, v2 ) ]

  /*
  rule (modulo AC) else__if_eq_att_v2____wrap__011211111:
     [ State_011211111( ~lock8, h1, h2, v1, v2 ) ]
    --[ Pred_not_eq( z, 'wrap' ) ]->
     [ State_0112111112( ~lock8, h1, h2, v1, v2 ) ]
    variants (modulo AC)
    1. v2    = v2.8
       z     = att(v2.8)
    
    2. v2    = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) event_Wrap_key_v1___key_v2__0112111111:
   [ State_0112111111( ~lock8, h1, h2, v1, v2 ) ]
  --[ Event( ), Wrap( key(v1), key(v2) ) ]->
   [ State_01121111111( ~lock8, h1, h2, v1, v2 ) ]

  /*
  rule (modulo AC) event_Wrap_key_v1___key_v2__0112111111:
     [ State_0112111111( ~lock8, h1, h2, v1, v2 ) ]
    --[ Event( ), Wrap( z, z.1 ) ]->
     [ State_01121111111( ~lock8, h1, h2, v1, v2 ) ]
    variants (modulo AC)
    1. v1    = v1.8
       v2    = v2.8
       z     = key(v1.8)
       z.1   = key(v2.8)
    
    2. v1    = v1.10
       v2    = <x.8, x.9>
       z     = key(v1.10)
       z.1   = x.8
    
    3. v1    = <x.8, x.9>
       v2    = v2.10
       z     = x.8
       z.1   = key(v2.10)
    
    4. v1    = <x.8, x.10>
       v2    = <x.9, x.11>
       z     = x.8
       z.1   = x.9
  */

rule (modulo E) out_senc_key_v2___key_v1__01121111111:
   [ State_01121111111( ~lock8, h1, h2, v1, v2 ) ]
  -->
   [
   Out( senc(key(v2), key(v1)) ),
   State_011211111111( ~lock8, h1, h2, v1, v2 )
   ]

  /*
  rule (modulo AC) out_senc_key_v2___key_v1__01121111111:
     [ State_01121111111( ~lock8, h1, h2, v1, v2 ) ]
    -->
     [ Out( senc(z, z.1) ), State_011211111111( ~lock8, h1, h2, v1, v2 )
     ]
    variants (modulo AC)
    1. v1    = v1.8
       v2    = v2.8
       z     = key(v2.8)
       z.1   = key(v1.8)
    
    2. v1    = v1.10
       v2    = <x.8, x.9>
       z     = x.8
       z.1   = key(v1.10)
    
    3. v1    = <x.8, x.9>
       v2    = v2.10
       z     = key(v2.10)
       z.1   = x.8
    
    4. v1    = <x.8, x.10>
       v2    = <x.9, x.11>
       z     = x.9
       z.1   = x.8
  */

rule (modulo E) unlock__device_011211111111:
   [ State_011211111111( ~lock8, h1, h2, v1, v2 ) ]
  --[ Unlock( ~lock8, 'device' ) ]->
   [ State_0112111111111( ~lock8, h1, h2, v1, v2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero0112111112:
   [ State_0112111112( ~lock8, h1, h2, v1, v2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero01121112:
   [ State_01121112( ~lock8, h1, h2, v1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in__h__senc_m__k__012:
   [ State_012( ), In( <h, senc(m, k)> ) ]
  -->
   [ State_0121( h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock__device_0121:
   [ State_0121( h, k, m ), Fr( ~lock10 ) ]
  --[ Lock( ~lock10, 'device' ) ]->
   [ State_01211( ~lock10, h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_h_as_v01211:
   [ State_01211( ~lock10, h, k, m ) ]
  --[ IsIn( h, v ) ]->
   [ State_012111( ~lock10, h, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) else__lookup_h_as_v01211:
   [ State_01211( ~lock10, h, k, m ) ]
  --[ IsNotSet( h ) ]->
   [ State_012112( ~lock10, h, k, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eq_att_v____wrap__012111:
   [ State_012111( ~lock10, h, k, m, v ) ]
  --[ Pred_eq( att(v), 'wrap' ) ]->
   [ State_0121111( ~lock10, h, k, m, v ) ]

  /*
  rule (modulo AC) if_eq_att_v____wrap__012111:
     [ State_012111( ~lock10, h, k, m, v ) ]
    --[ Pred_eq( z, 'wrap' ) ]->
     [ State_0121111( ~lock10, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) else__if_eq_att_v____wrap__012111:
   [ State_012111( ~lock10, h, k, m, v ) ]
  --[ Pred_not_eq( att(v), 'wrap' ) ]->
   [ State_0121112( ~lock10, h, k, m, v ) ]

  /*
  rule (modulo AC) else__if_eq_att_v____wrap__012111:
     [ State_012111( ~lock10, h, k, m, v ) ]
    --[ Pred_not_eq( z, 'wrap' ) ]->
     [ State_0121112( ~lock10, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.8
       z     = att(v.8)
    
    2. v     = <x.10, z.9>
       z     = z.9
  */

rule (modulo E) if_eq_key_v___k_0121111:
   [ State_0121111( ~lock10, h, k, m, v ) ]
  --[ Pred_eq( key(v), k ) ]->
   [ State_01211111( ~lock10, h, k, m, v ) ]

  /*
  rule (modulo AC) if_eq_key_v___k_0121111:
     [ State_0121111( ~lock10, h, k, m, v ) ]
    --[ Pred_eq( z, k ) ]->
     [ State_01211111( ~lock10, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <x.7, x.8>
       z     = x.7
  */

rule (modulo E) else__if_eq_key_v___k_0121111:
   [ State_0121111( ~lock10, h, k, m, v ) ]
  --[ Pred_not_eq( key(v), k ) ]->
   [ State_01211112( ~lock10, h, k, m, v ) ]

  /*
  rule (modulo AC) else__if_eq_key_v___k_0121111:
     [ State_0121111( ~lock10, h, k, m, v ) ]
    --[ Pred_not_eq( z, k ) ]->
     [ State_01211112( ~lock10, h, k, m, v ) ]
    variants (modulo AC)
    1. v     = v.7
       z     = key(v.7)
    
    2. v     = <x.7, x.8>
       z     = x.7
  */

rule (modulo E) new_h201211111:
   [ State_01211111( ~lock10, h, k, m, v ), Fr( h2 ) ]
  -->
   [ State_012111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_UnwrapMessage_senc_m__k__012111111:
   [ State_012111111( ~lock10, h, h2, k, m, v ) ]
  --[ Event( ), UnwrapMessage( senc(m, k) ) ]->
   [ State_0121111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Unwrapped_m_0121111111:
   [ State_0121111111( ~lock10, h, h2, k, m, v ) ]
  --[ Event( ), Unwrapped( m ) ]->
   [ State_01211111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_WrapKey_h2__m_01211111111:
   [ State_01211111111( ~lock10, h, h2, k, m, v ) ]
  --[ Event( ), WrapKey( h2, m ) ]->
   [ State_012111111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_h2__m___wrap__012111111111:
   [ State_012111111111( ~lock10, h, h2, k, m, v ) ]
  --[ Insert( h2, <m, 'wrap'> ) ]->
   [ State_0121111111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock__device_0121111111111:
   [ State_0121111111111( ~lock10, h, h2, k, m, v ) ]
  --[ Unlock( ~lock10, 'device' ) ]->
   [ State_01211111111111( ~lock10, h, h2, k, m, v ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero01211112:
   [ State_01211112( ~lock10, h, k, m, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero0121112:
   [ State_0121112( ~lock10, h, k, m, v ) ] --> [ ]

  /* has exactly the trivial AC variant */

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      (((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
       (∀ #t1. (Delete( x ) @ #t1) ⇒ ((#t1 < #t2) ∨ (#t3 < #t1)))) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒
        (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒
    ((∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1)) ∨
     (∃ #t1.
       ((Delete( x ) @ #t1) ∧ (#t1 < #t3)) ∧
       (∀ #t2 y. ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ⇒ (#t2 < #t1))))"

restriction predicate_not_eq:
  "∀ #i a b. (Pred_not_eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction predicate_eq:
  "∀ #i a b. (Pred_eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction immeadiate_in:
  "∀ t #i.
    (ChannelInEvent( t ) @ #i) ⇒
    (∃ #j.
      (((K( t ) @ #j) ∧ (#j < #i)) ∧
       (∀ #k. (Event( ) @ #k) ⇒ ((#k < #j) ∨ (#i < #k)))) ∧
      (∀ #k t2. (K( t2 ) @ #k) ⇒ (((#k < #j) ∨ (#i < #k)) ∨ (#k = #j))))"

restriction locking:
  "∀ n x np #i #j.
    ((Lock( n, x ) @ #i) ∧ (Lock( np, x ) @ #j)) ⇒
    ((((#i < #j) ∧
       (∃ #k.
         (((((Unlock( n, x ) @ #k) ∧ (#i < #k)) ∧ (#k < #j)) ∧
           (∀ #l. (Unlock( n, x ) @ #l) ⇒ (#l = #k))) ∧
          (∀ np.1 #l.
            (Lock( np.1, x ) @ #l) ⇒ (((#l < #i) ∨ (#l = #i)) ∨ (#k < #l)))) ∧
         (∀ np.1 #l.
           (Unlock( np.1, x ) @ #l) ⇒
           (((#l < #i) ∨ (#k < #l)) ∨ (#k = #l))))) ∨
      (#j < #i)) ∨
     (#i = #j))"

lemma can_create_key:
  exists-trace "∃ #t h k. NewKey( h, k ) @ #t"
/*
guarded formula characterizing all satisfying traces:
"∃ #t h k. (NewKey( h, k ) @ #t)"
*/
by sorry

lemma can_set_wrap:
  exists-trace "∃ #t h. WrapHandle( h ) @ #t"
/*
guarded formula characterizing all satisfying traces:
"∃ #t h. (WrapHandle( h ) @ #t)"
*/
by sorry

lemma dec_limits [sources]:
  all-traces
  "∀ k m #t1.
    (DecUsing( k, m ) @ #t1) ⇒
    ((((∃ h2 k2 #t2 #t3.
         (((NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)) ∧ (#t2 < #t1)) ∧
         (#t3 < #t1)) ∨
       (∃ #t2. (EncUsing( k, m ) @ #t2) ∧ (#t2 < #t1))) ∨
      (∃ h2 k2 #t2 #t3.
        (((WrapKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)) ∧ (#t2 < #t1)) ∧
        (#t3 < #t1))) ∨
     (∃ #t2 #t3 h1 h2 k2.
       (((WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)) ∧
        (#t2 < #t1)) ∧
       (#t3 < #t1)))"
/*
guarded formula characterizing all counter-examples:
"∃ k m #t1.
  (DecUsing( k, m ) @ #t1)
 ∧
  (∀ h2 k2 #t2 #t3.
    (NewKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
   ⇒
    (¬(#t2 < #t1)) ∨ (¬(#t3 < #t1))) ∧
  (∀ #t2. (EncUsing( k, m ) @ #t2) ⇒ ¬(#t2 < #t1)) ∧
  (∀ h2 k2 #t2 #t3.
    (WrapKey( h2, k2 ) @ #t2) ∧ (!KU( k2 ) @ #t3)
   ⇒
    (¬(#t2 < #t1)) ∨ (¬(#t3 < #t1))) ∧
  (∀ #t2 #t3 h1 h2 k2.
    (WrapKey( h2, k2 ) @ #t2) ∧ (DecKey( h1, k2 ) @ #t3)
   ⇒
    (¬(#t2 < #t1)) ∨ (¬(#t3 < #t1)))"
*/
by sorry

lemma bad_keys [reuse, use_induction]:
  all-traces
  "∀ h2 k #t2.
    (WrapKey( h2, k ) @ #t2) ⇒
    (((∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ (#t1 < #t2)) ∨
      (∃ h k2 #t1 #t0.
        (((NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧ (#t1 < #t2)) ∧
        (#t0 < #t2))) ∨
     (∃ #t0 #t1 h1 h2.1 k.1.
       (((WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)) ∧
        (#t0 < #t2)) ∧
       (#t1 < #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ h2 k #t2.
  (WrapKey( h2, k ) @ #t2)
 ∧
  (∀ h1 #t1. (NewKey( h1, k ) @ #t1) ⇒ ¬(#t1 < #t2)) ∧
  (∀ h k2 #t1 #t0.
    (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
   ⇒
    (¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))) ∧
  (∀ #t0 #t1 h1 h2.1 k.1.
    (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
   ⇒
    (¬(#t0 < #t2)) ∨ (¬(#t1 < #t2)))"
*/
by sorry

lemma test1 [use_induction, reuse]:
  all-traces
  "∀ h k #t2.
    (WrapKey( h, k ) @ #t2) ⇒
    (((∃ hp #t0.
        ((WrapKey( hp, k ) @ #t0) ∧ ((#t0 = #t2) ∨ (#t0 < #t2))) ∧
        (∀ hpp #t1.
          (WrapKey( hpp, k ) @ #t1) ⇒ ((#t0 = #t1) ∨ (#t0 < #t1)))) ∨
      (∃ h.1 k2 #t1 #t0.
        (((NewKey( h.1, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧ (#t1 < #t2)) ∧
        (#t0 < #t2))) ∨
     (∃ #t0 #t1 h1 h2 k.1.
       (((WrapKey( h2, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)) ∧
        (#t0 < #t2)) ∧
       (#t1 < #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ h k #t2.
  (WrapKey( h, k ) @ #t2)
 ∧
  (∀ hp #t0.
    (WrapKey( hp, k ) @ #t0)
   ⇒
    ((¬(#t0 = #t2)) ∧ (¬(#t0 < #t2))) ∨
    (∃ hpp #t1.
      (WrapKey( hpp, k ) @ #t1) ∧ (¬(#t0 = #t1)) ∧ (¬(#t0 < #t1)))) ∧
  (∀ h.1 k2 #t1 #t0.
    (NewKey( h.1, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
   ⇒
    (¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))) ∧
  (∀ #t0 #t1 h1 h2 k.1.
    (WrapKey( h2, k.1 ) @ #t0) ∧ (DecKey( h1, k.1 ) @ #t1)
   ⇒
    (¬(#t0 < #t2)) ∨ (¬(#t1 < #t2)))"
*/
by sorry

lemma no_key_is_wrap_and_dec [use_induction, reuse]:
  all-traces
  "∀ #t2 #t3 h1 h2 k.
    ((DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)) ⇒
    (((∃ h k2 #t1 #t0.
        ((NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧
        (((#t1 < #t2) ∧ (#t0 < #t2)) ∨ ((#t1 < #t3) ∧ (#t0 < #t3)))) ∨
      (∃ h k2 #t1 #t0.
        (((WrapKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)) ∧ (#t1 < #t2)) ∧
        (#t0 < #t2))) ∨
     (∃ #t0 #t1 h1.1 h2.1 k.1.
       ((WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1.1, k.1 ) @ #t1)) ∧
       (((#t0 < #t2) ∧ (#t1 < #t2)) ∨ ((#t0 < #t3) ∧ (#t1 < #t3)))))"
/*
guarded formula characterizing all counter-examples:
"∃ #t2 #t3 h1 h2 k.
  (DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)
 ∧
  (∀ h k2 #t1 #t0.
    (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
   ⇒
    ((¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))) ∧
    ((¬(#t1 < #t3)) ∨ (¬(#t0 < #t3)))) ∧
  (∀ h k2 #t1 #t0.
    (WrapKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
   ⇒
    (¬(#t1 < #t2)) ∨ (¬(#t0 < #t2))) ∧
  (∀ #t0 #t1 h1.1 h2.1 k.1.
    (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1.1, k.1 ) @ #t1)
   ⇒
    ((¬(#t0 < #t2)) ∨ (¬(#t1 < #t2))) ∧
    ((¬(#t0 < #t3)) ∨ (¬(#t1 < #t3))))"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( (∀ #t2 #t3 h1 h2 k.
           (DecKey( h1, k ) @ #t2) ∧ (WrapKey( h2, k ) @ #t3)
          ⇒
           (last(#t3)) ∨
           (last(#t2)) ∨
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (¬(last(#t0))) ∧
             (¬(last(#t1))) ∧
             (((#t1 < #t2) ∧ (#t0 < #t2)) ∨ ((#t1 < #t3) ∧ (#t0 < #t3)))) ∨
           (∃ h k2 #t1 #t0.
             (WrapKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (¬(last(#t0))) ∧ (¬(last(#t1))) ∧ (#t1 < #t2) ∧ (#t0 < #t2)) ∨
           (∃ #t0 #t1 h1.1 h2.1 k.1.
             (WrapKey( h2.1, k.1 ) @ #t0) ∧ (DecKey( h1.1, k.1 ) @ #t1)
            ∧
             (¬(last(#t1))) ∧
             (¬(last(#t0))) ∧
             (((#t0 < #t2) ∧ (#t1 < #t2)) ∨ ((#t0 < #t3) ∧ (#t1 < #t3)))))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             (last(#t2)) ∨
             (#t2 = #t3) ∨
             (#t3 < #t2) ∨
             (∃ #t1.
               (Delete( x ) @ #t1)
              ∧
               (¬(last(#t1))) ∧
               ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
               ((#t3 = #t1) ∨ (#t1 < #t3))) ∨
             (∃ #t1 yp.
               (Insert( x, yp ) @ #t1)
              ∧
               (¬(last(#t1))) ∧
               ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
               (¬(#t1 = #t2)) ∧
               ((#t3 = #t1) ∨ (#t1 < #t3)))))  ∥
         (∃ x #t3.
           (IsNotSet( x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∃ #t1 y.
             (Insert( x, y ) @ #t1)
            ∧
             (¬(last(#t1))) ∧ ((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (∀ #t1.
             (Delete( x ) @ #t1)
            ⇒
             (last(#t1)) ∨
             (#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∃ #t2 y.
               (Insert( x, y ) @ #t2)
              ∧
               (¬(last(#t2))) ∧ (#t2 < #t3) ∧ ((#t2 = #t1) ∨ (#t1 < #t2)))))  ∥
         (∃ t #i.
           (ChannelInEvent( t ) @ #i)
          ∧
           (¬(last(#i))) ∧
           (∀ #j.
             (K( t ) @ #j)
            ⇒
             (last(#j)) ∨
             (#j = #i) ∨
             (#i < #j) ∨
             (∃ #k.
               (Event( ) @ #k)
              ∧
               (¬(last(#k))) ∧
               ((#k = #j) ∨ (#j < #k)) ∧
               ((#i = #k) ∨ (#k < #i))) ∨
             (∃ #k t2.
               (K( t2 ) @ #k)
              ∧
               (¬(last(#k))) ∧
               ((#k = #j) ∨ (#j < #k)) ∧
               ((#i = #k) ∨ (#k < #i)) ∧
               (¬(#k = #j)))))  ∥
         (∃ n x np #i #j.
           (Lock( n, x ) @ #i) ∧ (Lock( np, x ) @ #j)
          ∧
           (¬(last(#j))) ∧
           (¬(last(#i))) ∧
           ((#i = #j) ∨
            (#j < #i) ∨
            (∀ #k.
              (Unlock( n, x ) @ #k)
             ⇒
              (last(#k)) ∨
              (#i = #k) ∨
              (#k < #i) ∨
              (#k = #j) ∨
              (#j < #k) ∨
              (∃ #l. (Unlock( n, x ) @ #l) ∧ (¬(last(#l))) ∧ (¬(#l = #k))) ∨
              (∃ np.1 #l.
                (Lock( np.1, x ) @ #l)
               ∧
                (¬(last(#l))) ∧
                ((#l = #i) ∨ (#i < #l)) ∧
                (¬(#l = #i)) ∧
                ((#k = #l) ∨ (#l < #k))) ∨
              (∃ np.1 #l.
                (Unlock( np.1, x ) @ #l)
               ∧
                (¬(last(#l))) ∧
                ((#l = #i) ∨ (#i < #l)) ∧
                ((#k = #l) ∨ (#l < #k)) ∧
                (¬(#k = #l))))) ∧
           ((#j = #i) ∨ (#i < #j)) ∧
           (¬(#i = #j))) )
    case case_1
    solve( (∃ hp #t0.
             (WrapKey( hp, k ) @ #t0)
            ∧
             ((#t0 = #t3) ∨ (#t0 < #t3)) ∧
             (∀ hpp #t1.
               (WrapKey( hpp, k ) @ #t1) ⇒ (#t0 = #t1) ∨ (#t0 < #t1)))  ∥
           (∃ h k2 #t1 #t0.
             (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
            ∧
             (#t1 < #t3) ∧ (#t0 < #t3))  ∥
           (∃ #t0 #t1 h1 h2 k.
             (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
            ∧
             (#t0 < #t3) ∧ (#t1 < #t3)) )
      case case_1
      solve( (∃ h1 #t1. (NewKey( h1, k ) @ #t1) ∧ #t1 < #t3)  ∥
             (∃ h k2 #t1 #t0.
               (NewKey( h, k2 ) @ #t0) ∧ (!KU( k2 ) @ #t1)
              ∧
               (#t1 < #t3) ∧ (#t0 < #t3))  ∥
             (∃ #t0 #t1 h1 h2 k.
               (WrapKey( h2, k ) @ #t0) ∧ (DecKey( h1, k ) @ #t1)
              ∧
               (#t0 < #t3) ∧ (#t1 < #t3)) )
        case case_1
        solve( State_01111121111( ~lock6, h1, v ) ▶₀ #t2 )
          case if_eq_att_v____init__0111112111
          solve( State_011111111111( h1, k, ~lock7 ) ▶₀ #t1 )
            case new_k01111111111
            solve( Insert( h1, <~n.1, 'init'> ) @ #t2.1 )
              case insert_h__k___init__0111111111111
              solve( State_0111111111111( h1, ~n.1, ~lock7.1 ) ▶₀ #t2.1 )
                case event_NewKey_h__k_011111111111
                solve( WrapKey( hp, ~n.1 ) @ #t0 )
                  case event_WrapKey_h2__m_01211111111
                  solve( State_01211111111( ~lock10, h, hp, k, ~n, v ) ▶₀ #t0 )
                    case event_Unwrapped_m_0121111111
                    solve( !KU( senc(~n.1, k) ) @ #vk.6 )
                      case csenc
                      by sorry
                    next
                      case out_m011112111111_case_1
                      by sorry
                    next
                      case out_m011112111111_case_2
                      by sorry
                    next
                      case out_m011112111111_case_3
                      by sorry
                    next
                      case out_m011112111111_case_4
                      by sorry
                    next
                      case out_m011112111111_case_5
                      by sorry
                    next
                      case out_senc_key_v2___key_v1__01121111111_case_1
                      solve( Insert( h2, <~n.1, 'wrap'> ) @ #t2.3 )
                        case insert_h2__m___wrap__012111111111
                        by sorry
                      next
                        case insert_h__key_v____wrap__0111111211111
                        by sorry
                      qed
                    next
                      case out_senc_key_v2___key_v1__01121111111_case_2
                      solve( Insert( h1, <z.1, 'wrap'> ) @ #t2.4 )
                        case insert_h2__m___wrap__012111111111
                        by sorry
                      next
                        case insert_h__key_v____wrap__0111111211111
                        by sorry
                      qed
                    next
                      case out_senc_m__key_v__0111211111
                      by sorry
                    qed
                  qed
                next
                  case event_WrapKey_h__key_v__011111121111
                  by sorry
                qed
              qed
            qed
          qed
        qed
      next
        case case_2
        by contradiction
      next
        case case_3
        by contradiction
      qed
    next
      case case_2
      by contradiction
    next
      case case_3
      by contradiction
    qed
  next
    case case_2
    by sorry
  next
    case case_3
    by sorry
  next
    case case_4
    by sorry
  next
    case case_5
    by sorry
  qed
qed

lemma cannot_obtain_key_ind [reuse, use_induction]:
  all-traces
  "¬(∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (!KU( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (!KU( k ) @ #j)"
*/
by sorry

lemma cannot_obtain_key:
  all-traces "¬(∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (K( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j h k. (NewKey( h, k ) @ #i) ∧ (K( k ) @ #j)"
*/
by sorry

/*
WARNING: the following wellformedness checks failed!

unbound:
  rule `lookup_h_as_v0111111211' has unbound variables: 
    v
  
  rule `lookup_h_as_v011111211' has unbound variables: 
    v
  
  rule `lookup_h_as_v01111211' has unbound variables: 
    v
  
  rule `lookup_h_as_v0111211' has unbound variables: 
    v
  
  rule `lookup_h1_as_v1011211' has unbound variables: 
    v1
  
  rule `lookup_h2_as_v201121111' has unbound variables: 
    v2
  
  rule `lookup_h_as_v01211' has unbound variables: 
    v
*/

end