theory StatVerif_Security_Device begin

/*
   Protocol:    Simple security device (Example 1 from [1])


   Proverif: in a few seconds
   Tamarin: in 1 minute on 64 core

*/

builtins: dest-pairing, dest-asymmetric-encryption

//options: translation-state-optimisation

let Device=(
	out(pk(~sk))
	||
	!(	lock ~s ; lookup ~s as status in
		        event Read(~s,status);
			if status='init' then
                               in('left');
                                event InitDevice(~s,'left');
				insert ~s,'left';
				unlock ~s
	)
	||
	!(	lock ~s ; lookup ~s as status in
			event Read(~s,status);
			if status='init' then
                               in('right');
                                event InitDevice(~s,'right');
				insert ~s,'right';
				unlock ~s
	)

	||
	!(
		lock ~s;
		lookup ~s as status in
	        event Read(~s,status);
		in(aencmess);
		let <x,y>=adec(aencmess,~sk) in
			if status='left' then
				event Access(~s,x); out(x); insert ~s, status; unlock ~s
			else if status='right' then
				event Access(~s,y); out(y); insert ~s, status;  unlock ~s
		else insert ~s, status; unlock ~s
         )
)

let User=new lm; new rm; event L_Exclusive(~s,lm,rm); out(aenc{<lm,rm>}pk(~sk))

process:
!( new ~sk:skey;  new ~s; insert ~s,'init';  ( Device || ! User ))

// Source lemma, taken from Tamarin's example directory:

// As we use a backwards search, we must specify the possible structure of
// messages sent in 'UseLeftDevice' and 'UseRightDevice' precise enough such
// that we can solve all chain constraints starting from the sent message. We
// therefore log the message being accessed and relate it to its possible
// origins: known to the intruder in an earlier step or part of an exclusive
// message generated by 'Alice'. Source lemmas are proven by induction and
// incorporated in the precomputation of the sources.
lemma source [sources]:
  "All s m #i. Access(s,m) @ i ==>
      (Ex #j. KU(m) @ j & j < i)  // Make use of the KU-facts logged
      //                             // by the construction rules.
    | (Ex x #j. L_Exclusive(s,x,m) @ j)
    | (Ex y #j. L_Exclusive(s,m,y) @ j)
  "

// Check that there is some trace where the intruder knows the left message of
// an exclusive message-tuple. In contrast to the source lemma, we use the
// standard 'K'-fact, which is logged by the built-in 'ISend' rule.
lemma reachability_left:
  exists-trace
  "Ex s x y #i #j. L_Exclusive(s,x,y) @i & KU(x) @j "

lemma reachability_right:
  exists-trace
  "Ex s x y #i #k. L_Exclusive(s,x,y) @i & KU(y) @ k"

lemma initnott[reuse,use_induction]:
   "All s st #t1 #t2 . Read(s,'init')@t1 & InitDevice(s,st)@t2 ==> t1 < t2"

lemma uniqInit[reuse,use_induction]:
   "All s st1 st2 #t1 #t2 . InitDevice(s,st1)@t1 & InitDevice(s,st2)@t2 ==>  #t1=#t2 "


lemma initdev2[reuse,use_induction]:
    "All s #t . Read(s,'left')@t ==> Ex #t2. InitDevice(s, 'left')@t2 & t2 < t"

lemma initdev3[reuse,use_induction]:
    "All s #t . Read(s,'right')@t ==> Ex #t2. InitDevice(s, 'right')@t2 & t2 < t"


lemma secrecyleft[reuse,use_induction]:
  "All s x y #i #k1 .  L_Exclusive(s,x,y) @i & KU(x) @ k1 ==> Ex #k2. InitDevice(s, 'left')@k2 & k2 < k1
  "

lemma secrecyright[reuse,use_induction]:
  "All s x y #i #k1 .  L_Exclusive(s,x,y) @i & KU(y) @ k1 ==> Ex #k2. InitDevice(s, 'right')@k2 & k2 < k1
  "

// Check that exclusivity is maintained
lemma secrecy[use_induction]:
  "not(Ex s x y #i #k1 #k2.
         L_Exclusive(s,x,y) @i & KU(x) @ k1 & KU(y) @ k2
      )
  "





end
