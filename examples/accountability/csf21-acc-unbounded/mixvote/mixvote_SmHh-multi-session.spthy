/*
 * Protocol: MixVote (accountability)
 * Modeler   (original): Lara Schmid
 * Modeler   (accountability): Kevin Morio and Robert KÃ¼nnemann
 * Date:     Sep 2020
 * Source:	 "Dispute Resolution in Voting", David Basin, Sasa Radomirovic, and Lara Schmid, CSF20
 * Status:   working
 */

theory mixvote_SmHh_acc_multi
begin



/*============
SPECIFICATION:
============== */

/*=====================
Functions and equations
======================= */
builtins: hashing, asymmetric-encryption

functions:
zkp/3, 		//zero knowledge proof of mix and decrypt
verzkp/4, 	//verification of zkp
encp/3, decp/2, //encryption function
sg/2, ver/2 	//new signing function

equations:

//encryption of x under pk(sk) and with randomness r; don't need randomness to decrypt it
decp(encp(x,r,pk(sk)),sk)=x,

// the function models that given a signature, one can also see the signed plaintext (only if one has the public key, but adversary has all public keys). With this, we do not explicitly have to always send the message in plaintext and signed, but only the signed one is enough.

ver(sg(m, sk), pk(sk)) = m




/* ==========
Channel rules
============= */

rule ChanOut_S: [Out_S(A,B,x)]--[ChanOut_S(A,B,x)]->[!Sec(A,B,x)]
rule ChanIn_S: [!Sec(A,B,x)]--[ChanIn_S(A,B,x)]->[In_S(A,B,x)]

rule ChanOut_A: [Out_A(A,x)]--[ChanOut_A(A,x)]->[!Auth(A,x), Out(<A,x>)]
rule ChanIn_A:	[!Auth(A,x)]--[ChanIn_A(A,x)]->[In_A(A,x)]

//reliable insecure channel from H to P: all messages sent on a reliable channel, are received unchanged
rule ChanOut_IR_HP:  	[ Out_IR_HP(A,B,m) ]--[ ChanOut_IR_HP(A,B,m) ]->[ Out(<A,B,m>) ]
rule ChanIn_IR_HP:  	[ In(<A,B,m>) ]--[ ChanIn_IR_HP(A,B,m) ]->[ In_IR_HP(A,B,m) ]
restriction Chan_R_HP:
    "All A B m #i. Send_R_HP(A,B,m) @i ==> Ex #j. Receive_R_HP(A,B,m) @j "

//reliable insecure channel from P to S: all messages sent on a reliable channel, are received unchanged
rule ChanOut_IR_PS:  	[ Out_IR_PS(A,B,m) ]--[ ChanOut_IR_PS(A,B,m) ]->[ Out(<A,B,m>) ]
rule ChanIn_IR_PS:  	[ In(<A,B,m>) ]--[ ChanIn_IR_PS(A,B,m) ]->[ In_IR_PS(A,B,m) ]
// restriction Chan_R_PS:
// 	"All A B m #i. Send_R_PS(A,B,m) @i ==> Ex #j. Receive_R_PS(A,B,m) @j "

//reliable insecure channel from S to P: all messages sent on a reliable channel, are received unchanged
rule ChanOut_IR_SP:  	[ Out_IR_SP(A,B,m) ]--[ ChanOut_IR_SP(A,B,m) ]->[ Out(<A,B,m>) ]
rule ChanIn_IR_SP:  	[ In(<A,B,m>) ]--[ ChanIn_IR_SP(A,B,m) ]->[ In_IR_SP(A,B,m) ]
restriction Chan_R_SP:
    "All A B m #i. Send_R_SP(A,B,m) @i ==> Ex #j. Receive_R_SP(A,B,m) @j "


//reliable insecure channel from P to H: all messages sent on a reliable channel, are received unchanged
rule ChanOut_IR_PH:  	[ Out_IR_PH(A,B,m) ]--[ ChanOut_IR_PH(A,B,m) ]->[ Out(<A,B,m>) ]
rule ChanIn_IR_PH:  	[ In(<A,B,m>) ]--[ ChanIn_IR_PH(A,B,m) ]->[ In_IR_PH(A,B,m) ]
restriction Chan_R_PH:
    "All A B m #i. Send_R_PH(A,B,m) @i ==> Ex #j. Receive_R_PH(A,B,m) @j "



/* ======================
Adversary's fake evidence
====================== */
// the adversary can claim any term that he knows to be evidence
rule fakeEvidence:
    [ In(<sid, ballot,evidence>) ] --[ Evidence(sid, ballot,evidence) ]-> [ ]

/* =====
Protocol
======== */

rule Init:
  [ Fr(~sid) ] --[ Init(~sid) ]-> [ !Session(~sid), Out(~sid) ]

rule publickeyinfrastructure:
  [ Fr(~skX), !Session(~sid) ]--[ LongtermKey(<~sid, $X>,~skX) ]-> [ !Ltk(<~sid,$X>,<~sid, ~skX>), !Pk(<~sid,$X>,pk(<~sid, ~skX>)), Out(pk(<~sid, ~skX>)) ]

rule Setup:
    let
        S = <~sid, $S>
        D1 = <~sid, 'D1'>
        BB = <~sid, 'BB'>
        H = <~sid, 'H'>
        H1 = <~sid, 'H1'>
        P = <~sid, 'P'>
        A = <~sid, 'A'>
    in
      [ !Session(~sid)
      , !Ltk(S,skS), !Ltk(D1,sskD1) ]
      --[ 	Setup(~sid),
        BB_pskDs(BB,<'spkD', pk(sskD1)>), //corresponds to signal BBpkD in [1]
        BB_pkS(BB,<'spkS', pk(skS)>), //corresponds to signal BBpk in [1]
        BB_H(BB,<H,H1>),
        // castBy is defined over the relation of the voters and their devices' keys
        CastByCorresp(H1, pk(sskD1)), //corresponds to signal "Corr" in [1]
        Voter(H1),
        SecretKeyD(~sid, sskD1),
        Server(S),
        Corrupted(S),
        _restrict( not($S = 'D1' | $S = 'BB' | $S = 'H' | $S = 'H1' | $S = 'P' | $S = 'A' ) )

    ]->
      [ AgSt_H0(H1,< D1,P,BB,$v1>)

    , AgSt_D0(D1,< H1,S,pk(skS),sskD1 >)

    , AgSt_A0(A,<S,BB,pk(skS)>)

    , AgSt_P0(P,<S>)
    , AgSt_P1(P,<H1>)

    , AgSt_BB0(BB, <S, pk(sskD1), pk(skS),H1>)
    , Out_A(BB,<'spkD', pk(sskD1)>)
    , Out_A(BB,<'spkS', pk(skS)>)
    , Out_A(BB,<H,H1>)

    , AgSt_S0(S, <skS, pk(sskD1)>)
    , Out(<S, <skS, pk(sskD1)>>)

      ]

rule H_1:
    let
        D = <~sid, 'D1'>
        BB = <~sid, 'BB'>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_H0(H, <D, P, BB, $v>) ]
    --[	Vote(H,$v),
        Send(H,D,$v),
        H1(~sid)
    ]->
    [ AgSt_H1(H, <D, P, BB, $v>), Out_S(H,D,$v)
    ]

rule D_1:
    let
        S = <~sid, $S>
        D = <~sid, 'D1'>
        H = <~sid, 'H1'>
        sskD = <~sid, ~sskDp>
    in
    [ AgSt_D0(D, <H,S,pkS,sskD >), In_S(H,D,v), Fr(~r) ]
    --[  	D1(~sid) ]->
    [ Out_S(D,H, sg(encp(v,~r,pkS),sskD) )
    ]

rule H_2:
    let
        S = <~sid, $S>
        D = <~sid, 'D1'>
        BB = <~sid, 'BB'>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_H1(H, <D, P, BB, $v>), In_S(D,H, b) ]
    --[	Ballot(H,b),
        Send(H,P,b),
        Comm_H_vote(H,S,$v),
        Comm_H_ballot(H,S,b),
        Send_R_HP(H,P,b),
        H2(~sid)
    ]->
    [ AgSt_H2(H, <D, P, BB, $v, b>),
      Out_IR_HP(H,P,b)
    ]

rule P: // P is partially trusted to forward messages from H to S
    let
        S = <~sid, $S>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_P0(P,<S>), In_IR_HP(H,P,b)]
    --[ Receive_R_HP(H,P,b),
        Send_R_PS(P,S,b),
        P1(~sid)
    ]->
    [  Out_IR_PS(P,S,b) ]

rule S_1a: // S is partially trusted to answer with a confirmation when receiving a valid ballot
    let
        S = <~sid, $S>
        P = <~sid, 'P'>
        skS = <~sid, ~skSp>
        sskDa = <~sid, ~sskDp>
    in
    [ AgSt_S0(S, < skS, pk(sskDa)>),
      In_IR_PS(P,S,sg(encp(va,ra,pk(skS)),sskDa)) ]
    --[ Learn_S_ballot(S,sg(encp(va,ra,pk(skS)),sskDa)),
        Receive_R_PS(P,S,sg(encp(va,ra,pk(skS)),sskDa)),
        Send_R_SP(S,P,sg(sg(encp(va,ra,pk(skS)),sskDa),skS)),
        S1(~sid)
    ]->
    [ Out_IR_SP(S,P,sg(sg(encp(va,ra,pk(skS)),sskDa),skS))
    ]

rule P_2: // P is partially trusted to forward messages from S to H
    let
        S = <~sid, $S>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_P1(P,<H>), In_IR_SP(S,P,c) ]
    --[ Receive_R_SP(S,P,c),
        Send_R_PH(P,H,c),
        P2(~sid)
    ]->
    [  Out_IR_PH(P,H,c) ]

rule H_3:
    let
        D = <~sid, 'D1'>
        BB = <~sid, 'BB'>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_H2(H, <D, P, BB, $v, b>), In_IR_PH(P,H,c)]
    --[ Receive_R_PH(P,H,c),
        Evidence(~sid, b,c),
        H3(~sid)
    ]->
    [ AgSt_H3(H, <D, P, BB, $v, b, c>)
    ]

rule BB:
    let
        S = <~sid, $S>
        BB = <~sid, 'BB'>
    in
    [ AgSt_BB0(BB, <S, spkDa, pkS,Ha>)
    , In(<S, <'b', ba >>)
    , In(<S, <'bPrime', bPrimea >>)
    , In(<S, <'v', va >>)
    , In(<S, <'zkp', p >>)
    ]
     --[	BB_rec(BB,<'b', ba >),
        BB_woS(BB,<'bPrime', bPrimea >),
        BB_tal(BB,<'v', va >),
        BB_zkp(BB,<'zkp', p >),
        End(~sid)
    ]->
    [ Out_A(BB, <'b', ba>)
    , Out_A(BB, <'bPrime', bPrimea >)
    , Out_A(BB, <'v', va>)
    , Out_A(BB, <'zkp', p >)
    ]

rule A_1:
    let
        S = <~sid, $S>
        BB = <~sid, 'BB'>
        A = <~sid, 'A'>
    in
    [ AgSt_A0(A,<S,BB,pkS>)
    // implicitly do verifyA1 (by pattern matching) since each ballot signed w/ exactly one valid verification key (also no duplicates) and since bPrime really corresponds to b without signatures:
    , In_A(BB, <'b', sg(bPrimea,sskDa) >)
    , In_A(BB, <'bPrime', bPrimea >)
    , In_A(BB, <'v', va>)
    , In_A(BB, <'zkp', p >)
    , In_A(BB, <'spkD', pk(sskDa) >)
    ]
    --[   Learn_A_proof(A, <'zkp', p >),
          Learn_A_spkDSG(A, <'spkD', pk(sskDa) >),
          Learn_A_Vs(A,<'v', va >),
          Learn_A_Bs(A,<'b', sg(bPrimea,sskDa) >),
          Learn_A_bPrimes(A,<'bPrime', bPrimea >),
          VerifyA2(A,verzkp( p, <bPrimea>,<va>,pkS) ),
          A1(~sid)
    ]->
    []

rule H_4:
    let
        D = <~sid, 'D1'>
        BB = <~sid, 'BB'>
        H = <~sid, 'H1'>
        P = <~sid, 'P'>
    in
    [ AgSt_H3(H, <D, P, BB, $v, b, c>),
      In_A(BB, <'b', ba >)
    ]
    --[	Verify(H,b,ba), //captures both VerifyC and VerifyH from [1]
          H4(~sid)
    ]->
    [   ]



/* =========
RESTRICTIONS
========= */
// there is only one setup per session
restriction OneSetup:
    "All sid #i #j. Setup(sid) @i & Setup(sid) @j ==> #i = #j "



/* ====
LEMMAS
======= */

lemma onlyonce1 [reuse]: " All sid #i #j. H1(sid) @i & H1(sid) @j ==> #i = #j "
lemma onlyonce2 [reuse]: " All sid #i #j. H2(sid) @i & H2(sid) @j ==> #i = #j "
lemma onlyonce3 [reuse]: " All sid #i #j. H3(sid) @i & H3(sid) @j ==> #i = #j "
lemma onlyonce4 [reuse]: " All sid #i #j. H4(sid) @i & H4(sid) @j ==> #i = #j "
lemma onlyonce5 [reuse]: " All sid #i #j. P1(sid)  @i & P1(sid)  @j ==> #i = #j "
lemma onlyonce6 [reuse]: " All sid #i #j. P2(sid) @i & P2(sid) @j ==> #i = #j "
lemma onlyonce7 [reuse]: " All sid #i #j. D1(sid)  @i & D1(sid)  @j ==> #i = #j "
lemma onlyonce8 [reuse]: " All sid #i #j. S1(sid) @i & S1(sid) @j ==> #i = #j "
lemma onlyonce9 [reuse]: " All sid #i #j. End(sid)@i & End(sid)@j ==> #i = #j "
lemma onlyonce10 [reuse]: " All sid #i #j. A1(sid)@i & A1(sid)@j ==> #i = #j "


/* ================
FUNCTIONAL PROPERTY
=================== */
lemma functional: exists-trace
    " Ex sid H1 H1p v
         #i #d #h b P Pp #p S Sp #s c #p2 #i2 #k #l BB BBp #m
        A Ap bPrimea skS #o
        .
        H1 = <sid, H1p>
        & P = <sid, Pp>
        & S = <sid, Sp>
        & BB = <sid, BBp>
        & A = <sid, Ap>
        & Vote(H1,v) @i
        & D1(sid) @d
        & Ballot(H1,b) @h
        & Receive_R_HP(H1,P,b)	@p

        & Receive_R_PS(P,S,b) @s
        & Send_R_SP(S,P,c) @s
        & Receive_R_SP(S,P,c) @p2
        & Send_R_PH(P,H1,c) @p2
        & Evidence(sid, b,c) @i2

        & BB_rec(BB,<'b', b  >) @k
        & BB_tal(BB,<'v', v >) @l

        & Verify(H1,b,b ) @m
        & VerifyA2(A, verzkp( zkp(<bPrimea>,<v>,skS)  ,<bPrimea>,<v>,pk(skS) )) @o
        "


/*======================
INDIVIDUAL VERIFIABILITY:
=======================*/

lemma indivVerif:
    "All sid H Hp v #i b #j .
        H = <sid, Hp>
        & Vote(H,v) @i
        & Verify(H,b,b) @j
    ==> Ex BB BBp #l r pkS sskD .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', b >) @l
        & b = sg(encp(v,r,pkS),sskD) "



/*================
DISPUTE RESOLUTION
==================*/

lemma VoterC:
    "All sid H Hp b #j b1  .
        H = <sid, Hp>
        & Verify(H,b,b1 ) @j
    ==> ( Ex BB BBp #k .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', b >) @k )
    |   //Faulty(S,b)
        ( Ex BB BBp skS #k #l #m ba .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & not (b=ba)
        & Evidence(sid, b,sg(b,skS)) @l
        & BB_pkS(BB,<'spkS', pk(skS)>) @m
        )
    |   //Faulty's second disjunct
        ( Ex BB BBp ba bPrimea sskDa #k #l #m.
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & BB_woS(BB,<'bPrime', bPrimea >)@l
        & BB_pskDs(BB,<'spkD', pk(sskDa) >)@m
        & not ba = sg(bPrimea,sskDa)
        )"

// As BB is honest, BB_recorded is always executed before End(), i.e., k<j holds as required by Definition 2 [1]. We thus omit this for optimization.
lemma TimelyP:
    "All sid H Hp b #i #j.
        H = <sid, Hp>
        & Ballot(H,b) @i & End(sid) @j & i<j
    ==> (  Ex BB BBp #k .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', b >) @k )
    |   //Faulty(S,b)
        ( Ex BB BBp skS #k #l #m ba .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & not (b=ba)
        & Evidence(sid, b,sg(b,skS)) @l
        & BB_pkS(BB,<'spkS', pk(skS)>) @m
        )
    |   //Faulty's second disjunct
        ( Ex BB BBp ba bPrimea sskDa #k #l #m.
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & BB_woS(BB,<'bPrime', bPrimea >)@l
        & BB_pskDs(BB,<'spkD', pk(sskDa) >)@m
        & not ba = sg(bPrimea,sskDa)
        )"



lemma Uniqueness:
"All #i bs sid BB BBp
    .
    BB = <sid, BBp> &
    // not exists b. Faulty(S,b)
    not (Ex b BB BBp skS #k #l #m ba .
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & not (b=ba)
        & Evidence(sid, b,sg(b,skS)) @l
        & BB_pkS(BB,<'spkS', pk(skS)>) @m
        )
    &    //Faulty's second disjunct
    not (Ex BB BBp ba bPrimea sskDa #k #l #m.
        BB = <sid, BBp>
        & BB_rec(BB,<'b', ba >) @k
        & BB_woS(BB,<'bPrime', bPrimea >)@l
        & BB_pskDs(BB,<'spkD', pk(sskDa) >)@m
        & not ba = sg(bPrimea,sskDa)
        )
    & BB_rec(BB,<'b', bs >) @i
==> (Ex BB BBp H H1 H1p bPrime1 sskD1 #bb #s #h1 P .
    BB = <sid, BBp>
    & H = <sid, 'H'>
    & H1 = <sid, H1p>
    & BB_H(BB,<H, H1 >) @bb
    //castby(b1)= H1 when:
    & bs = sg(bPrime1,sskD1)
    & CastByCorresp(H1,pk(sskD1)) @s
     & Send(H1,P,bs) @h1
     )"


/*=====================
UNIVERSAL VERIFIABILITY
=====================*/

lemma secretSskD [reuse]:
"All sid sskD #i.
    SecretKeyD(sid, sskD) @i
==> not (Ex #j. K(sskD) @j)"


lemma ballotsFromVoters [reuse]:
"All sid S Sp b #i.
    S = <sid, Sp>
    & Learn_S_ballot(S,b) @i
==> (Ex H Hp S2 S2p #j.
    H = <sid, Hp>
    & S2 = <sid, S2p>
    & Comm_H_ballot(H,S2,b) @j)"


lemma TalliedAsRecorded:
"All sid A Ap #a spkD p votes ballots bPrimes sk xa ra
    .
    A = <sid, Ap>
    & Learn_A_spkDSG(A, <'spkD', spkD >) @a
    & Learn_A_proof(A, <'zkp', p >) @a
    & Learn_A_Vs(A,<'v', votes >) @a
    & Learn_A_Bs(A,<'b', ballots >) @a
    & Learn_A_bPrimes(A,<'bPrime', bPrimes >) @a
    //by application of rule, A1 is checked;
    //by application of rule, it is made sure that the values bPrimes, votes, and p are input to the VerifyA2
    & VerifyA2(A, verzkp(zkp(<encp(xa,ra,pk(sk))>,<xa>,sk)
                ,<encp(xa,ra,pk(sk))>,<xa>,pk(sk))) @a
==> (Ex #b BB BBp r1 sskD1 #b2.
    BB = <sid, BBp>
    & BB_rec(BB,<'b', ballots >) @b
    & BB_tal(BB,<'v', votes>) @b
    & BB_pskDs(BB,<'spkD', spkD >) @b2
    & spkD =  pk(sskD1)
    & ballots = sg(encp(votes,r1,pk(sk)),sskD1)
     )"

lemma EligVerif:
"All sid A Ap #a votes sk xa ra .
    A = <sid, Ap>
    & Learn_A_Vs(A,<'v', votes >) @a
    //by application of rule, A1 is checked
    //by application of rule, it is made sure that the value 'votes' are input to the VerifyA2
    & VerifyA2(A, verzkp(zkp(<encp(xa,ra,pk(sk))>,<xa>,sk)
                ,<encp(xa,ra,pk(sk))>,<xa>,pk(sk))) @a
==> (Ex #b #b2 BB BBp H H1 H1p #h1 A1 A1p.
    BB = <sid, BBp>
    & H = <sid, 'H'>
    & H1 = <sid, H1p>
    & A1 = <sid, A1p>
    & BB_tal(BB,<'v', votes>) @b
    & BB_H(BB,<H, H1 >) @b2
    & Send(H1,A1,votes) @h1
     )"


/*================================
Accountability for server S
================================*/

test faultyS_strong_H4:
    "Ex sid Sp BB ba sskDa #i #j #k #l.
       S = <sid, Sp>
     & Server(S)@i
     & BB_rec(<sid, BB>,<'b', ba >) @j
     & BB_pskDs(<sid, BB>,<'spkD', pk(sskDa) >)@k
     & (not Ex bPrimeb. ba = sg(bPrimeb,sskDa))
     & H4(sid)@l"

lemma acc_VoterC:
  faultyS_strong_H4 accounts for
  "All sid H b #j b1. Verify(<sid, H>,b,b1 )@j ==> Ex BB #k. BB_rec(<sid, BB>,<'b', b >)@k"


test faultyS_strong_H2:
    "Ex sid Sp BB ba sskDa #i #j #k #l.
       S = <sid, Sp>
     & Server(S)@i
     & BB_rec(<sid, BB>,<'b', ba >) @j
     & BB_pskDs(<sid, BB>,<'spkD', pk(sskDa) >)@k
     & (not Ex bPrimeb. ba = sg(bPrimeb,sskDa))
     & H2(sid)@l"

lemma acc_TimelyP:
   faultyS_strong_H2 accounts for
   "All sid H b #i #j. Ballot(<sid, H>,b) @i & End(sid) @j ==> (  Ex BB #k . BB_rec(<sid, BB>,<'b', b >) @k & #i < #k & #k = #j)"



/*********************************************
Results
*********************************************/

/*
==============================================================================
summary of summaries:

analyzed: mixvote_SmHh-multi-session.spthy

  acc_VoterC_faultyS_strong_H4_suff (exists-trace): verified (13 steps)
  acc_VoterC_verif_empty (all-traces): verified (66 steps)
  acc_VoterC_faultyS_strong_H4_verif_nonempty (all-traces): verified (7 steps)
  acc_VoterC_faultyS_strong_H4_min (all-traces): verified (2 steps)
  acc_VoterC_faultyS_strong_H4_uniq (all-traces): verified (2 steps)
  acc_VoterC_faultyS_strong_H4_inj (all-traces): verified (1 steps)
  acc_VoterC_faultyS_strong_H4_single (exists-trace): verified (13 steps)
  acc_TimelyP_faultyS_strong_H2_suff (exists-trace): verified (13 steps)
  acc_TimelyP_verif_empty (all-traces): verified (67 steps)
  acc_TimelyP_faultyS_strong_H2_verif_nonempty (all-traces): verified (8 steps)
  acc_TimelyP_faultyS_strong_H2_min (all-traces): verified (2 steps)
  acc_TimelyP_faultyS_strong_H2_uniq (all-traces): verified (2 steps)
  acc_TimelyP_faultyS_strong_H2_inj (all-traces): verified (1 steps)
  acc_TimelyP_faultyS_strong_H2_single (exists-trace): verified (13 steps)

==============================================================================
*/



end
