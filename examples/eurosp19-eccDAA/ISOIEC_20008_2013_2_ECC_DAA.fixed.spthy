theory ISOIEC_20008_2013_2_ECC_DAA_FIXED
begin

/*
  Protocol:	ISOIEC_20008_2013_2_ECC_DAA
  Author: 	Jorden Whitefield
  Date: 	  November 2018

  Status:   development

  Version: TAMARIN Prover 1.5.0 commit 44d5ecbc2097ee99a22a01876e445047f2a31c54

  Citations -
      Title:   Simplified security notions of direct anonymous attestation and a concrete scheme from pairings
      Journal: Int. J. Inf. Sec.
      Authors: Ernie Brickell and Liqun Chen and Jiangtao Li
      Year:    2009

      
      Title:    On the Design and Implementation of an Efficient DAA Scheme
      Book:     Smart Card Research and Advanced Application, Springer Berlin Heidelberg
      Authors:  Chen, Liqun and Page, Dan and Smart, Nigel P.
      Year:     2013
      ISBN:     978-3-642-12510-2


      Title:    Information technology - Security techniques - Anonymous digital Signatures
                Part 2: Mechanisms using a group public key
                Mechanism 4
      Year:     2013
      ISO:      ISO/IEC 20008-2:2013
      URL:      https://www.iso.org/standard/56916.html

      --------------------------------------------

      The major outline of the file is as follows:

      - Custom functions and equations 
      - Protocol restrictions
      - Secure Channel rules
      - Adversary rules
      - Issuer Key Generation rules
      - Join operation rules
      - Sign & Verify operation rules
      - Link operation rule
      - Lemmas
          + Functional Correctness
          + Authentication
          + User-controlled Traceability
          + User-controlled Anonymity

      - Custom functions and equations:
          Full details of definition of sigma and the equations can
          be seen in the paper. We briefly state the purpose for
          each equation.

          verifyMAC       Function to verify that a MAC was signed with the generated
                          MAC key k for a message m.

          calcU           Takes a constructed U' and represents the proof of knowledge
                          in the JOIN operation, and represents that the two values of
                          the hash H2 are computed equally by the Principal Signer and
                          Issuer respectively. 

          verifyCre       A DAA credential (cre) A, B , C and D is input into the
                          equation with the Issuers public key to verify that the
                          credential received in the JOIN operation was correctly
                          constructed and signed by the Issuer.
          
          verifyBlindCre  Input a randomised credential R, S, T and W (randomised with some
                          l) and the Issuer public key and verify that the credential is
                          correctly constructed and was signed by the Issuer.
          
          calcR1          The equation reduces R1' to its normal form R1 demonstrating
                          the symbolic representation of the proof of knowledge in
                          SIGN / VERIFY operation. This equation encapsulates that
                          a J value is associated with a specific secret DAA key, tsk.

          calcR2          The equation reduces R2' to its normal form R2 demonstrating
                          the symbolic representation of the proof of knowledge in
                          SIGN / VERIFY operation. This equation encapsulates the
                          randomised credential, S in creHat, was constructed by the Assistant
                          Signer correctly and it is a valid credential that was issued by the
                          Issuer from the JOIN operation.
      
      - Protocol restrictions
          We employ a number of restrictions in our model:

          issuer_init     We consider the Issuer to be a distinct role in the protocol. This
                          choice has been made to simplify the proof, and it is important to
                          note that the Issuer can still be a corrupt entity.

          unique_pairing  We constrain a principal signer to belong to a single unique assistant
                          signer, and an assistant signer to have exactly one principal signer.
                          This models an ideal system and is representative of the real world.

          platform_init   Once a platform has performed its setup to generate its unique values
                          and endorsement key-pair, it is not allowed to do this again. This
                          restriction captures the manufacture process where secrets are
                          installed to a principal signer at manufacture time.


          equality        Such checks ensure that all instances of equality actions within traces
                          are valid, meaning that both arguments within the action must be equal.
                          We use them for modelling the verification of MACs, cre, creHat and DAA
                          signatures.

          inequality      Such checks are used to ensures that two arguments of a check are not
                          equal in a trace. This is used specifically during the platform initialisation
                          rule to specify the assistant signer and principal signer identities to be 
                          different, which in reality makes no sense either.
      
      - Secure Channel rules
          Secure channel communication could have been simply modelled through shared state facts but
          careful management of the model would have been required to ensure that only the assistant
          signer and the principal signer made use of such facts and prevented unpaired parties from
          sharing messages. Instead we introduce two rules, ChanOut_S and ChanIn_S, to create an extra
          layer of abstraction based on linear facts to explicitly model secure channels. This prevents
          communication being broadcast via the adversary, over the standard In and Out channels.
      
      - Adversary rules
          There are three rules ISSUER_KEY_REVEAL, PLATFORM_CORRUPT and REVEAL_TSK that can be used by
          the adversary. These rules allow the adversary to learn secret keys by transmitting 'Out'
          the respective keys on the public (adversary controlled, Dolev-Yao) channel. Action labels
          in these rules are then used in lemmas to describe if an adversary gains knowledge of any
          of these keys.
          
      - Issuer key generation rules
          The ISSUER_SETUP rule is used to act as a single point of authority key generation.
          Conclusion of the rule initalises the Issuer with its public / private keys, its
          generator P1 and some security parameters Ki.

      - Join operation rules
          These rules capture the behaviour described in 6.5.2 from ISO/IEC 20008-2:2013

          ISSUER_JOIN_ONE and ISSUER_JOIN_TWO capture a, b, i, j, k, l, m and n from the
          second list. These rules capture the challenge response for authentication of
          a Principal Signer and the DAA crediential A, B and C creation. These two rules
          are represented as 'Issuer Join One' and 'Issuer Join Two' in figure 1b of the
          paper.

          The PS_JOIN_ONE rule creates the proof of knowledge U and PS_TWO_JOIN rules
          create the D element of cre. Steps c, d, e, f, g, h, o, and p from the second
          list is captured by these two rules. These two rules are represented as
          'PS Join One' and 'PS Join Two' in figure 1b of the paper.

          AS_JOIN_ONE to AS_JOIN_THREE rules are used to capture the forwarding / sending of
          messages from the Issuer to Assistant Signer or vice versa. The AS_JOIN_FOUR rule
          is where the assistant signer performs the action of verifying the cre and captures
          the steps q, r, s and t; and represented as 'AS Join Four' in figure 1b of the paper.

      - Sign & Verify operation rules
          These rules capture the behaviour described in 6.5.3 from ISO/IEC 20008-2:2013.
          The message / nonce nv is chosen by the Verifier in our model and performed in the
          rule VERIFIER_SIGN_ONE. This step is represented by 'Verifier sign one' in figure
          1b of the paper.

          AS_SIGN_ONE represents the assistant signer generating its half of a DAA signature,
          capturing steps a, b, c, d, e and f in the standard. AS_SIGN_TWO is the rule that
          recieves the principal signers half of a DAA signature, and the assistant signer
          combines all the terms from AS_SIGN_ONE rule to output the signature. This is step
          n from the standard and represented by 'ASigner sign one' and 'ASigner sign two' in
          figure 1b of the paper.

          PS_SIGN_ONE generates the principal signers half of the DAA signature, capturing
          steps g, h, i, j, k, l and m in the standard. It is represented by 'PSigner Sign One'
          in figure 1b of the paper.

          These rules capture the behaviour described in 6.5.4 from ISO/IEC 20008-2:2013.
          Verification of signed DAA messages is performed by the rule VERIFIER_VERIFY_ONE_WITH_STATE
          or VERIFIER_VERIFY_ONE_NO_STATE. The rule with state models that the verifier that sent the
          message to be signed, is also the entity which verifies a signed message. The other rule
          demonstrates message verification by any other verifier. Both rules capture the functionality
          described in steps a - g. These steps are represented by 'Verifier verify one' in figure 1b
          of the paper.

      - Link operation rule
          This rule captures the behaviour described in 6.5.5 from ISO/IEC 20008-2:2013.
          Given two DAA signatures if the J's or K's are the same then the signatures
          are linked as coming from the same platform. This rule contains the action label
          'Link' which is used in a lemma to test for traceability.

      - Lemmas are described inline below towards the end of the theory file.

      --------------------------------------------

*/


builtins:   asymmetric-encryption

functions:  accept/0,
            H1/1, H2/6, H3/5, H4/8, PRF/3, calcU/1,
            MAC/2, multp/2, plus/2, minus/2, U/2,
            verifyMAC/3, s/2, calcR1/1, calcR2/1,       // s is compute_s in the paper
            verifyCre/5, verifyBlindCre/5,
            checkAnon/5, deanon/0


equations:  
            verifyMAC( m, MAC( m, k ), k ) = accept,


            calcU(        // Works: Full expansion
                  minus( multp( plus( uu, multp( H2( pk(sk_ek), P1, multp( P1, PRF( DAASeed, Ki, cnt ) ), U( uu, P1 ), pk( isk ), ni ), PRF( DAASeed, Ki, cnt ) ) ), P1 ),
                         multp( H2( pk(sk_ek), P1, multp( P1, PRF( DAASeed, Ki, cnt ) ), U( uu, P1 ), pk( isk ), ni ), multp( P1, PRF( DAASeed, Ki, cnt ) ) )
                       )
            ) = U( uu, P1 ),


            verifyCre(      // Works: Full expansion
                  multp( creRandom, P1 ), // A
                  multp( isk, multp( creRandom, P1 ) ), // B 
                  plus( multp( isk, multp( creRandom, P1 ) ), multp( multp( creRandom, isk ), multp( P1, PRF( DAASeed, Ki, cnt ) ) ) ), // C
                  multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ), // D
                  pk( isk ) // ipk
            ) = accept,


            verifyBlindCre( // Works: Full expansion
                  multp( l, multp( creRandom, P1 ) ),  // R
                  multp( l, multp( isk, multp( creRandom, P1 ) ) ), // S
                  multp( l, plus( multp( isk, multp( creRandom, P1 ) ), multp( multp( creRandom, isk ), multp( P1, PRF( DAASeed, Ki, cnt ) ) ) ) ), // T
                  multp( l, multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ) ), // W
                  pk( isk ) // ipk
            ) = accept,


            calcR1( // Works: Full expansion
              minus( multp( s( randS1, PRF( DAASeed, Ki, cnt ) ), J ), // s and J
                    multp( H4( H3(
                                        multp( l, multp( creRandom, P1 ) ), // R
                                        multp( l, multp( isk, multp( creRandom, P1 ) ) ), // S
                                        multp( l, plus( multp( isk, multp( creRandom, P1 ) ), multp( multp( creRandom, isk ), multp( P1, PRF( DAASeed, Ki, cnt ) ) ) ) ), // T
                                        multp( l, multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ) ), // W
                                        nv
                                    ),
                                  m,
                                  J,
                                  multp( PRF( DAASeed, Ki, cnt ), J ), // K
                                  bsn,
                                  multp( randS1, J ), // R1
                                  multp( randS1, multp( l, multp( isk, multp( creRandom, P1 ) ) ) ), // R2
                                  nt
                                ),
                            multp( PRF( DAASeed, Ki, cnt ), J ) // K
                          )
                    ) ) = multp( randS1, J ), // R1


            calcR2( // Works: Full expansion
              minus( multp( s( randS1, PRF( DAASeed, Ki, cnt ) ),        // s (s is compute_s in the paper)
                            multp( l, multp( isk, multp( creRandom, P1 ) ) )    // S
                          ),
                     multp( H4( // h
                              H3( // c
                                        multp( l, multp( creRandom, P1 ) ), // R
                                        multp( l, multp( isk, multp( creRandom, P1 ) ) ), // S
                                        multp( l, plus( multp( isk, multp( creRandom, P1 ) ), multp( multp( creRandom, isk ), multp( P1, PRF( DAASeed, Ki, cnt ) ) ) ) ), // T
                                        multp( l, multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ) ), // W
                                        nv
                                    ),
                                  m,
                                  J,
                                  multp( PRF( DAASeed, Ki, cnt ), J ), // K
                                  bsn,
                                  multp( randS1, J ), // R1
                                  multp( randS1, multp( l, multp( isk, multp( creRandom, P1 ) ) ) ), // R2
                                  nt
                                ),
                            multp( l, multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ) ) // W
                          )
                    ) ) = multp( randS1, multp( l, multp( isk, multp( creRandom, P1 ) ) ) ), // R2


            checkAnon(
                multp( l, multp( isk, multp( creRandom, P1 ) ) ), // S
                multp( l, multp( PRF( DAASeed, Ki, cnt ), multp( isk, multp( creRandom, P1 ) ) ) ), // W
                J,
                multp( PRF( DAASeed, Ki, cnt ), J ), // K
                PRF( DAASeed, Ki, cnt ) // tsk
            ) = deanon


// Protocol Restrictions (Axioms)
restriction issuer_init:	   "All #i #j        . IssuerInit( ) @ i & IssuerInit( ) @ j ==> #i = #j"
restriction unique_pairing:  "All #i #j x      . Unique_Pairing( x ) @ i & Unique_Pairing( x ) @ j ==> #i = #j"
restriction platform_init:   "All #i #j x y    . PlatformStart( x, y ) @ i & PlatformStart( x, y ) @ j ==> #i = #j"
restriction equality: 	     "All #i    x y    . Eq( x, y ) @ i ==> x = y"
restriction inequality:      "All #i    x      . Neq( x, x ) @ i ==> F"


// ********************************* PROTOCOL START *****************************************


/* Secure Channel rules

   Communication between the Assistant Signer (AS) and Principal Signer (PS) is done over a
   'Secure Channel'. This means that an adversary can neither modify nor learn messages that
   are sent over the channel. Sec( A, B, x ) is a linear fact modelling that the adversary
   cannot replay on this channel. Secure channels have the property of being both confidential
   and authentic. Communication between the AS and PS is constrained by the channel invariant
   !F_Paired, such that two arbitary roles cannot communicate over this channel.
*/


rule ChanOut_S [colour=ffffff]:
    [ Out_S( $A, $B, x ), !F_Paired( $A, $B ) ]
  --[ ChanOut_S( $A, $B, x ) ]->
    [ Sec( $A, $B, x ) ]


rule ChanIn_S [colour=ffffff]:
    [ Sec( $A, $B, x ) ]
  --[ ChanIn_S( $A, $B, x ) ]->
    [ In_S( $A, $B, x ) ]


/*
Setup operation
===============

The following rules captures the 'Key generation process' from section
6.5.2 in the standards document (page 20). These rules capture the
setup of an Issuer.
*/


// The rule models 6.5.2
rule ISSUER_SETUP:
  let
    ipk	= pk( ~isk ) // g). X = [x]P2 Y = [y]P2
  in
    [
        Fr( ~Ki )    // a). Representation of t := ( G1, P1, q )
      , Fr( ~P1 )    // c). Choose random generator P1
      , Fr( ~isk )   // f). x, y <- Zp  
      , Fr( ~bottom )   // ??
    ]
  --[
        IssuerInit(  )
      , UniqueExecJoin( 'ISSUER_SETUP' )    // Action label used in restriction two_joins
    ]->
    [
        !F_IssuerSK( $I, ~isk )         // Store Issuer secret key (x,y)
      , !F_IssuerPK( $I, ipk )          // Store Issuer secret key (X,Y)
      , !F_IssuerKi( $I, ~Ki )          // Store Issuer security parameters
      , !F_IssuerGenerator( $I, ~P1 )   // Store Issuer generator P1
      , !F_BSN( $I, ~bottom )              // Store group basname
      , Out( < ipk, ~Ki, ~P1, ~bottom > )  // Output all public values to adversary
    ]


/*
Adversary Rules
===============
*/

/**********************************************
 * ISSUER_KEY_REVEAL
 * Rule models the Issuer being corrupt and
 * leaking its secret key to the adversary.
 **********************************************/
rule ISSUER_KEY_REVEAL:
     [ !F_IssuerSK( $I, isk ) ]   // Recall the Issuer secret key (x,y)
   --[ IssuerKeyReveal( $I ) ]->
     [ Out( isk ) ]               // Output Issuer secret key to adversary.


/*********************************************
 * PLATFORM_CORRUPT
 * Rule models a platform being corrupt. The
 * rule concludes with the public and secret
 * endorsement being given to the adversary.
 **********************************************/
rule PLATFORM_CORRUPT:
    [
        !F_PSEk( $PS, sk_ek )
      , !F_PSPkEk( $PS, pk_ek )
    ]
  --[ RevealEK( $PS ) ]->         // Action label used to signify that the platform has been corrupt by the adversary
    [ Out( < sk_ek, pk_ek > ) ]   // Output sk_ek and pk_ek to the adversary


/*********************************************
 * REVEAL_TSK
 * Rule models a platform being corrupt. The
 * rule concludes with the secret DAA key tsk
 * being given to the adversary.
 **********************************************/
rule REVEAL_TSK:
    [ !F_PSTsk( $PS, tsk ) ]
  --[
        RevealTsk( $PS )
      , RevealPSTsk( $PS, tsk )
    ]->      // Action label used to signify that the platform has revealed its DAA key tsk to the adversary
    [
        Out( <$PS, tsk> )           // Output tsk and associated $PS to the adversary
      , !RevealedPSTsk( $PS, tsk )
    ]   


/*
Join operation
==============

    Protocol JOIN {
      I   ->  AS: {| ci, ni |}pk_ek
      AS  ->  PS: {| ci, ni |}pk_ek
      PS  ->  AS: Q2, v, w, gamma
      AS  ->   I: Q2, v, w, gamma
      I   ->  AS: {| A, B, C |}pk_ek
      AS  ->  PS: {| A, B, C |}pk_ek
      PS  ->  AS: {| A, B, C, D |}pk_ek
    }

The following rules capture the steps a) - t) in section 6.5.2
after the Issuer key generation process. For clarity and a
cleaner model we model the Platform setup process prior to
receiving the nonce challenge from the Issuer.

Please note: Communication between the Assistant Signer (AS)
and Principal Signer (PS) is performed over a secure channel.
See the Secure Channel rules (above) for more information.

Additionally, we have included the TCG Trusted Platform Module
Library version 2.0 from 2015 which says for the Issuer to use
the TPM Public Endorsement Key (pk_ek) and Chen, Page, and Smart
implement a MAC for between the PS and Issuer. These two pieces
have been included from the literature to establish a secure and
authentic channel between the Issuer and AS.
*/


// Rule models a platform being setup honestly.
rule PLATFORM_SETUP:
  let
    pk_ek = pk( ~sk_ek )                    // !!TCG assumption!! Public endorsement key
  in
    [
        Fr( ~sk_ek )                        // !!TCG assumption!! Secret endorsement key
    ]
  --[
        PlatformInit( )
      , PlatformStart( $AS, $PS )           // Action label used in restriction platform_init
      , Create( $PS )                       // Action label used in authentication lemmas
      , Neq( $AS, $PS )                     // Inequality to ensure only AS and PS can pair. E.g., AS and AS in a Paired fact is disallowed.
      , UniqueExecJoin( 'PLATFORM_SETUP' )  // Action label used in restriction two_joins 
      , Unique_Pairing( $PS )               // Action label used in restriction unique_pairing
      , Unique_Pairing( $AS )               // Action label used in restriction unique_pairing
    ]->
    [   // The following lines beginning with ! store a persistent fact for each the created terms.
        !F_PSEk( $PS, ~sk_ek )
      , !F_PSPkEk( $PS, pk_ek )
      , !F_Paired( $PS, $AS )               // The following two Paired facts are used as an invariant to the
      , !F_Paired( $AS, $PS )               // secure channel. Ensure that only paired entities can communicate.
      , St_PlatformInit( $AS, $PS )         // Linear state fact to constrain platform from re-running JOIN
      , Out( pk_ek )                        // Output pk_ek to adversary
    ]


/*****************************************************
 * ISSUER_JOIN_ONE 
 *    This rule can only be fired when a platform has
 *    been setup, controlled by the St_PlatformInit
 *    fact. This rule captures section 6.5.2 steps
 *    a and b, but in addition from Chen, Page and Smart
 *    a MAC key KM is also included. 
 * 
 *****************************************************/
rule ISSUER_JOIN_ONE:
  let
    msg   = aenc( < 'ISSUER_REQ', ~km, ~ni >, pk_ek ) // message containing MAC key km and nonce encrypted under the endorsement key
  in                                                  // A 'tag' is used to differentiate the message in Tamarin.
    [
        Fr( ~ni )                             // Step a) generate a fresh nonce
      , Fr( ~km )                             // !! Chen, Page and Smart assumption !! Generate fresh MAC key km.
      , !F_PSPkEk( $PS, pk_ek )
      , !F_IssuerPK( $I, ipk )
      , St_PlatformInit( $AS, $PS )           // Linear state fact consumed from PLATFORM_SETUP /_ADV rule
    ]
  --[
        UniqueExecJoin( 'ISSUER_JOIN_ONE' )   // Action label used in restriction two_joins
      , IssuerJoinOne( )
      , Create( $I )
    ]->
    [
        Out( msg )                                // Output the msg as defined in the local let binding to the public channel
      , St_ISSUER_JOIN_ONE( $I, $PS, ~km, ~ni )   // Save the active join session MAC key km and nonce, recalled in ISSUER_JOIN_TWO rule
    ]


/*****************************************************
 * AS_JOIN_ONE 
 *    This rule consumed the JOIN request output by the
 *    Issuer in ISSUER_JOIN_ONE rule. The purpose of
 *    this rule is for the AS to forward the message
 *    to the PS, since the AS cannot decrypt message. 
 *****************************************************/
rule AS_JOIN_ONE:
  let
    msg   = aenc( < 'ISSUER_REQ', km, ni >, pk_ek )
  in
    [ In( msg ) ]                         // Take in the message from the public channel via the DY, sent from the Issuer
  --[
        UniqueExecJoin( 'AS_JOIN_ONE' )   // Action label used in restriction two_joins
      , ASJoinOne( )
    ]->
    [ Out_S( $AS, $PS, msg ) ]            // Forward message on to the PS via the Secure channel


/*****************************************************
 * PS_JOIN_ONE 
 *    This rule consumes the JOIN request sent by the
 *    AS in AS_JOIN_ONE rule over the secure channel.
 *    The purpose of this rule is for the PS to
 *    create the proof of knowledge v to prove it is a
 *    valid PS to the Issuer. This rule captures
 *    section 6.5.2 steps d, e, f, g and in addition
 *    from Chen, Page and Smart a MAC is also computed
 *    and is denoted as gamma.
 *****************************************************/
rule PS_JOIN_ONE:
  let
    tsk     = PRF( ~DAASeed, Ki, ~cnt )               // Step c) PS derives f from its secret seed value DAASeed, Issuer params and a counter value.
    pk_ek   = pk( sk_ek )
    msg     = aenc( < 'ISSUER_REQ', km, ni >, pk_ek )
    Q2      = multp( P1, tsk )                        // Step d) compute Q2 <- [f]P1 
    U       = U( ~u, P1 )                             // Step e) compute U  <- [u]P1
    v       = H2( pk_ek, P1, Q2, U, ipk, ni )                // Step f) compute proof of knowledge v
    w       = plus( ~u, multp( v, tsk ) )             // Step g) compute w 
    gamma   = MAC( < 'gamma', P1, Q2, v, w >, km )    // !! Chen, Page and Smart assumption !! Generate MAC
  in
    [
        In_S( $AS, $PS, msg )           // Message input from AS over the secure channel
      , Fr( ~DAASeed )                  // c) fresh secret seed value
      , Fr( ~cnt )                      //    fresh counter
      , !F_IssuerKi( $I, Ki )           //    recall Issuer parameters
                                        //    All used in the derivation of tsk (f)
      , !F_PSEk( $PS, sk_ek )           
      , !F_IssuerPK( $I, ipk )          // Representative of Issuer public key (X,Y)
      , !F_IssuerGenerator( $I, P1 )
      , Fr( ~u )                        // Step e) generate fresh u used to compute U
    ]
  --[
        UniqueExecJoin( 'PS_JOIN_ONE' )  // Action label used in restriction two_joins
      , DeriveTsk( tsk )
      , PSJoinOne( )
    ]->
    [
        Out_S( $PS, $AS, < 'PS_RESP_OUT', Q2, v, w, gamma > ) // Step h) but in addition we send the MAC 'gamma'
                                                              // sent to AS over secure channel.
      , !F_PSDaaSeed( $PS, ~DAASeed )
      , !F_PSCnt( $PS, ~cnt )
      , !F_PSTsk( $PS, tsk )
    ]


/*****************************************************
 * AS_JOIN_TWO 
 *    This rule consumed the PS response of Q2, v, w
 *    and gamma. The AS then takes the response and
 *    forwards it to the Issuer over the public
 *    channel. 
 *****************************************************/
rule AS_JOIN_TWO:
    [ In_S( $PS, $AS, < 'PS_RESP_OUT', Q2, v, w, gamma > ) ] // Receive in from secure channel 
  --[
        UniqueExecJoin( 'AS_JOIN_TWO' )  // Action label used in restriction two_joins
      , ASJoinTwo( )
    ]->
    [ Out( < 'PS_RESP', Q2, v, w, gamma > ) ]


/*****************************************************
 * ISSUER_JOIN_TWO 
 *    This rule receives a response Q2, v, w and gamma
 *    from the public channel via the DY as a result
 *    of the Issuer sending out the JOIN request.
 *    To capture an open JOIN session on the Issuer end
 *    recall the use of the St_ISSUER_JOIN_ONE state
 *    fact that was introduced in the ISSUER_JOIN_ONE
 *    rule. Therefore, only valid open sessions will
 *    be verified. This rule concludes with the creation
 *    of a DAA credential A, B and C. This rule captures
 *    steps i - n in section 6.5.2 second list.
 *****************************************************/
rule ISSUER_JOIN_TWO:
  let
    gamma   = MAC( < 'gamma', P1, Q2, v, w >, km )
    msg     = < 'gamma', P1, Q2, v, w >
    wP1     = multp( w, P1 )                          // Step i) generate [w]P1
    vQ2     = multp( v, Q2 )                          // Step i) generate [v]Q2
    UPrime  = minus( wP1, vQ2 )                       // Step i) compute U' <- [w]P1 - [v]Q2
    vPrime  = H2( pk_ek, P1, Q2, calcU( UPrime ), ipk, ni )  // Step j) compute v' <- H2( P1, Q2, U', X, Y, ni )
    A       = multp( ~creRandom, P1 )                 // Step m) generate A <- [r]P1
    B       = multp( isk, A )                         // Step m) generate B <- [y]A
    C       = plus( multp( isk, A ), multp( multp( ~creRandom, isk ), Q2 ) )  // Step m) generate C <- [x]A + [rxy]Q2
    cre     = < A, B, C >
  in
    [
        In( < 'PS_RESP', Q2, v, w, gamma > )          // Message received in from public channel via DY
      , St_ISSUER_JOIN_ONE( $I, $PS, km, ni )         // Recall state about the open JOIN session from ISSUER_JOIN_ONE rule
      , Fr( ~creRandom )                              // Step l) choose fresh random integer from Zp
      , !F_IssuerSK( $I, isk )                        // Representative of Issuer secret key (x,y)
      , !F_IssuerPK( $I, ipk )                        // Representative of Issuer public key (X,Y)
      , !F_IssuerGenerator( $I, P1 )
      , !F_PSPkEk( $PS, pk_ek )
    ]
  --[
        Eq( verifyMAC( msg, gamma, km ), accept )     // !! Chen, Page and Smart assumption !! Check MAC is valid
      , Eq( v, vPrime )                               // Step k) check v == v'
      , IssuerJoinTwo(  )
      , UniqueExecJoin( 'ISSUER_JOIN_TWO' )           // Action label used in restriction two_joins
      , Running( $PS, $I, < 'creI', A, B, C > )       // Action label to capture authentication property
      , Honest( $I )                                  // Action label Honest used in authentication property
      , Honest( $PS )
    ]->
    [  Out( aenc( < 'creI', cre >, pk_ek ) ) ]        // Step n) output on the public channel the credential A, B and C encrypted under the PS public endorsement key


/*****************************************************
 * AS_JOIN_THREE 
 *    This rule consumes the encrypted message under
 *    the public endorsement key containing the A, B
 *    and C, from the Issuer in ISSUER_JOIN_TWO rule.
 *    The purpose of this rule is for the AS to forward
 *    the message to the PS, since the AS cannot
 *    decrypt message. 
 *****************************************************/
rule AS_JOIN_THREE:
    [ In( aenc( < 'creI', cre >, pk_ek ) ) ]              // Message received in from public channel via DY
  --[
        ASJoinThree( )
      , UniqueExecJoin( 'AS_JOIN_THREE' )                 // Action label used in restriction two_joins
    ]->
    [ Out_S( $AS, $PS, aenc( < 'creI', cre >, pk_ek ) ) ] // sent to PS over secure channel.


/*****************************************************
 * PS_JOIN_TWO 
 *    This rule consumes the encrypted message containing
 *    A, B and C sent by the Issuer to the AS in
 *    AS_JOIN_THREE rule and concluded with the message
 *    forward to the PS over the secure channel.
 *    The purpose of this rule is for the PS to decrypt
 *    the message to retrieve A, B and C then to create
 *    the PS part of the credential D. This rule captures
 *    section 6.5.2 steps o and p.
 *****************************************************/
rule PS_JOIN_TWO:
  let
    pk_ek   = pk( sk_ek )
    tsk     = PRF( DAASeed, Ki, cnt )   // 'f' is represented as tsk
    creI    = < A, B, C >
    D       = multp( tsk, B )           // Step o) PS computes D <- [f]B
    cre     = < A, B, C, D >
  in
    [
        In_S( $AS, $PS, aenc( < 'creI', creI >, pk_ek ) )
      , !F_PSEk( $PS, sk_ek )
      , !F_PSTsk( $PS, tsk )
    ]
  --[
        PSJoinTwo( )
      , UniqueExecJoin( 'PS_JOIN_TWO' )               // Action label used in restriction two_joins
    ]->
    [ Out_S( $PS, $AS, < 'cre', cre > ) ] // Step p) PS sends A, B, C and D to the AS


/*****************************************************
 * AS_JOIN_FOUR
 *    This rule receives the A, B, C and D sent over
 *    the secure channel from the PS. This rule
 *    validates that the DAA credential was created
 *    by the Issuer, and that the PS created its D
 *    correctly. This rule captures section 6.5.2
 *    steps q - t.
 *****************************************************/
rule AS_JOIN_FOUR:
  let
    cre     = < A, B, C, D >
  in
    [
        In_S( $PS, $AS, < 'cre', cre > )
      , !F_IssuerPK( $I, ipk )
    ]
  --[
        ASJoinFour( )
      , UniqueExecJoin( 'AS_JOIN_FOUR' )            // Action label used in restriction two_joins
      , Honest( $PS )                               // Action labels Honest used to capture authentication property
      , Honest( $I )
      , Eq( verifyCre( A, B, C, D, ipk ), accept )  // Steps q), r) and s) 
      , Commit( $I, $PS, < 'creI', A, B, C > )      // Action label to capture authentication property
      , Secret( $I, $PS, <A, B, C> )
    ]->
    [ !F_ASCre( $AS, $PS, cre ) ]                   // Step t) the AS sets this as the signature key


/*
SIGN operation
==============

    Protocol SIGN {
      V    ->    AS: nv
      AS   ->    PS: c, J, S, msg, bsn
      PS   ->    AS: K, h, s, nt
      AS   ->    V: R, S, T, W, J, K, h, s, nv, nt
    }

    The following rules capture the steps a) - n) in section 6.5.3

    Please note: Communication between the Assistant Signer (AS)
    and Principal Signer (PS) is performed over a secure channel.
    See the Secure Channel rules (above) for more information.
    s is compute_s in the paper
*/


/*****************************************************
 * VERIFIER_SIGN_ONE
 *    This rule outputs the message m and nonce nv
 *    to be signed by a platforms DAA key.
 *****************************************************/
rule VERIFIER_SIGN_ONE:
  let
    msg = < 'V1', ~nv, ~m >
  in
    [ Fr( ~nv ), Fr( ~m ) ]                       // Fresh nonce nv and message m chosen by the verifier.
  --[
        VerifierSignOne( )
      , UniqueExecSign( 'VERIFIER_SIGN_ONE' )
      , Send( $V, ~nv )                           // Action label used in functional correctness lemma's.
    ]->
    [
        Out( msg )                                // Output the message on the public channel via the DY adversary
      , St_VERIFIER_SIGN_1( $V, ~nv, ~m )         // Keep state on the message sent for use in later verification
    ]


/*****************************************************
 * AS_SIGN_ONE
 *    This rule receives in messages that have been
 *    requested to be signed by verifiers. In this
 *    rule the AS constructs its half of a DAA
 *    signature. The J is always fresh in this rule as
 *    the bsn has not previously been agreed. The J
 *    controls linkability. The rule concludes by
 *    submitting the terms c, J, S, m and bsn to the
 *    PS over the secure channel. 
 *****************************************************/
rule AS_SIGN_ONE:
  let
    msg     = < 'V1', nv, m >
    cre     = < A, B, C, D >
    R       = multp( ~l, A )                    // Step d) R <- [l]A
    S       = multp( ~l, B )                    // Step d) S <- [l]B
    T       = multp( ~l, C )                    // Step d) T <- [l]C
    W       = multp( ~l, D )                    // Step d) W <- [l]D
    c       = H3( R, S, T, W, nv )              // Step e) compute c <- H3( R || S || T || W || nv )
    PSSign  = < 'PSSign', c, ~J, S, m, bsn >     // Message to be sent to PS over secure channel
  in
    [
        In( msg )                               // Message received in from a verifier over the public channel via DY
      , !F_BSN( $I, bsn )                       // Step b) if bsn = ⊥ then fresh J else J <- H1( bsn )
      , Fr( ~J )
      , Fr( ~l )                                // Step c) fresh l from Zp
      , !F_ASCre( $AS, $PS, cre )               // Step d) recall A, B, C and D
      , Fr( ~sid )                              // Create a fresh SIGN session identifier
    ]
  --[
        ASSignOne( )
      , UniqueExecSign( 'AS_SIGN_ONE' )
    ]->
    [
        Out_S( $AS, $PS, < ~sid, PSSign > )                 // Step f) submit SIGN query to PS and identify session using ~sid
      , St_AS_SIGN_ONE( ~sid, $AS, R, S, T, W, ~J, nv, m )   // Save state of partial signature as performed by AS
    ]


/*****************************************************
 * PS_SIGN_ONE
 *    This rule receives in from the AS over the secure
 *    channel the terms the PS needs to construct its
 *    half of the signature using its DAA key tsk.
 *    Note that because of J the K is deterministic and
 *    the same K in this variant will always be output.
 *****************************************************/
rule PS_SIGN_ONE:
  let
    c         = H3( R, S, T, W, nv )
    PSSign    = < 'PSSign', c, ~J, S, m, bsn >
    tsk       = PRF( DAASeed, Ki, cnt )               // 'f' is represented as tsk
    K         = multp( tsk, ~J )                       // Step g) compute K <- [f]J
    R1        = multp( ~randS1, ~J )                   // Step j) compute R1 <- [r]J
    R2        = multp( ~randS1, S )                   // Step j) compute R2 <- [r]S
    h         = H4( c, m, ~J, K, bsn, R1, R2, ~nt )    // Step k) compute h <- H4( c || m || J || K || bsn || R1 || R2 || nt )
    s         = s( ~randS1, tsk )                     // Step l) compute s <- (r + h . f ) mod p  (s is compute_s in the paper)
    PSResp    =  < 'PSSignResp', K, h, s, ~nt >       // Message to be sent to AS over secure channel
  in
    [
        In_S( $AS, $PS, < ~sid, PSSign > )            // Receive in SIGN query from the AS over the secure channel under the session ~sid
      , Fr( ~nt )                                     // Step h) choose fresh nt
      , Fr( ~randS1 )                                 // Step i) choose fresh r from Zp
      , !F_PSTsk( $PS, tsk )
    ]
  --[
        PSSignOne( )
      , DAASign( tsk, ~J, nv )
      , UniqueExecSign( 'PS_SIGN_ONE' )
    ]->
    [ Out_S( $PS, $AS, < ~sid, PSResp > ) ]           // Step m) submit SIGN response to AS under the session ~sid


/*****************************************************
 * AS_SIGN_TWO
 *    This rule the AS receives the PS signers half of
 *    the DAA signature over the secure channel. The
 *    AS constructs the complete signature, σ, and
 *    outputs this on the network.
 *****************************************************/
rule AS_SIGN_TWO:
  let
    s         = s( ~randS1, tsk )                                 // s is compute_s in the paper
    PSResp    = < 'PSSignResp', K, h, s, ~nt >
    sigma     = < 'sigma', R, S, T, W, ~J, K, h, s, nv, ~nt >    // Step n) signer puts together the signature σ
  in
    [
        In_S( $PS, $AS, < ~sid, PSResp > )                      // Receive in SIGN response from the PS over the secure channel under the session ~sid
      , St_AS_SIGN_ONE( ~sid, $AS, R, S, T, W, ~J, nv, m )       // Recall state of partial signature as performed by AS in AS_SIGN_ONE rule
    ]
  --[
        ASSignTwo( )
      , UniqueExecSign( 'AS_SIGN_TWO' )
      , ASSendSignature( $AS, $PS, nv )
      , ASSendFullSignature( $AS, $PS, sigma )
    ]->
    [
        Sigma( sigma ),                                         // Create linear fact of the signature σ for use in the LINK rule
        Out( < 'sigma', m, sigma >  )                                            // Step n) AS outputs signatue σ on the public channel
    ]


/*
VERIFY operation
================

    The following rules capture the steps a) - g) in section 6.5.4
    We have two variants of the rule one which models a verifier as
    the one which sent the message (annotated _WITH_STATE); and the
    other rule demonstrates any verifier in our model can also do a
    verification.
*/


/*****************************************************
 * VERIFIER_VERIFY_ONE_WITH_STATE
 *    This rule models that the verifier that sent
 *    the message is the one to also verify it. This
 *    is captured by the use of the St_VERIFIER_SIGN_1
 *    linear fact. The verifier receives in a DAA
 *    signature, and verifies that it is correct.
 *****************************************************/
rule VERIFIER_VERIFY_ONE_WITH_STATE:
  let
    s         = s( randS1, tsk )                                                        // s is compute_s in the paper
    sigma     = < 'sigma', R, S, T, W, J, K, h, s, nv, nt >                             // DAA signature σ
    R1Prime   = minus( multp( s, J ), multp( h, K ) )                                   // Step c) compute R1' <- [s]J - [h]K
    R2Prime   = minus( multp( s, S ), multp( h, W ) )                                   // Step d) compute R2' <- [s]S - [h]W
    cPrime    = H3( R, S, T, W, nv )                                                    // Step e) this is the H3 in H4, we compute c' <- H3( R || S || T || W || nv )
    hPrime    = H4( cPrime, m, J, K, bsn, calcR1( R1Prime ), calcR2( R2Prime ), nt )   // Step e) compute h' <- H4( c || m || J || K || bsn || R1' || R2' || nt )
  in
    [
        In( < 'sigma', m, sigma >  )                       // DAA signature σ message received in from a platform over the public channel via DY
      , St_VERIFIER_SIGN_1( $V, nv, m )   // Creates behaviour of verifier in the group who sent the message and verifies it. Recall state from VERIFIER_SIGN_ONE rule
      , !F_BSN( $I, bsn )                 // Step a) if bsn /= ⊥ then verify J = H1( bsn )
      , !F_IssuerPK( $I, ipk )            // Representative of Issuer public key (X,Y)
    ]
  --[
        VerifierVerifyOneWS(  )
      , UniqueExecSign( 'VERIFIER_VERIFY_ONE_WS' )
      , Eq( verifyBlindCre( R, S, T, W, ipk ), accept )   // Step b) verify that: e(R, Y) = e( S, P2 ) and e( R + W, X ) = e( T, P2 )
      , Eq( hPrime, h )                                   // Step e) verify that h' == h
      , Confirm( $V, nv )
    ]->
    [ ]


/*****************************************************
 * VERIFIER_VERIFY_ONE_NO_STATE
 *    The verifier receives in a DAA signature, and
 *    verifies that it is correct. This rule models
 *    that any arbitrary verifier can receive a signature
 *    and verify it.
 *****************************************************/
rule VERIFIER_VERIFY_ONE_NO_STATE:
  let
    s         = s( randS1, tsk )                                                        // s is compute_s in the paper
    sigma     = < 'sigma', R, S, T, W, J, K, h, s, nv, nt >                             // DAA signature σ
    R1Prime   = minus( multp( s, J ), multp( h, K ) )                                   // Step c) compute R1' <- [s]J - [h]K
    R2Prime   = minus( multp( s, S ), multp( h, W ) )                                   // Step d) compute R2' <- [s]S - [h]W
    cPrime    = H3( R, S, T, W, nv )                                                    // Step e) this is the H3 in H4, we compute c' <- H3( R || S || T || W || nv )
    hPrime    = H4( cPrime, m, J, K, bsn, calcR1( R1Prime ), calcR2( R2Prime ), nt )   // Step e) compute h' <- H4( c || m || J || K || bsn || R1' || R2' || nt )
  in
    [
        In( < 'sigma', m, sigma >  )                   // DAA signature σ message received in from a platform over the public channel via DY
      , !F_BSN( $I, bsn )             // Step a) if bsn /= ⊥ then verify J = H1( bsn )
      , !F_IssuerPK( $I, ipk )        // Representative of Issuer public key (X,Y)
    ]
  --[
        VerifierVerifyOneNS(  )
      , UniqueExecSign( 'VERIFIER_VERIFY_ONE_NS' )
      , Eq( verifyBlindCre( R, S, T, W, ipk ), accept )   // Step b) verify that: e(R, Y) = e( S, P2 ) and e( R + W, X ) = e( T, P2 )
      , Eq( hPrime, h )                                   // Step e) verify that h' == h
      , Confirm( $V, nv )
    ]->
    [ ]


/*
Link operation
==============

    The following rule captures the step a) in section 6.5.5
    
    The LINK rule is used to put the action label 'Link' in the trace
    with the parameters K, K', J and J'. Given two signatures
    σ1 and σ2 the linking process takes the following step:
        + If J = J' and K = K' then the two signatures are linked.
    
    We capture the checking of this in the lemma user_controlled_independent_link_tokens
    below.
*/


rule LINK:
  let
    s         = s( randS1, tsk )                                          // s is compute_s in the paper
    sigma1    = < 'sigma', R, S, T, W, J, K, h, s, nv, nt >
    sigma2    = < 'sigma', RP, SP, TP, WP, JP, KP, hP, ssP, nvP, ntP >
  in
    [ Sigma( sigma1 ), Sigma( sigma2 )  ]
  --[ CompareLinkTokens( K, KP, J, JP ) ]->
    [ ]


/*
De-anonymise operation
======================

    The following rule demonstrates the ability to break
    anonymity of an agent, in the event that the agents
    DAA key, tsk, is known.

    The DEANONYMISE rule is used to put the action label
    'DeAnonymised' in the trace with the parameters $PS,
    tsk, and sigma. Given a signatures σ the de-anonymise
    rule executes the following:
        + If the signature is valid then
          - Using J and tsk K can be constructed
          - additionally, S or W can be used to calculate
            each respectively, with knowledge of tsk.

    We capture the checking of this in the lemma
    can_be_deanonymised below.
*/


rule DEANONYMISE:
  let
    s         = s( randS1, tsk )                                                        // s is compute_s in the paper
    sigma     = < 'sigma', R, S, T, W, J, K, h, s, nv, nt >                             // DAA signature σ
    R1Prime   = minus( multp( s, J ), multp( h, K ) )                                   // Step c) compute R1' <- [s]J - [h]K
    R2Prime   = minus( multp( s, S ), multp( h, W ) )                                   // Step d) compute R2' <- [s]S - [h]W
    cPrime    = H3( R, S, T, W, nv )                                                    // Step e) this is the H3 in H4, we compute c' <- H3( R || S || T || W || nv )
    hPrime    = H4( cPrime, m, J, K, bsn, calcR1( R1Prime ), calcR2( R2Prime ), nt )   // Step e) compute h' <- H4( c || m || J || K || bsn || R1' || R2' || nt )
  in
    [
        In( < 'sigma', m, sigma >  )    // DAA signature σ message received in from a platform over the public channel via DY
      , !F_BSN( $I, bsn )               // Step a) if bsn /= ⊥ then verify J = H1( bsn )
      , !F_IssuerPK( $I, ipk )          // Representative of Issuer public key (X,Y)
      , !RevealedPSTsk( $PS, tsk1 )       // the tsk from the reveal rule
    ]
  --[
        Eq( verifyBlindCre( R, S, T, W, ipk ), accept )   // Step b) verify that: e(R, Y) = e( S, P2 ) and e( R + W, X ) = e( T, P2 )
      , Eq( hPrime, h )                                   // Step e) verify that h' == h
      , Eq( checkAnon( S, W, J, K, tsk1 ), deanon)
      , DeAnonymised($PS, tsk1, sigma)
    ]->
    [ ]


// ********************************* PROTOCOL END   *****************************************


/*
Lemma's
=======

This section of the file details the lemma's we define for the
ECC-DAA scheme. We have three different categories of lemma's
and these are:

    + Functional Correctness
        * functional_correctness
        * functional_correctness_dishonest_send
        * functional_correctness_group_verification
    
    + Authentication
        * aliveness
        * weak_agreement_any_reveal
        * weak_agreement
        * ni_agreement_any_reveal
        * ni_agreement
        * i_agreement

    + Anonymity
        * can_be_deanonymised

    + Linkability
        * user_controlled_independent_link_tokens

Below we describe each of the above lemma's, and annotate each
one to describe the steps of the lemma.

*/


// ****************************** FUNCTIONAL CORRECTNESS ************************************


/*
functional_correctness
======================

When Both the Signer and Verifier are honest, the signatures and
their links generated by the signer will be accepted by the
verifier. This means that the SETUP, JOIN, SIGN and VERIFY operations
were executed consistently. This lemma additionally acts as a sanity
check for the model.
*/
lemma functional_correctness: exists-trace
"
Ex #a #i #j #k #l #m #n #o #p #q #r #s #t #u .

    /* There does not exist a Issuer key reveal */
    not( Ex C #k1 . IssuerKeyReveal( C )  @ k1 ) &
    /* and there does not exist a PS secret endorsement key reveal */
    not( Ex C #k2 . RevealEK( C )         @ k2 ) &
    /* and there does not exist a PS reveal of its DAA key, tsk */
    not( Ex C #k3 . RevealTsk( C )        @ k3 ) &

    /* JOIN: There exists a successful JOIN operation between a PLATFORM and the Issuer */
    PlatformInit( ) @ a &
    IssuerJoinOne( ) @ i &
    ASJoinOne( ) @ j &
    PSJoinOne( ) @ k &
    ASJoinTwo( ) @ l &
    IssuerJoinTwo( ) @ m &
    ASJoinThree( ) @ n &
    PSJoinTwo( ) @ o &
    ASJoinFour( ) @ p &

    /* SIGN: and a verifier has sent a message to be signed by a Platform */
    VerifierSignOne( ) @ q &
    ASSignOne( ) @ r &
    PSSignOne( ) @ s &
    ASSignTwo( ) @ t &

    /* VERIFY: and there exists a successful verification of a signed DAA message */
    VerifierVerifyOneWS( ) @ u &

    /* Constrain the timepoints of protocol to order in the steps presented above */
    a < i &
    i < j &
    j < k &
    k < l &
    l < m &
    m < n &
    n < o &
    o < p &
    p < q &
    q < r &
    r < s &
    s < t &
    t < u &

    /* Limit this to one platform and a single sign operation */
    ( All #i #j x . UniqueExecJoin( x ) @ i & UniqueExecJoin( x ) @ j ==> #i = #j ) &
    ( All #i #j x . UniqueExecSign( x ) @ i & UniqueExecSign( x ) @ j ==> #i = #j )
"


/*
functional_correctness_dishonest_send
=====================================
    This lemma captures that there exists a confirmation of
    a signed DAA message, but there was not a verifier that
    sent the message. Demonstrates that the scheme may not
    be protected from honest sender starvation or resource
    exhaustion.
*/
lemma functional_correctness_dishonest_send: exists-trace
"
Ex V nv #j .
  Confirm( V, nv ) @ j & not( Ex #i . Send( V, nv ) @ i )
"


/*
functional_correctness_group_verification
=========================================
    This lemma captures that there exists a send by a
    verifier V and that the signed DAA message sent by
    V can be verified by another verifier V1.
*/
lemma functional_correctness_group_verification: exists-trace
"
Ex V V1 nv #i #j .
  Send( V, nv ) @ i & Confirm( V1, nv ) @ j & not( V = V1 )
"


// ********************************* AUTHENTICATION ***************************************
// The IssuerKeyReveal(C) action is required, however the Honest(C) conjuction for the Issuer
// is not necessairy as there is only one. Hence, Honest(C) for the Issuer is always true.
// The line is present in the lemma for consistency.


lemma aliveness:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
  ==>
      /* Implies that a Issuer has previously been created (alive) */
      ( Ex #j . Create( a ) @ j )
      /* or it is the case that the issuer secret key has been revealed and claims to be honest */
      | ( Ex C #r . IssuerKeyReveal( C )  @ r & Honest( C ) @ i )
      /* or it is the case that the PS secret endorsement key has been revealed and claims to be honest */
      | ( Ex C #r . RevealEK( C ) @ r & Honest( C ) @ i )
      /* or it is the case that the PS DAA key, tsk, has been revealed and claims to be honest */
      | ( Ex C #r . RevealTsk( C ) @ r & Honest( C ) @ i )
"


lemma weak_agreement_any_reveal:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
    ==>
        /* Implies there exists a running issuer on some term(s) n2 */
        ( Ex n2 #j . Running( b, a, n2 ) @ j )
        /* or it is the case that the issuer secret key has been revealed */
        | ( Ex C #r . IssuerKeyReveal( C )  @ r )
        /* or it is the case that the PS secret endorsement key has been revealed */
        | ( Ex C #r . RevealEK( C ) @ r  )
        /* or it is the case that the PS DAA key, tsk, has been revealed */
        | ( Ex C #r . RevealTsk( C ) @ r  )
"


lemma weak_agreement:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
    ==>
        /* Implies there exists a running issuer on some term(s) n2 */
        ( Ex n2 #j . Running( b, a, n2 ) @ j )
        /* or it is the case that the used issuer from the commit at i secret key has been revealed */
        | ( Ex C #r . IssuerKeyReveal( C )  @ r & Honest( C ) @ i )
        /* or it is the case that the used PS from the commit at i secret endorsement key has been revealed */
        | ( Ex C #r . RevealEK( C ) @ r & Honest( C ) @ i )
        /* or it is the case that the used PS from the commit at i DAA key, tsk, has been revealed */
        | ( Ex C #r . RevealTsk( C ) @ r & Honest( C ) @ i )
"


lemma ni_agreement_any_reveal:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
  ==>
        /* Implies there exists a running issuer on the same term(s) n */
        ( Ex #j . Running( b, a, n ) @ j )
        /* or it is the case that the used issuer from the commit at i secret key has been revealed */
        | ( Ex C #r . IssuerKeyReveal( C )  @ r )
        /* or it is the case that the used PS from the commit at i secret endorsement key has been revealed */
        | ( Ex C #r . RevealEK( C ) @ r )
         /* or it is the case that the used PS from the commit at i DAA key, tsk, has been revealed */
        | ( Ex C #r . RevealTsk( C ) @ r )
"


lemma ni_agreement:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
  ==>
      /* Implies there exists a running issuer on the same term(s) n */
      ( Ex #j . Running( b, a, n ) @ j )
      /* or it is the case that the used issuer from the commit at i secret key has been revealed */
      | ( Ex C #r . IssuerKeyReveal( C )  @ r & Honest( C ) @ i )
      /* or it is the case that the used PS from the commit at i secret endorsement key has been revealed */
      | ( Ex C #r . RevealEK( C ) @ r & Honest( C ) @ i )
      /* or it is the case that the used PS from the commit at i DAA key, tsk, has been revealed */
      | ( Ex C #r . RevealTsk( C ) @ r & Honest( C ) @ i )
"


lemma i_agreement:
"
All a b n #i .
  /* For all commited JOIN sessions running between a platform and issuer on the term(s) n */
  Commit( a, b, n ) @ i
  ==> 
      /* Implies there exists a running issuer on the same term(s) n */
      ( Ex #j . Running( a, b, n ) @ j 
      /* and the running session occurs before the session was committed */
      & #j < #i
      /* and there does not exist another session between two other entities where the session has commit on the same term(s) n */
      & not ( Ex a2 b2 #i2 . Commit( a2, b2, n ) @ i2
          /* where the two commit events are different */
          & not ( #i2 = #i )))
            /* or it is the case that the used issuer from the commit at i secret key has been revealed */
            | ( Ex C #r . IssuerKeyReveal( C )  @ r & Honest( C ) @ i )
            /* or it is the case that the used PS from the commit at i secret endorsement key has been revealed */
            | ( Ex C #r . RevealEK( C ) @ r & Honest( C ) @ i )
            /* or it is the case that the used PS from the commit at i DAA key, tsk, has been revealed */
            | ( Ex C #r . RevealTsk( C ) @ r & Honest( C ) @ i )
"


// ********************************* SECRECY *****************************************


// CRE secrecy from the perspective of both the Issuer and the Platform.
lemma secrecy_cre:
"
  All A B x #i. 
    /* somebody claims to have setup a shared secret, */
    Secret( A, B, x ) @ i
    ==>
      /* implies the adversary does not know it */
      not( Ex #k. K( x ) @ k )
      /* or it is the case that the issuer secret key has been revealed */
    | ( Ex C #r . IssuerKeyReveal( C )  @ r & Honest( C ) @ i )
    /* or it is the case that the PS secret endorsement key has been revealed */
    | ( Ex C #r . RevealEK( C ) @ r & Honest( C ) @ i )
    /* or it is the case that the PS DAA key, tsk, has been revealed */
    | ( Ex C #r . RevealTsk( C ) @ r & Honest( C ) @ i )   
"


// ********************************* ANONYMITY *****************************************


// SHOWS CORRECT EXECUTION.
// TPM is NOT anonymous if the TPMs tsk is revealed:
lemma can_be_deanonymised: exists-trace
"
Ex AS PS sigma tsk #i #j #k #l.
  (   // we have a platform
    PlatformStart( AS, PS ) @ i
    &
    //and the platform's TPM's tsk was leaked
    RevealPSTsk( PS, tsk ) @ j
    &
    //and given any signature from that platform
    ASSendFullSignature( AS, PS, sigma )@ k
    //we can de-anonymise the TPM
    & DeAnonymised(PS, tsk, sigma) @ l
  )
"


// ********************************* LINKABILITY *****************************************
 

lemma user_controlled_independent_link_tokens:
"
All k kP j jP #i .
  /* For all Link actions in the trace */
  CompareLinkTokens( k, kP, j, jP ) @ i
  /* and if the AS decides to use different values for J */
  & not( j = jP )
  ==>
    /* Then it will be the case that K is different for each signed DAA message */
    not( k = kP )
"


/*
All well-formedness checks were successful.

end

==============================================================================
summary of summaries:

analyzed: ./ISOIEC_20008_2013_2_ECC_DAA.fixed.spthy

  functional_correctness (exists-trace): verified (47 steps)
  functional_correctness_dishonest_send (exists-trace): verified (28 steps)
  functional_correctness_group_verification (exists-trace): verified (29 steps)
  aliveness (all-traces): verified (11 steps)
  weak_agreement_any_reveal (all-traces): verified (12 steps)
  weak_agreement (all-traces): verified (123 steps)
  ni_agreement_any_reveal (all-traces): verified (12 steps)
  ni_agreement (all-traces): verified (123 steps)
  i_agreement (all-traces): falsified - found trace (12 steps)
  secrecy_cre (all-traces): verified (175 steps)
  can_be_deanonymised (exists-trace): verified (29 steps)
  user_controlled_independent_link_tokens (all-traces): verified (13 steps)

==============================================================================

real  3m23.242s
user  10m14.697s
sys 2m0.549s
*/

end
